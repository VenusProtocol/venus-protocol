{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"./IAccessControlManagerV8.sol\";\n\n/**\n * @title AccessControlledV8\n * @author Venus\n * @notice This contract is helper between access control manager and actual contract. This contract further inherited by other contract (using solidity 0.8.13)\n * to integrate access controlled mechanism. It provides initialise methods and verifying access methods.\n */\nabstract contract AccessControlledV8 is Initializable, Ownable2StepUpgradeable {\n    /// @notice Access control manager contract\n    IAccessControlManagerV8 private _accessControlManager;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n\n    /// @notice Emitted when access control manager contract address is changed\n    event NewAccessControlManager(address oldAccessControlManager, address newAccessControlManager);\n\n    /// @notice Thrown when the action is prohibited by AccessControlManager\n    error Unauthorized(address sender, address calledContract, string methodSignature);\n\n    function __AccessControlled_init(address accessControlManager_) internal onlyInitializing {\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n    }\n\n    function __AccessControlled_init_unchained(address accessControlManager_) internal onlyInitializing {\n        _setAccessControlManager(accessControlManager_);\n    }\n\n    /**\n     * @notice Sets the address of AccessControlManager\n     * @dev Admin function to set address of AccessControlManager\n     * @param accessControlManager_ The new address of the AccessControlManager\n     * @custom:event Emits NewAccessControlManager event\n     * @custom:access Only Governance\n     */\n    function setAccessControlManager(address accessControlManager_) external onlyOwner {\n        _setAccessControlManager(accessControlManager_);\n    }\n\n    /**\n     * @notice Returns the address of the access control manager contract\n     */\n    function accessControlManager() external view returns (IAccessControlManagerV8) {\n        return _accessControlManager;\n    }\n\n    /**\n     * @dev Internal function to set address of AccessControlManager\n     * @param accessControlManager_ The new address of the AccessControlManager\n     */\n    function _setAccessControlManager(address accessControlManager_) internal {\n        require(address(accessControlManager_) != address(0), \"invalid acess control manager address\");\n        address oldAccessControlManager = address(_accessControlManager);\n        _accessControlManager = IAccessControlManagerV8(accessControlManager_);\n        emit NewAccessControlManager(oldAccessControlManager, accessControlManager_);\n    }\n\n    /**\n     * @notice Reverts if the call is not allowed by AccessControlManager\n     * @param signature Method signature\n     */\n    function _checkAccessAllowed(string memory signature) internal view {\n        bool isAllowedToCall = _accessControlManager.isAllowedToCall(msg.sender, signature);\n\n        if (!isAllowedToCall) {\n            revert Unauthorized(msg.sender, address(this), signature);\n        }\n    }\n}\n"
    },
    "@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IAccessControlManagerV8\n * @author Venus\n * @notice Interface implemented by the `AccessControlManagerV8` contract.\n */\ninterface IAccessControlManagerV8 is IAccessControl {\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\n\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) external;\n\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\n\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) external view returns (bool);\n}\n"
    },
    "@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\ninterface OracleInterface {\n    function getPrice(address asset) external view returns (uint256);\n}\n\ninterface ResilientOracleInterface is OracleInterface {\n    function updatePrice(address vToken) external;\n\n    function updateAssetPrice(address asset) external;\n\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\n}\n\ninterface TwapInterface is OracleInterface {\n    function updateTwap(address asset) external returns (uint256);\n}\n\ninterface BoundValidatorInterface {\n    function validatePriceWithAnchorPrice(\n        address asset,\n        uint256 reporterPrice,\n        uint256 anchorPrice\n    ) external view returns (bool);\n}\n"
    },
    "@venusprotocol/solidity-utilities/contracts/constants.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\nuint256 constant EXP_SCALE = 1e18;\n\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\nuint256 constant MANTISSA_ONE = EXP_SCALE;\n\n/// @dev The approximate number of seconds per year\nuint256 constant SECONDS_PER_YEAR = 31_536_000;\n"
    },
    "@venusprotocol/solidity-utilities/contracts/MaxLoopsLimitHelper.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title MaxLoopsLimitHelper\n * @author Venus\n * @notice Abstract contract used to avoid collection with too many items that would generate gas errors and DoS.\n */\nabstract contract MaxLoopsLimitHelper {\n    // Limit for the loops to avoid the DOS\n    uint256 public maxLoopsLimit;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n\n    /// @notice Emitted when max loops limit is set\n    event MaxLoopsLimitUpdated(uint256 oldMaxLoopsLimit, uint256 newmaxLoopsLimit);\n\n    /// @notice Thrown an error on maxLoopsLimit exceeds for any loop\n    error MaxLoopsLimitExceeded(uint256 loopsLimit, uint256 requiredLoops);\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param limit Limit for the max loops can execute at a time\n     */\n    function _setMaxLoopsLimit(uint256 limit) internal {\n        require(limit > maxLoopsLimit, \"Comptroller: Invalid maxLoopsLimit\");\n\n        uint256 oldMaxLoopsLimit = maxLoopsLimit;\n        maxLoopsLimit = limit;\n\n        emit MaxLoopsLimitUpdated(oldMaxLoopsLimit, limit);\n    }\n\n    /**\n     * @notice Compare the maxLoopsLimit with number of the times loop iterate\n     * @param len Length of the loops iterate\n     * @custom:error MaxLoopsLimitExceeded error is thrown when loops length exceeds maxLoopsLimit\n     */\n    function _ensureMaxLoops(uint256 len) internal view {\n        if (len > maxLoopsLimit) {\n            revert MaxLoopsLimitExceeded(maxLoopsLimit, len);\n        }\n    }\n}\n"
    },
    "@venusprotocol/solidity-utilities/contracts/TimeManagerV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { SECONDS_PER_YEAR } from \"./constants.sol\";\n\nabstract contract TimeManagerV8 {\n    /// @notice Stores blocksPerYear if isTimeBased is true else secondsPerYear is stored\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable blocksOrSecondsPerYear;\n\n    /// @notice Acknowledges if a contract is time based or not\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    bool public immutable isTimeBased;\n\n    /// @notice Stores the current block timestamp or block number depending on isTimeBased\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    function() view returns (uint256) private immutable _getCurrentSlot;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n\n    /// @notice Thrown when blocks per year is invalid\n    error InvalidBlocksPerYear();\n\n    /// @notice Thrown when time based but blocks per year is provided\n    error InvalidTimeBasedConfiguration();\n\n    /**\n     * @param timeBased_ A boolean indicating whether the contract is based on time or block\n     * If timeBased is true than blocksPerYear_ param is ignored as blocksOrSecondsPerYear is set to SECONDS_PER_YEAR\n     * @param blocksPerYear_ The number of blocks per year\n     * @custom:error InvalidBlocksPerYear is thrown if blocksPerYear entered is zero and timeBased is false\n     * @custom:error InvalidTimeBasedConfiguration is thrown if blocksPerYear entered is non zero and timeBased is true\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor(bool timeBased_, uint256 blocksPerYear_) {\n        if (!timeBased_ && blocksPerYear_ == 0) {\n            revert InvalidBlocksPerYear();\n        }\n\n        if (timeBased_ && blocksPerYear_ != 0) {\n            revert InvalidTimeBasedConfiguration();\n        }\n\n        isTimeBased = timeBased_;\n        blocksOrSecondsPerYear = timeBased_ ? SECONDS_PER_YEAR : blocksPerYear_;\n        _getCurrentSlot = timeBased_ ? _getBlockTimestamp : _getBlockNumber;\n    }\n\n    /**\n     * @dev Function to simply retrieve block number or block timestamp\n     * @return Current block number or block timestamp\n     */\n    function getBlockNumberOrTimestamp() public view virtual returns (uint256) {\n        return _getCurrentSlot();\n    }\n\n    /**\n     * @dev Returns the current timestamp in seconds\n     * @return The current timestamp\n     */\n    function _getBlockTimestamp() private view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Returns the current block number\n     * @return The current block number\n     */\n    function _getBlockNumber() private view returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "@venusprotocol/solidity-utilities/contracts/validators.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/// @notice Thrown if the supplied address is a zero address where it is not allowed\nerror ZeroAddressNotAllowed();\n\n/// @notice Thrown if the supplied value is 0 where it is not allowed\nerror ZeroValueNotAllowed();\n\n/// @notice Checks if the provided address is nonzero, reverts otherwise\n/// @param address_ Address to check\n/// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\nfunction ensureNonzeroAddress(address address_) pure {\n    if (address_ == address(0)) {\n        revert ZeroAddressNotAllowed();\n    }\n}\n\n/// @notice Checks if the provided value is nonzero, reverts otherwise\n/// @param value_ Value to check\n/// @custom:error ZeroValueNotAllowed is thrown if the provided value is 0\nfunction ensureNonzeroValue(uint256 value_) pure {\n    if (value_ == 0) {\n        revert ZeroValueNotAllowed();\n    }\n}\n"
    },
    "contracts/Admin/VBNBAdmin.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IProtocolShareReserve } from \"../external/IProtocolShareReserve.sol\";\nimport { IWBNB } from \"../external/IWBNB.sol\";\nimport { VBNBAdminStorage, VTokenInterface } from \"./VBNBAdminStorage.sol\";\n\n/**\n * @title VBNBAdmin\n * @author Venus\n * @notice This contract is the \"admin\" of the vBNB market, reducing the reserves of the market, sending them to the `ProtocolShareReserve` contract,\n * and allowing the executions of the rest of the privileged functions in the vBNB contract (after checking if the sender has the required permissions).\n */\ncontract VBNBAdmin is ReentrancyGuardUpgradeable, AccessControlledV8, VBNBAdminStorage {\n    using SafeERC20Upgradeable for IWBNB;\n\n    /// @notice address of vBNB\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    VTokenInterface public immutable vBNB;\n\n    /// @notice address of WBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IWBNB public immutable WBNB;\n\n    /// @notice Emitted when PSR is updated\n    event ProtocolShareReserveUpdated(\n        IProtocolShareReserve indexed oldProtocolShareReserve,\n        IProtocolShareReserve indexed newProtocolShareReserve\n    );\n\n    /// @notice Emitted reserves are reduced\n    event ReservesReduced(uint256 reduceAmount);\n\n    /// @param _vBNB Address of the vBNB contract\n    /// @param _WBNB Address of the WBNB token\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(VTokenInterface _vBNB, IWBNB _WBNB) {\n        require(address(_WBNB) != address(0), \"WBNB address invalid\");\n        require(address(_vBNB) != address(0), \"vBNB address invalid\");\n\n        vBNB = _vBNB;\n        WBNB = _WBNB;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /// @notice Used to initialize non-immutable variables\n    function initialize(\n        IProtocolShareReserve _protocolShareReserve,\n        address accessControlManager\n    ) external initializer {\n        require(address(_protocolShareReserve) != address(0), \"PSR address invalid\");\n        protocolShareReserve = _protocolShareReserve;\n\n        __ReentrancyGuard_init();\n        __AccessControlled_init(accessControlManager);\n    }\n\n    /**\n     * @notice PSR setter.\n     * @param protocolShareReserve_ Address of the PSR contract\n     * @custom:access Only owner (Governance)\n     * @custom:event Emits ProtocolShareReserveUpdated event.\n     */\n    function setProtocolShareReserve(IProtocolShareReserve protocolShareReserve_) external onlyOwner {\n        require(address(protocolShareReserve_) != address(0), \"PSR address invalid\");\n        emit ProtocolShareReserveUpdated(protocolShareReserve, protocolShareReserve_);\n        protocolShareReserve = protocolShareReserve_;\n    }\n\n    /**\n     * @notice Reduce reserves of vBNB, wrap them and send them to the PSR contract\n     * @param reduceAmount amount of reserves to reduce\n     * @custom:event Emits ReservesReduced event.\n     */\n    function reduceReserves(uint reduceAmount) external nonReentrant {\n        require(vBNB._reduceReserves(reduceAmount) == 0, \"reduceReserves failed\");\n        _wrapBNB();\n\n        uint256 balance = WBNB.balanceOf(address(this));\n        WBNB.safeTransfer(address(protocolShareReserve), balance);\n        protocolShareReserve.updateAssetsState(\n            vBNB.comptroller(),\n            address(WBNB),\n            IProtocolShareReserve.IncomeType.SPREAD\n        );\n\n        emit ReservesReduced(reduceAmount);\n    }\n\n    /**\n     * @notice Sets the interest rate model of the vBNB contract\n     * @param newInterestRateModel Address of the new interest rate model\n     * @custom:access Controlled by ACM\n     */\n    function setInterestRateModel(address newInterestRateModel) public returns (uint256) {\n        _checkAccessAllowed(\"setInterestRateModel(address)\");\n        return vBNB._setInterestRateModel(newInterestRateModel);\n    }\n\n    /**\n     * @notice Wraps BNB into WBNB\n     */\n    function _wrapBNB() internal {\n        uint256 bnbBalance = address(this).balance;\n        WBNB.deposit{ value: bnbBalance }();\n    }\n\n    /**\n     * @notice Invoked when BNB is sent to this contract\n     * @custom:access Only vBNB is considered a valid sender\n     */\n    receive() external payable {\n        require(msg.sender == address(vBNB), \"only vBNB can send BNB to this contract\");\n    }\n\n    /**\n     * @notice Invoked when called function does not exist in the contract. The function will be executed in the vBNB contract.\n     * @custom:access Only owner (Governance)\n     */\n    fallback(bytes calldata data) external payable onlyOwner returns (bytes memory) {\n        (bool ok, bytes memory res) = address(vBNB).call{ value: msg.value }(data);\n        require(ok, \"call failed\");\n        return res;\n    }\n}\n"
    },
    "contracts/Admin/VBNBAdminStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { IProtocolShareReserve } from \"../external/IProtocolShareReserve.sol\";\n\ninterface VTokenInterface {\n    function _reduceReserves(uint reduceAmount) external returns (uint);\n\n    function _acceptAdmin() external returns (uint);\n\n    function comptroller() external returns (address);\n\n    function _setInterestRateModel(address newInterestRateModel) external returns (uint);\n}\n\ncontract VBNBAdminStorage {\n    /// @notice address of protocol share reserve contract\n    IProtocolShareReserve public protocolShareReserve;\n\n    /// @dev gap to prevent collision in inheritence\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/Comptroller/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { VAIControllerInterface } from \"../Tokens/VAI/VAIControllerInterface.sol\";\n\nenum Action {\n    MINT,\n    REDEEM,\n    BORROW,\n    REPAY,\n    SEIZE,\n    LIQUIDATE,\n    TRANSFER,\n    ENTER_MARKET,\n    EXIT_MARKET\n}\n\ninterface ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() external pure returns (bool);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory);\n\n    function enterMarket(address user, address vToken) external returns (uint256);\n\n    function exitMarket(address vToken) external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address vToken, address minter, uint mintAmount) external returns (uint);\n\n    function mintVerify(address vToken, address minter, uint mintAmount, uint mintTokens) external;\n\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external returns (uint);\n\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external returns (uint);\n\n    function borrowAllowed(\n        address vToken,\n        address borrower,\n        address receiver,\n        uint borrowAmount\n    ) external returns (uint);\n\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external;\n\n    function repayBorrowAllowed(\n        address vToken,\n        address payer,\n        address borrower,\n        uint repayAmount\n    ) external returns (uint);\n\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint repayAmount,\n        uint borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount\n    ) external returns (uint);\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        uint seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenOrExecutor,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external returns (uint);\n\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external;\n\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external returns (uint);\n\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function setMintedVAIOf(address owner, uint amount) external returns (uint);\n\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function getXVSAddress() external view returns (address);\n\n    function markets(address) external view returns (bool, uint);\n\n    function oracle() external view returns (ResilientOracleInterface);\n\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\n\n    function getAssetsIn(address) external view returns (VToken[] memory);\n\n    function claimVenus(address) external;\n\n    function venusAccrued(address) external view returns (uint);\n\n    function venusSupplySpeeds(address) external view returns (uint);\n\n    function venusBorrowSpeeds(address) external view returns (uint);\n\n    function getAllMarkets() external view returns (VToken[] memory);\n\n    function venusSupplierIndex(address, address) external view returns (uint);\n\n    function venusInitialIndex() external view returns (uint224);\n\n    function venusBorrowerIndex(address, address) external view returns (uint);\n\n    function venusBorrowState(address) external view returns (uint224, uint32);\n\n    function venusSupplyState(address) external view returns (uint224, uint32);\n\n    function approvedDelegates(address borrower, address delegate) external view returns (bool);\n\n    function vaiController() external view returns (VAIControllerInterface);\n\n    function liquidationIncentiveMantissa() external view returns (uint);\n\n    function protocolPaused() external view returns (bool);\n\n    function actionPaused(address market, Action action) external view returns (bool);\n\n    function mintedVAIs(address user) external view returns (uint);\n\n    function vaiMintRate() external view returns (uint);\n}\n\ninterface IVAIVault {\n    function updatePendingRewards() external;\n}\n\ninterface IComptroller {\n    function liquidationIncentiveMantissa() external view returns (uint);\n\n    /*** Treasury Data ***/\n    function treasuryAddress() external view returns (address);\n\n    function treasuryPercent() external view returns (uint);\n}\n"
    },
    "contracts/Comptroller/ComptrollerLensInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\n\ninterface ComptrollerLensInterface {\n    function liquidateCalculateSeizeTokens(\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function liquidateVAICalculateSeizeTokens(\n        address comptroller,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function getHypotheticalAccountLiquidity(\n        address comptroller,\n        address account,\n        VToken vTokenModify,\n        uint redeemTokens,\n        uint borrowAmount\n    ) external view returns (uint, uint, uint);\n}\n"
    },
    "contracts/Comptroller/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { VAIControllerInterface } from \"../Tokens/VAI/VAIControllerInterface.sol\";\nimport { ComptrollerLensInterface } from \"./ComptrollerLensInterface.sol\";\nimport { IPrime } from \"../Tokens/Prime/IPrime.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public comptrollerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    ResilientOracleInterface public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint256 public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => VToken[]) public accountAssets;\n\n    struct Market {\n        /// @notice Whether or not this market is listed\n        bool isListed;\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /// @notice Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n        /// @notice Whether or not this market receives XVS\n        bool isVenus;\n    }\n\n    /**\n     * @notice Official mapping of vTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    address public pauseGuardian;\n\n    /// @notice Whether minting is paused (deprecated, superseded by actionPaused)\n    bool private _mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool private _borrowGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal transferGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal seizeGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal borrowGuardianPaused;\n\n    struct VenusMarketState {\n        /// @notice The market's last updated venusBorrowIndex or venusSupplyIndex\n        uint224 index;\n        /// @notice The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice A list of all markets\n    VToken[] public allMarkets;\n\n    /// @notice The rate at which the flywheel distributes XVS, per block\n    uint256 internal venusRate;\n\n    /// @notice The portion of venusRate that each market currently receives\n    mapping(address => uint256) internal venusSpeeds;\n\n    /// @notice The Venus market supply state for each market\n    mapping(address => VenusMarketState) public venusSupplyState;\n\n    /// @notice The Venus market borrow state for each market\n    mapping(address => VenusMarketState) public venusBorrowState;\n\n    /// @notice The Venus supply index for each market for each supplier as of the last time they accrued XVS\n    mapping(address => mapping(address => uint256)) public venusSupplierIndex;\n\n    /// @notice The Venus borrow index for each market for each borrower as of the last time they accrued XVS\n    mapping(address => mapping(address => uint256)) public venusBorrowerIndex;\n\n    /// @notice The XVS accrued but not yet transferred to each user\n    mapping(address => uint256) public venusAccrued;\n\n    /// @notice The Address of VAIController\n    VAIControllerInterface public vaiController;\n\n    /// @notice The minted VAI amount to each user\n    mapping(address => uint256) public mintedVAIs;\n\n    /// @notice VAI Mint Rate as a percentage\n    uint256 public vaiMintRate;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    bool public mintVAIGuardianPaused;\n    bool public repayVAIGuardianPaused;\n\n    /**\n     * @notice Pause/Unpause whole protocol actions\n     */\n    bool public protocolPaused;\n\n    /// @notice The rate at which the flywheel distributes XVS to VAI Minters, per block (deprecated)\n    uint256 private venusVAIRate;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    /// @notice The rate at which the flywheel distributes XVS to VAI Vault, per block\n    uint256 public venusVAIVaultRate;\n\n    // address of VAI Vault\n    address public vaiVaultAddress;\n\n    // start block of release to VAI Vault\n    uint256 public releaseStartBlock;\n\n    // minimum release amount to VAI Vault\n    uint256 public minReleaseAmount;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address.\n    mapping(address => uint256) public borrowCaps;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n    /// @notice Treasury Guardian address\n    address public treasuryGuardian;\n\n    /// @notice Treasury address\n    address public treasuryAddress;\n\n    /// @notice Fee percent of accrued interest with decimal 18\n    uint256 public treasuryPercent;\n}\n\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\n    /// @notice The portion of XVS that each contributor receives per block (deprecated)\n    mapping(address => uint256) private venusContributorSpeeds;\n\n    /// @notice Last block at which a contributor's XVS rewards have been allocated (deprecated)\n    mapping(address => uint256) private lastContributorBlock;\n}\n\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\n    address public liquidatorContract;\n}\n\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\n    ComptrollerLensInterface public comptrollerLens;\n}\n\ncontract ComptrollerV8Storage is ComptrollerV7Storage {\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\n    mapping(address => uint256) public supplyCaps;\n}\n\ncontract ComptrollerV9Storage is ComptrollerV8Storage {\n    /// @notice AccessControlManager address\n    address internal accessControl;\n\n    /// @notice True if a certain action is paused on a certain market\n    mapping(address => mapping(uint256 => bool)) internal _actionPaused;\n}\n\ncontract ComptrollerV10Storage is ComptrollerV9Storage {\n    /// @notice The rate at which venus is distributed to the corresponding borrow market (per block)\n    mapping(address => uint256) public venusBorrowSpeeds;\n\n    /// @notice The rate at which venus is distributed to the corresponding supply market (per block)\n    mapping(address => uint256) public venusSupplySpeeds;\n}\n\ncontract ComptrollerV11Storage is ComptrollerV10Storage {\n    /// @notice Whether the delegate is allowed to borrow or redeem on behalf of the user\n    //mapping(address user => mapping (address delegate => bool approved)) public approvedDelegates;\n    mapping(address => mapping(address => bool)) public approvedDelegates;\n}\n\ncontract ComptrollerV12Storage is ComptrollerV11Storage {\n    /// @notice Whether forced liquidation is enabled for all users borrowing in a certain market\n    mapping(address => bool) public isForcedLiquidationEnabled;\n}\n\ncontract ComptrollerV13Storage is ComptrollerV12Storage {\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in _facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in _facetAddresses array\n    }\n\n    mapping(bytes4 => FacetAddressAndPosition) internal _selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) internal _facetFunctionSelectors;\n    // facet addresses\n    address[] internal _facetAddresses;\n}\n\ncontract ComptrollerV14Storage is ComptrollerV13Storage {\n    /// @notice Prime token address\n    IPrime public prime;\n}\n\ncontract ComptrollerV15Storage is ComptrollerV14Storage {\n    /// @notice Whether forced liquidation is enabled for the borrows of a user in a market\n    mapping(address user => mapping(address market => bool)) public isForcedLiquidationEnabledForUser;\n}\n\ncontract ComptrollerV16Storage is ComptrollerV15Storage {\n    /// @notice The XVS token contract address\n    address internal xvs;\n\n    /// @notice The XVS vToken contract address\n    address internal xvsVToken;\n}\n\ncontract ComptrollerV17Storage is ComptrollerV16Storage {\n    /// @notice Accounts that are whitelisted to execute certain actions (seize, borrow etc) without restrictions\n    mapping(address => bool) public whitelistedExecutors;\n}\n"
    },
    "contracts/Comptroller/Diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport { Unitroller } from \"../Unitroller.sol\";\nimport { ComptrollerV17Storage } from \"../ComptrollerStorage.sol\";\n\n/**\n * @title Diamond\n * @author Venus\n * @notice This contract contains functions related to facets\n */\ncontract Diamond is IDiamondCut, ComptrollerV17Storage {\n    /// @notice Emitted when functions are added, replaced or removed to facets\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut);\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /**\n     * @notice Call _acceptImplementation to accept the diamond proxy as new implementaion\n     * @param unitroller Address of the unitroller\n     */\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    /**\n     * @notice To add function selectors to the facet's mapping\n     * @dev Allows the contract admin to add function selectors\n     * @param diamondCut_ IDiamondCut contains facets address, action and function selectors\n     */\n    function diamondCut(IDiamondCut.FacetCut[] memory diamondCut_) public {\n        require(msg.sender == admin, \"only unitroller admin can\");\n        libDiamondCut(diamondCut_);\n    }\n\n    /**\n     * @notice Get all function selectors mapped to the facet address\n     * @param facet Address of the facet\n     * @return selectors Array of function selectors\n     */\n    function facetFunctionSelectors(address facet) external view returns (bytes4[] memory) {\n        return _facetFunctionSelectors[facet].functionSelectors;\n    }\n\n    /**\n     * @notice Get facet position in the _facetFunctionSelectors through facet address\n     * @param facet Address of the facet\n     * @return Position of the facet\n     */\n    function facetPosition(address facet) external view returns (uint256) {\n        return _facetFunctionSelectors[facet].facetAddressPosition;\n    }\n\n    /**\n     * @notice Get all facet addresses\n     * @return facetAddresses Array of facet addresses\n     */\n    function facetAddresses() external view returns (address[] memory) {\n        return _facetAddresses;\n    }\n\n    /**\n     * @notice Get facet address and position through function selector\n     * @param functionSelector function selector\n     * @return FacetAddressAndPosition facet address and position\n     */\n    function facetAddress(\n        bytes4 functionSelector\n    ) external view returns (ComptrollerV17Storage.FacetAddressAndPosition memory) {\n        return _selectorToFacetAndPosition[functionSelector];\n    }\n\n    /**\n     * @notice Get all facets address and their function selector\n     * @return facets_ Array of Facet\n     */\n    function facets() external view returns (Facet[] memory) {\n        uint256 facetsLength = _facetAddresses.length;\n        Facet[] memory facets_ = new Facet[](facetsLength);\n        for (uint256 i; i < facetsLength; ++i) {\n            address facet = _facetAddresses[i];\n            facets_[i].facetAddress = facet;\n            facets_[i].functionSelectors = _facetFunctionSelectors[facet].functionSelectors;\n        }\n        return facets_;\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping\n     * @param diamondCut_ IDiamondCut contains facets address, action and function selectors\n     */\n    function libDiamondCut(IDiamondCut.FacetCut[] memory diamondCut_) internal {\n        uint256 diamondCutLength = diamondCut_.length;\n        for (uint256 facetIndex; facetIndex < diamondCutLength; ++facetIndex) {\n            IDiamondCut.FacetCutAction action = diamondCut_[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(diamondCut_);\n    }\n\n    /**\n     * @notice Add function selectors to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to add in the mapping\n     */\n    function addFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        require(functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(_facetFunctionSelectors[facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(facetAddress);\n        }\n        uint256 functionSelectorsLength = functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(selector, selectorPosition, facetAddress);\n            ++selectorPosition;\n        }\n    }\n\n    /**\n     * @notice Replace facet's address mapping for function selectors i.e selectors already associate to any other existing facet\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to replace in the mapping\n     */\n    function replaceFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        require(functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(_facetFunctionSelectors[facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(facetAddress);\n        }\n        uint256 functionSelectorsLength = functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            addFunction(selector, selectorPosition, facetAddress);\n            ++selectorPosition;\n        }\n    }\n\n    /**\n     * @notice Remove function selectors to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to remove in the mapping\n     */\n    function removeFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        uint256 functionSelectorsLength = functionSelectors.length;\n        require(functionSelectorsLength != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and revert\n        require(facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    /**\n     * @notice Add new facet to the proxy\n     * @param facetAddress Address of the facet\n     */\n    function addFacet(address facetAddress) internal {\n        enforceHasContractCode(facetAddress, \"Diamond: New facet has no code\");\n        _facetFunctionSelectors[facetAddress].facetAddressPosition = _facetAddresses.length;\n        _facetAddresses.push(facetAddress);\n    }\n\n    /**\n     * @notice Add function selector to the facet's address mapping\n     * @param selector funciton selector need to be added\n     * @param selectorPosition funciton selector position\n     * @param facetAddress Address of the facet\n     */\n    function addFunction(bytes4 selector, uint96 selectorPosition, address facetAddress) internal {\n        _selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n        _facetFunctionSelectors[facetAddress].functionSelectors.push(selector);\n        _selectorToFacetAndPosition[selector].facetAddress = facetAddress;\n    }\n\n    /**\n     * @notice Remove function selector to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param selector function selectors need to remove in the mapping\n     */\n    function removeFunction(address facetAddress, bytes4 selector) internal {\n        require(facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = _selectorToFacetAndPosition[selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = _facetFunctionSelectors[facetAddress].functionSelectors.length - 1;\n        // if not the same then replace selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = _facetFunctionSelectors[facetAddress].functionSelectors[lastSelectorPosition];\n            _facetFunctionSelectors[facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            _selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        _facetFunctionSelectors[facetAddress].functionSelectors.pop();\n        delete _selectorToFacetAndPosition[selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = _facetAddresses.length - 1;\n            uint256 facetAddressPosition = _facetFunctionSelectors[facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = _facetAddresses[lastFacetAddressPosition];\n                _facetAddresses[facetAddressPosition] = lastFacetAddress;\n                _facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            _facetAddresses.pop();\n            delete _facetFunctionSelectors[facetAddress];\n        }\n    }\n\n    /**\n     * @dev Ensure that the given address has contract code deployed\n     * @param _contract The address to check for contract code\n     * @param _errorMessage The error message to display if the contract code is not deployed\n     */\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize != 0, _errorMessage);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external {\n        address facet = _selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute public function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/DiamondConsolidated.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { MarketFacet } from \"./facets/MarketFacet.sol\";\nimport { PolicyFacet } from \"./facets/PolicyFacet.sol\";\nimport { RewardFacet } from \"./facets/RewardFacet.sol\";\nimport { SetterFacet } from \"./facets/SetterFacet.sol\";\nimport { Diamond } from \"./Diamond.sol\";\n\n/**\n * @title DiamondConsolidated\n * @author Venus\n * @notice This contract contains the functions defined in the different facets of the Diamond, plus the getters to the public variables.\n * This contract cannot be deployed, due to its size. Its main purpose is to allow the easy generation of an ABI and the typechain to interact with the\n * Unitroller contract in a simple way\n */\ncontract DiamondConsolidated is Diamond, MarketFacet, PolicyFacet, RewardFacet, SetterFacet {}\n"
    },
    "contracts/Comptroller/Diamond/facets/FacetBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { ComptrollerErrorReporter } from \"../../../Utils/ErrorReporter.sol\";\nimport { ExponentialNoError } from \"../../../Utils/ExponentialNoError.sol\";\nimport { IVAIVault, Action } from \"../../../Comptroller/ComptrollerInterface.sol\";\nimport { ComptrollerV17Storage } from \"../../../Comptroller/ComptrollerStorage.sol\";\nimport { IFacetBase } from \"../interfaces/IFacetBase.sol\";\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title FacetBase\n * @author Venus\n * @notice This facet contract contains functions related to access and checks\n */\ncontract FacetBase is IFacetBase, ComptrollerV17Storage, ExponentialNoError, ComptrollerErrorReporter {\n    using SafeERC20 for IERC20;\n\n    /// @notice The initial Venus index for a market\n    uint224 public constant venusInitialIndex = 1e36;\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(VToken indexed vToken, address indexed account);\n\n    /// @notice Emitted when XVS is distributed to VAI Vault\n    event DistributedVAIVaultVenus(uint256 amount);\n\n    /// @notice Reverts if the protocol is paused\n    function checkProtocolPauseState() internal view {\n        require(!protocolPaused, \"protocol is paused\");\n    }\n\n    /// @notice Reverts if a certain action is paused on a market\n    function checkActionPauseState(address market, Action action) internal view {\n        require(!actionPaused(market, action), \"action is paused\");\n    }\n\n    /// @notice Reverts if the caller is not admin\n    function ensureAdmin() internal view {\n        require(msg.sender == admin, \"only admin can\");\n    }\n\n    /// @notice Checks the passed address is nonzero\n    function ensureNonzeroAddress(address someone) internal pure {\n        require(someone != address(0), \"can't be zero address\");\n    }\n\n    /// @notice Reverts if the market is not listed\n    function ensureListed(Market storage market) internal view {\n        require(market.isListed, \"market not listed\");\n    }\n\n    /// @notice Reverts if the caller is neither admin nor the passed address\n    function ensureAdminOr(address privilegedAddress) internal view {\n        require(msg.sender == admin || msg.sender == privilegedAddress, \"access denied\");\n    }\n\n    /// @notice Checks the caller is allowed to call the specified fuction\n    function ensureAllowed(string memory functionSig) internal view {\n        require(IAccessControlManagerV8(accessControl).isAllowedToCall(msg.sender, functionSig), \"access denied\");\n    }\n\n    /**\n     * @notice Checks if a certain action is paused on a market\n     * @param action Action id\n     * @param market vToken address\n     */\n    function actionPaused(address market, Action action) public view returns (bool) {\n        return _actionPaused[market][uint256(action)];\n    }\n\n    /**\n     * @notice Get the latest block number\n     */\n    function getBlockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Get the latest block number with the safe32 check\n     */\n    function getBlockNumberAsUint32() internal view returns (uint32) {\n        return safe32(getBlockNumber(), \"block # > 32 bits\");\n    }\n\n    /**\n     * @notice Transfer XVS to VAI Vault\n     */\n    function releaseToVault() internal {\n        if (releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\n            return;\n        }\n\n        IERC20 xvs_ = IERC20(xvs);\n\n        uint256 xvsBalance = xvs_.balanceOf(address(this));\n        if (xvsBalance == 0) {\n            return;\n        }\n\n        uint256 actualAmount;\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\n        uint256 releaseAmount_ = mul_(venusVAIVaultRate, deltaBlocks);\n\n        if (xvsBalance >= releaseAmount_) {\n            actualAmount = releaseAmount_;\n        } else {\n            actualAmount = xvsBalance;\n        }\n\n        if (actualAmount < minReleaseAmount) {\n            return;\n        }\n\n        releaseStartBlock = getBlockNumber();\n\n        xvs_.safeTransfer(vaiVaultAddress, actualAmount);\n        emit DistributedVAIVaultVenus(actualAmount);\n\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        VToken vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) internal view returns (Error, uint256, uint256) {\n        (uint256 err, uint256 liquidity, uint256 shortfall) = comptrollerLens.getHypotheticalAccountLiquidity(\n            address(this),\n            account,\n            vTokenModify,\n            redeemTokens,\n            borrowAmount\n        );\n        return (Error(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param vToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\n        checkActionPauseState(address(vToken), Action.ENTER_MARKET);\n        Market storage marketToJoin = markets[address(vToken)];\n        ensureListed(marketToJoin);\n        if (marketToJoin.accountMembership[borrower]) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(vToken);\n\n        emit MarketEntered(vToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Checks for the user is allowed to redeem tokens\n     * @param vToken Address of the market\n     * @param redeemer Address of the user\n     * @param redeemTokens Amount of tokens to redeem\n     * @return Success indicator for redeem is allowed or not\n     */\n    function redeemAllowedInternal(\n        address vToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        ensureListed(markets[vToken]);\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[vToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            VToken(vToken),\n            redeemTokens,\n            0\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall != 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Returns the XVS address\n     * @return The address of XVS token\n     */\n    function getXVSAddress() external view returns (address) {\n        return xvs;\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/MarketFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IMarketFacet } from \"../interfaces/IMarketFacet.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\n\n/**\n * @title MarketFacet\n * @author Venus\n * @dev This facet contains all the methods related to the market's management in the pool\n * @notice This facet contract contains functions regarding markets\n */\ncontract MarketFacet is IMarketFacet, FacetBase {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(VToken indexed vToken);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(VToken indexed vToken, address indexed account);\n\n    /// @notice Emitted when the borrowing or redeeming delegate rights are updated for an account\n    event DelegateUpdated(address indexed approver, address indexed delegate, bool approved);\n\n    /// @notice Emitted when an admin unlists a market\n    event MarketUnlisted(address indexed vToken);\n\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() public pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\n        uint256 len;\n        VToken[] memory _accountAssets = accountAssets[account];\n        uint256 _accountAssetsLength = _accountAssets.length;\n\n        VToken[] memory assetsIn = new VToken[](_accountAssetsLength);\n\n        for (uint256 i; i < _accountAssetsLength; ++i) {\n            Market storage market = markets[address(_accountAssets[i])];\n            if (market.isListed) {\n                assetsIn[len] = _accountAssets[i];\n                ++len;\n            }\n        }\n\n        assembly {\n            mstore(assetsIn, len)\n        }\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market\n     * @return The list of market addresses\n     */\n    function getAllMarkets() external view returns (VToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenBorrowed The address of the borrowed vToken\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateCalculateSeizeTokens(\n            address(this),\n            vTokenBorrowed,\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateVAICalculateSeizeTokens(\n            address(this),\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param vToken The vToken to check\n     * @return True if the account is in the asset, otherwise false\n     */\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\n        return markets[address(vToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Check if a market is marked as listed (active)\n     * @param vToken vToken Address for the market to check\n     * @return listed True if listed otherwise false\n     */\n    function isMarketListed(VToken vToken) external view returns (bool) {\n        return markets[address(vToken)].isListed;\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param vTokens The list of addresses of the vToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory) {\n        uint256 len = vTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i; i < len; ++i) {\n            results[i] = uint256(addToMarketInternal(VToken(vTokens[i]), msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add asset to be included in account liquidity calculation\n     * @dev Allows only whitelisted executors to call this function\n     * @param user The address of the account to enter the market\n     * @param vToken The address of the vToken market to be enabled\n     * @return Success indicator for whether the corresponding market was entered\n     */\n    function enterMarket(address user, address vToken) external returns (uint256) {\n        if (!whitelistedExecutors[msg.sender]) {\n            return uint256(Error.UNAUTHORIZED);\n        }\n        return uint256(addToMarketInternal(VToken(vToken), user));\n    }\n\n    /**\n     * @notice Unlist a market by setting isListed to false\n     * @dev Checks if market actions are paused and borrowCap/supplyCap/CF are set to 0\n     * @param market The address of the market (vToken) to unlist\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function unlistMarket(address market) external returns (uint256) {\n        ensureAllowed(\"unlistMarket(address)\");\n\n        Market storage _market = markets[market];\n\n        if (!_market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNLIST_MARKET_NOT_LISTED);\n        }\n\n        require(actionPaused(market, Action.BORROW), \"borrow action is not paused\");\n        require(actionPaused(market, Action.MINT), \"mint action is not paused\");\n        require(actionPaused(market, Action.REDEEM), \"redeem action is not paused\");\n        require(actionPaused(market, Action.REPAY), \"repay action is not paused\");\n        require(actionPaused(market, Action.ENTER_MARKET), \"enter market action is not paused\");\n        require(actionPaused(market, Action.LIQUIDATE), \"liquidate action is not paused\");\n        require(actionPaused(market, Action.SEIZE), \"seize action is not paused\");\n        require(actionPaused(market, Action.TRANSFER), \"transfer action is not paused\");\n        require(actionPaused(market, Action.EXIT_MARKET), \"exit market action is not paused\");\n\n        require(borrowCaps[market] == 0, \"borrow cap is not 0\");\n        require(supplyCaps[market] == 0, \"supply cap is not 0\");\n\n        require(_market.collateralFactorMantissa == 0, \"collateral factor is not 0\");\n\n        _market.isListed = false;\n        emit MarketUnlisted(market);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow\n     * @param vTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address vTokenAddress) external returns (uint256) {\n        checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\n\n        VToken vToken = VToken(vTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(vToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set vToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete vToken from the account’s list of assets */\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\n        VToken[] storage userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 i;\n        for (; i < len; ++i) {\n            if (userAssetList[i] == vToken) {\n                userAssetList[i] = userAssetList[len - 1];\n                userAssetList.pop();\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(i < len);\n\n        emit MarketExited(vToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _supportMarket to support the Isolated Lending Comptroller Interface\n     * @param vToken The address of the market (token) to list\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function supportMarket(VToken vToken) external returns (uint256) {\n        return __supportMarket(vToken);\n    }\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed\n     * @dev Allows a privileged role to add and list markets to the Comptroller\n     * @param vToken The address of the market (token) to list\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(VToken vToken) external returns (uint256) {\n        return __supportMarket(vToken);\n    }\n\n    /**\n     * @notice Grants or revokes the borrowing or redeeming delegate rights to / from an account\n     *  If allowed, the delegate will be able to borrow funds on behalf of the sender\n     *  Upon a delegated borrow, the delegate will receive the funds, and the borrower\n     *  will see the debt on their account\n     *  Upon a delegated redeem, the delegate will receive the redeemed amount and the approver\n     *  will see a deduction in his vToken balance\n     * @param delegate The address to update the rights for\n     * @param approved Whether to grant (true) or revoke (false) the borrowing or redeeming rights\n     */\n    function updateDelegate(address delegate, bool approved) external {\n        ensureNonzeroAddress(delegate);\n        require(approvedDelegates[msg.sender][delegate] != approved, \"Delegation status unchanged\");\n\n        _updateDelegate(msg.sender, delegate, approved);\n    }\n\n    function _updateDelegate(address approver, address delegate, bool approved) internal {\n        approvedDelegates[approver][delegate] = approved;\n        emit DelegateUpdated(approver, delegate, approved);\n    }\n\n    function _addMarketInternal(VToken vToken) internal {\n        uint256 allMarketsLength = allMarkets.length;\n        for (uint256 i; i < allMarketsLength; ++i) {\n            require(allMarkets[i] != vToken, \"already added\");\n        }\n        allMarkets.push(vToken);\n    }\n\n    function _initializeMarket(address vToken) internal {\n        uint32 blockNumber = getBlockNumberAsUint32();\n\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n\n        /*\n         * Update market state indices\n         */\n        if (supplyState.index == 0) {\n            // Initialize supply state index with default value\n            supplyState.index = venusInitialIndex;\n        }\n\n        if (borrowState.index == 0) {\n            // Initialize borrow state index with default value\n            borrowState.index = venusInitialIndex;\n        }\n\n        /*\n         * Update market state block numbers\n         */\n        supplyState.block = borrowState.block = blockNumber;\n    }\n\n    function __supportMarket(VToken vToken) internal returns (uint256) {\n        ensureAllowed(\"_supportMarket(address)\");\n\n        if (markets[address(vToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n        // Note that isVenus is not in active use anymore\n        Market storage newMarket = markets[address(vToken)];\n        newMarket.isListed = true;\n        newMarket.isVenus = false;\n        newMarket.collateralFactorMantissa = 0;\n\n        _addMarketInternal(vToken);\n        _initializeMarket(address(vToken));\n\n        emit MarketListed(vToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/PolicyFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IPolicyFacet } from \"../interfaces/IPolicyFacet.sol\";\n\nimport { XVSRewardsHelper } from \"./XVSRewardsHelper.sol\";\n\n/**\n * @title PolicyFacet\n * @author Venus\n * @dev This facet contains all the hooks used while transferring the assets\n * @notice This facet contract contains all the external pre-hook functions related to vToken\n */\ncontract PolicyFacet is IPolicyFacet, XVSRewardsHelper {\n    /// @notice Emitted when a new borrow-side XVS speed is calculated for a market\n    event VenusBorrowSpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /// @notice Emitted when a new supply-side XVS speed is calculated for a market\n    event VenusSupplySpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param vToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.MINT);\n        ensureListed(markets[vToken]);\n\n        uint256 supplyCap = supplyCaps[vToken];\n        require(supplyCap != 0, \"market supply cap is 0\");\n\n        uint256 vTokenSupply = VToken(vToken).totalSupply();\n        Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\n        uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\n        require(nextTotalSupply <= supplyCap, \"market supply cap reached\");\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, minter);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    // solhint-disable-next-line no-unused-vars\n    function mintVerify(address vToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(minter, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param vToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address vToken, address redeemer, uint256 redeemTokens) external returns (uint256) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REDEEM);\n\n        uint256 allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, redeemer);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address vToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external {\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(redeemer, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param vToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address vToken, address borrower, uint256 borrowAmount) external returns (uint256) {\n        return _borrowAllowed(vToken, borrower, address(0), borrowAmount);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param vToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param receiver The account which would receive the borrowed asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(\n        address vToken,\n        address borrower,\n        address receiver,\n        uint256 borrowAmount\n    ) external returns (uint256) {\n        return _borrowAllowed(vToken, borrower, receiver, borrowAmount);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param vToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param receiver The account which would receive the borrowed asset or address(0) when receiver is not specified\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function _borrowAllowed(\n        address vToken,\n        address borrower,\n        address receiver,\n        uint256 borrowAmount\n    ) internal returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.BORROW);\n        ensureListed(markets[vToken]);\n\n        uint256 borrowCap = borrowCaps[vToken];\n        require(borrowCap != 0, \"market borrow cap is 0\");\n\n        if (!markets[vToken].accountMembership[borrower]) {\n            // only vTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == vToken, \"sender must be vToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(VToken(vToken), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n        }\n\n        if (oracle.getUnderlyingPrice(vToken) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        uint256 nextTotalBorrows = add_(VToken(vToken).totalBorrows(), borrowAmount);\n        require(nextTotalBorrows <= borrowCap, \"market borrow cap reached\");\n\n        // Skipped for debt swapping, the receiver is the PositionSwapper contract\n        if (!whitelistedExecutors[receiver]) {\n            (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n                borrower,\n                VToken(vToken),\n                0,\n                borrowAmount\n            );\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n            if (shortfall != 0) {\n                return uint256(Error.INSUFFICIENT_LIQUIDITY);\n            }\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    // solhint-disable-next-line no-unused-vars\n    function borrowVerify(address vToken, address borrower, uint256 borrowAmount) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param vToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address vToken,\n        address payer, // solhint-disable-line no-unused-vars\n        address borrower,\n        uint256 repayAmount // solhint-disable-line no-unused-vars\n    ) external returns (uint256) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REPAY);\n        ensureListed(markets[vToken]);\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address vToken,\n        address payer, // solhint-disable-line no-unused-vars\n        address borrower,\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\n        uint256 borrowerIndex // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external view returns (uint256) {\n        checkProtocolPauseState();\n\n        // if we want to pause liquidating to vTokenCollateral, we should pause seizing\n        checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\n\n        if (liquidatorContract != address(0) && liquidator != liquidatorContract) {\n            return uint256(Error.UNAUTHORIZED);\n        }\n\n        ensureListed(markets[vTokenCollateral]);\n\n        uint256 borrowBalance;\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n            borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\n        } else {\n            borrowBalance = vaiController.getVAIRepayAmount(borrower);\n        }\n\n        if (isForcedLiquidationEnabled[vTokenBorrowed] || isForcedLiquidationEnabledForUser[borrower][vTokenBorrowed]) {\n            if (repayAmount > borrowBalance) {\n                return uint(Error.TOO_MUCH_REPAY);\n            }\n            return uint(Error.NO_ERROR);\n        }\n\n        /* The borrower must have shortfall in order to be liquidatable */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(address(0)), 0, 0);\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall == 0) {\n            return uint256(Error.INSUFFICIENT_SHORTFALL);\n        }\n\n        // The liquidator may not repay more than what is allowed by the closeFactor\n        //-- maxClose = multipy of closeFactorMantissa and borrowBalance\n        if (repayAmount > mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance)) {\n            return uint256(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     * @param seizeTokens The amount of collateral token that will be seized\n     */\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral, // solhint-disable-line no-unused-vars\n        address liquidator,\n        address borrower,\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vTokenBorrowed);\n            prime.accrueInterestAndUpdateScore(liquidator, vTokenBorrowed);\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenOrExecutor Asset which was borrowed by the borrower or a whitelisted executor\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenOrExecutor,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vTokenCollateral, Action.SEIZE);\n\n        Market storage market = markets[vTokenCollateral];\n\n        // We've added VAIController as a borrowed token list check for seize\n        ensureListed(market);\n\n        // Skipped for collateral swapping, the vTokenOrExecutor is the PositionSwapper contract\n        if (!whitelistedExecutors[vTokenOrExecutor]) {\n            if (!market.accountMembership[borrower]) {\n                return uint256(Error.MARKET_NOT_COLLATERAL);\n            }\n\n            if (address(vTokenOrExecutor) != address(vaiController)) {\n                ensureListed(markets[vTokenOrExecutor]);\n            }\n\n            if (VToken(vTokenCollateral).comptroller() != VToken(vTokenOrExecutor).comptroller()) {\n                return uint256(Error.COMPTROLLER_MISMATCH);\n            }\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vTokenCollateral);\n        distributeSupplierVenus(vTokenCollateral, borrower);\n        distributeSupplierVenus(vTokenCollateral, liquidator);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenOrExecutor Asset which was borrowed by the borrower or a whitelisted executor\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenOrExecutor, // solhint-disable-line no-unused-vars\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vTokenCollateral);\n            prime.accrueInterestAndUpdateScore(liquidator, vTokenCollateral);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param vToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.TRANSFER);\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(vToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, src);\n        distributeSupplierVenus(vToken, dst);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     */\n    // solhint-disable-next-line no-unused-vars\n    function transferVerify(address vToken, address src, address dst, uint256 transferTokens) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(src, vToken);\n            prime.accrueInterestAndUpdateScore(dst, vToken);\n        }\n    }\n\n    /**\n     * @notice Alias to getAccountLiquidity to support the Isolated Lending Comptroller Interface\n     * @param account The account get liquidity for\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getBorrowingPower(address account) external view returns (uint256, uint256, uint256) {\n        return _getAccountLiquidity(account);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @param account The account get liquidity for\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256) {\n        return _getAccountLiquidity(account);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external view returns (uint256, uint256, uint256) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(vTokenModify),\n            redeemTokens,\n            borrowAmount\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    // setter functionality\n    /**\n     * @notice Set XVS speed for a single market\n     * @dev Allows the contract admin to set XVS speed for a market\n     * @param vTokens The market whose XVS speed to update\n     * @param supplySpeeds New XVS speed for supply\n     * @param borrowSpeeds New XVS speed for borrow\n     */\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint256[] calldata supplySpeeds,\n        uint256[] calldata borrowSpeeds\n    ) external {\n        ensureAdmin();\n\n        uint256 numTokens = vTokens.length;\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"invalid input\");\n\n        for (uint256 i; i < numTokens; ++i) {\n            ensureNonzeroAddress(address(vTokens[i]));\n            setVenusSpeedInternal(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n        }\n    }\n\n    function _getAccountLiquidity(address account) internal view returns (uint256, uint256, uint256) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(address(0)),\n            0,\n            0\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    function setVenusSpeedInternal(VToken vToken, uint256 supplySpeed, uint256 borrowSpeed) internal {\n        ensureListed(markets[address(vToken)]);\n\n        if (venusSupplySpeeds[address(vToken)] != supplySpeed) {\n            // Supply speed updated so let's update supply state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n\n            updateVenusSupplyIndex(address(vToken));\n            // Update speed and emit event\n            venusSupplySpeeds[address(vToken)] = supplySpeed;\n            emit VenusSupplySpeedUpdated(vToken, supplySpeed);\n        }\n\n        if (venusBorrowSpeeds[address(vToken)] != borrowSpeed) {\n            // Borrow speed updated so let's update borrow state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n            // Update speed and emit event\n            venusBorrowSpeeds[address(vToken)] = borrowSpeed;\n            emit VenusBorrowSpeedUpdated(vToken, borrowSpeed);\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/RewardFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { IRewardFacet } from \"../interfaces/IRewardFacet.sol\";\nimport { XVSRewardsHelper } from \"./XVSRewardsHelper.sol\";\nimport { VBep20Interface } from \"../../../Tokens/VTokens/VTokenInterfaces.sol\";\n\n/**\n * @title RewardFacet\n * @author Venus\n * @dev This facet contains all the methods related to the reward functionality\n * @notice This facet contract provides the external functions related to all claims and rewards of the protocol\n */\ncontract RewardFacet is IRewardFacet, XVSRewardsHelper {\n    /// @notice Emitted when Venus is granted by admin\n    event VenusGranted(address indexed recipient, uint256 amount);\n\n    /// @notice Emitted when XVS are seized for the holder\n    event VenusSeized(address indexed holder, uint256 amount);\n\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\n     * @param holder The address to claim XVS for\n     */\n    function claimVenus(address holder) public {\n        return claimVenus(holder, allMarkets);\n    }\n\n    /**\n     * @notice Claim all the xvs accrued by holder in the specified markets\n     * @param holder The address to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     */\n    function claimVenus(address holder, VToken[] memory vTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimVenus(holders, vTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all xvs accrued by the holders\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     */\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\n        claimVenus(holders, vTokens, borrowers, suppliers, false);\n    }\n\n    /**\n     * @notice Claim all the xvs accrued by holder in all markets, a shorthand for `claimVenus` with collateral set to `true`\n     * @param holder The address to claim XVS for\n     */\n    function claimVenusAsCollateral(address holder) external {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimVenus(holders, allMarkets, true, true, true);\n    }\n\n    /**\n     * @notice Transfer XVS to the user with user's shortfall considered\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all\n     * @param user The address of the user to transfer XVS to\n     * @param amount The amount of XVS to (possibly) transfer\n     * @param shortfall The shortfall of the user\n     * @param collateral Whether or not we will use user's venus reward as collateral to pay off the debt\n     * @return The amount of XVS which was NOT transferred to the user\n     */\n    function grantXVSInternal(\n        address user,\n        uint256 amount,\n        uint256 shortfall,\n        bool collateral\n    ) internal returns (uint256) {\n        // If the user is blacklisted, they can't get XVS rewards\n        require(\n            user != 0xEF044206Db68E40520BfA82D45419d498b4bc7Bf &&\n                user != 0x7589dD3355DAE848FDbF75044A3495351655cB1A &&\n                user != 0x33df7a7F6D44307E1e5F3B15975b47515e5524c0 &&\n                user != 0x24e77E5b74B30b026E9996e4bc3329c881e24968,\n            \"Blacklisted\"\n        );\n\n        IERC20 xvs_ = IERC20(xvs);\n\n        if (amount == 0 || amount > xvs_.balanceOf(address(this))) {\n            return amount;\n        }\n\n        if (shortfall == 0) {\n            xvs_.safeTransfer(user, amount);\n            return 0;\n        }\n        // If user's bankrupt and doesn't use pending xvs as collateral, don't grant\n        // anything, otherwise, we will transfer the pending xvs as collateral to\n        // vXVS token and mint vXVS for the user\n        //\n        // If mintBehalf failed, don't grant any xvs\n        require(collateral, \"bankrupt\");\n\n        address xvsVToken_ = xvsVToken;\n\n        xvs_.safeApprove(xvsVToken_, 0);\n        xvs_.safeApprove(xvsVToken_, amount);\n        require(VBep20Interface(xvsVToken_).mintBehalf(user, amount) == uint256(Error.NO_ERROR), \"mint behalf error\");\n\n        // set venusAccrued[user] to 0\n        return 0;\n    }\n\n    /*** Venus Distribution Admin ***/\n\n    /**\n     * @notice Transfer XVS to the recipient\n     * @dev Allows the contract admin to transfer XVS to any recipient based on the recipient's shortfall\n     *      Note: If there is not enough XVS, we do not perform the transfer all\n     * @param recipient The address of the recipient to transfer XVS to\n     * @param amount The amount of XVS to (possibly) transfer\n     */\n    function _grantXVS(address recipient, uint256 amount) external {\n        ensureAdmin();\n        uint256 amountLeft = grantXVSInternal(recipient, amount, 0, false);\n        require(amountLeft == 0, \"no xvs\");\n        emit VenusGranted(recipient, amount);\n    }\n\n    /**\n     * @dev Seize XVS tokens from the specified holders and transfer to recipient\n     * @notice Seize XVS rewards allocated to holders\n     * @param holders Addresses of the XVS holders\n     * @param recipient Address of the XVS token recipient\n     * @return The total amount of XVS tokens seized and transferred to recipient\n     */\n    function seizeVenus(address[] calldata holders, address recipient) external returns (uint256) {\n        ensureAllowed(\"seizeVenus(address[],address)\");\n\n        uint256 holdersLength = holders.length;\n        uint256 totalHoldings;\n\n        updateAndDistributeRewardsInternal(holders, allMarkets, true, true);\n        for (uint256 j; j < holdersLength; ++j) {\n            address holder = holders[j];\n            uint256 userHolding = venusAccrued[holder];\n\n            if (userHolding != 0) {\n                totalHoldings += userHolding;\n                delete venusAccrued[holder];\n            }\n\n            emit VenusSeized(holder, userHolding);\n        }\n\n        if (totalHoldings != 0) {\n            IERC20(xvs).safeTransfer(recipient, totalHoldings);\n            emit VenusGranted(recipient, totalHoldings);\n        }\n\n        return totalHoldings;\n    }\n\n    /**\n     * @notice Claim all xvs accrued by the holders\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     * @param collateral Whether or not to use XVS earned as collateral, only takes effect when the holder has a shortfall\n     */\n    function claimVenus(\n        address[] memory holders,\n        VToken[] memory vTokens,\n        bool borrowers,\n        bool suppliers,\n        bool collateral\n    ) public {\n        uint256 holdersLength = holders.length;\n\n        updateAndDistributeRewardsInternal(holders, vTokens, borrowers, suppliers);\n        for (uint256 j; j < holdersLength; ++j) {\n            address holder = holders[j];\n\n            // If there is a positive shortfall, the XVS reward is accrued,\n            // but won't be granted to this holder\n            (, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(holder, VToken(address(0)), 0, 0);\n\n            uint256 value = venusAccrued[holder];\n            delete venusAccrued[holder];\n\n            uint256 returnAmount = grantXVSInternal(holder, value, shortfall, collateral);\n\n            // returnAmount can only be positive if balance of xvsAddress is less than grant amount(venusAccrued[holder])\n            if (returnAmount != 0) {\n                venusAccrued[holder] = returnAmount;\n            }\n        }\n    }\n\n    /**\n     * @notice Update and distribute tokens\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     */\n    function updateAndDistributeRewardsInternal(\n        address[] memory holders,\n        VToken[] memory vTokens,\n        bool borrowers,\n        bool suppliers\n    ) internal {\n        uint256 j;\n        uint256 holdersLength = holders.length;\n        uint256 vTokensLength = vTokens.length;\n\n        for (uint256 i; i < vTokensLength; ++i) {\n            VToken vToken = vTokens[i];\n            ensureListed(markets[address(vToken)]);\n            if (borrowers) {\n                Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\n                for (j = 0; j < holdersLength; ++j) {\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\n                }\n            }\n\n            if (suppliers) {\n                updateVenusSupplyIndex(address(vToken));\n                for (j = 0; j < holdersLength; ++j) {\n                    distributeSupplierVenus(address(vToken), holders[j]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the XVS vToken address\n     * @return The address of XVS vToken\n     */\n    function getXVSVTokenAddress() external view returns (address) {\n        return xvsVToken;\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/SetterFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { ComptrollerLensInterface } from \"../../ComptrollerLensInterface.sol\";\nimport { VAIControllerInterface } from \"../../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { IPrime } from \"../../../Tokens/Prime/IPrime.sol\";\nimport { ISetterFacet } from \"../interfaces/ISetterFacet.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\n\n/**\n * @title SetterFacet\n * @author Venus\n * @dev This facet contains all the setters for the states\n * @notice This facet contract contains all the configurational setter functions\n */\ncontract SetterFacet is ISetterFacet, FacetBase {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(\n        VToken indexed vToken,\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(ResilientOracleInterface oldPriceOracle, ResilientOracleInterface newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint256 oldVAIMintRate, uint256 newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint256 oldTreasuryPercent, uint256 newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address indexed vault_, uint256 releaseStartBlock_, uint256 releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint256 oldVenusVAIVaultRate, uint256 newVenusVAIVaultRate);\n\n    /// @notice Emitted when prime token contract address is changed\n    event NewPrimeToken(IPrime oldPrimeToken, IPrime newPrimeToken);\n\n    /// @notice Emitted when forced liquidation is enabled or disabled for all users in a market\n    event IsForcedLiquidationEnabledUpdated(address indexed vToken, bool enable);\n\n    /// @notice Emitted when forced liquidation is enabled or disabled for a user borrowing in a market\n    event IsForcedLiquidationEnabledForUserUpdated(address indexed borrower, address indexed vToken, bool enable);\n\n    /// @notice Emitted when XVS token address is changed\n    event NewXVSToken(address indexed oldXVS, address indexed newXVS);\n\n    /// @notice Emitted when XVS vToken address is changed\n    event NewXVSVToken(address indexed oldXVSVToken, address indexed newXVSVToken);\n\n    /// @notice Emitted when whitelisted executors are updated\n    event WhitelistedExecutorsUpdated(address indexed executor, bool status);\n\n    /**\n     * @notice Compare two addresses to ensure they are different\n     * @param oldAddress The original address to compare\n     * @param newAddress The new address to compare\n     */\n    modifier compareAddress(address oldAddress, address newAddress) {\n        require(oldAddress != newAddress, \"old address is same as new address\");\n        _;\n    }\n\n    /**\n     * @notice Compare two values to ensure they are different\n     * @param oldValue The original value to compare\n     * @param newValue The new value to compare\n     */\n    modifier compareValue(uint256 oldValue, uint256 newValue) {\n        require(oldValue != newValue, \"old value is same as new value\");\n        _;\n    }\n\n    /**\n     * @notice Alias to _setPriceOracle to support the Isolated Lending Comptroller Interface\n     * @param newOracle The new price oracle to set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256) {\n        return __setPriceOracle(newOracle);\n    }\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Allows the contract admin to set a new price oracle used by the Comptroller\n     * @param newOracle The new price oracle to set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256) {\n        return __setPriceOracle(newOracle);\n    }\n\n    /**\n     * @notice Alias to _setCloseFactor to support the Isolated Lending Comptroller Interface\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint256 0=success, otherwise will revert\n     */\n    function setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        return __setCloseFactor(newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Allows the contract admin to set the closeFactor used to liquidate borrows\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint256 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        return __setCloseFactor(newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Allows the contract admin to set the address of access control of this contract\n     * @param newAccessControlAddress New address for the access control\n     * @return uint256 0=success, otherwise will revert\n     */\n    function _setAccessControl(\n        address newAccessControlAddress\n    ) external compareAddress(accessControl, newAccessControlAddress) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _setCollateralFactor to support the Isolated Lending Comptroller Interface\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256) {\n        require(\n            newCollateralFactorMantissa == newLiquidationThresholdMantissa,\n            \"collateral factor and liquidation threshold must be the same\"\n        );\n        return __setCollateralFactor(vToken, newCollateralFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Allows a privileged role to set the collateralFactorMantissa\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(VToken vToken, uint256 newCollateralFactorMantissa) external returns (uint256) {\n        return __setCollateralFactor(vToken, newCollateralFactorMantissa);\n    }\n\n    /**\n     * @notice Alias to _setLiquidationIncentive to support the Isolated Lending Comptroller Interface\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n        return __setLiquidationIncentive(newLiquidationIncentiveMantissa);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Allows a privileged role to set the liquidationIncentiveMantissa\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n        return __setLiquidationIncentive(newLiquidationIncentiveMantissa);\n    }\n\n    /**\n     * @notice Update the address of the liquidator contract\n     * @dev Allows the contract admin to update the address of liquidator contract\n     * @param newLiquidatorContract_ The new address of the liquidator contract\n     */\n    function _setLiquidatorContract(\n        address newLiquidatorContract_\n    ) external compareAddress(liquidatorContract, newLiquidatorContract_) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newLiquidatorContract_);\n        address oldLiquidatorContract = liquidatorContract;\n        liquidatorContract = newLiquidatorContract_;\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @dev Allows the contract admin to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(\n        address newPauseGuardian\n    ) external compareAddress(pauseGuardian, newPauseGuardian) returns (uint256) {\n        ensureAdmin();\n        ensureNonzeroAddress(newPauseGuardian);\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _setMarketBorrowCaps to support the Isolated Lending Comptroller Interface\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to Borrow not allowed\n     */\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\n        __setMarketBorrowCaps(vTokens, newBorrowCaps);\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given vToken market Borrowing that brings total borrows to or above borrow cap will revert\n     * @dev Allows a privileged role to set the borrowing cap for a vToken market. A borrow cap of 0 corresponds to Borrow not allowed\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to Borrow not allowed\n     */\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\n        __setMarketBorrowCaps(vTokens, newBorrowCaps);\n    }\n\n    /**\n     * @notice Alias to _setMarketSupplyCaps to support the Isolated Lending Comptroller Interface\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed\n     */\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        __setMarketSupplyCaps(vTokens, newSupplyCaps);\n    }\n\n    /**\n     * @notice Set the given supply caps for the given vToken market Supply that brings total Supply to or above supply cap will revert\n     * @dev Allows a privileged role to set the supply cap for a vToken. A supply cap of 0 corresponds to Minting NotAllowed\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed\n     */\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        __setMarketSupplyCaps(vTokens, newSupplyCaps);\n    }\n\n    /**\n     * @notice Set whole protocol pause/unpause state\n     * @dev Allows a privileged role to pause/unpause protocol\n     * @param state The new state (true=paused, false=unpaused)\n     * @return bool The updated state of the protocol\n     */\n    function _setProtocolPaused(bool state) external returns (bool) {\n        ensureAllowed(\"_setProtocolPaused(bool)\");\n\n        protocolPaused = state;\n        emit ActionProtocolPaused(state);\n        return state;\n    }\n\n    /**\n     * @notice Alias to _setActionsPaused to support the Isolated Lending Comptroller Interface\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        __setActionsPaused(markets_, actions_, paused_);\n    }\n\n    /**\n     * @notice Pause/unpause certain actions\n     * @dev Allows a privileged role to pause/unpause the protocol action state\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        __setActionsPaused(markets_, actions_, paused_);\n    }\n\n    /**\n     * @dev Pause/unpause an action on a market\n     * @param market Market to pause/unpause the action on\n     * @param action Action id to pause/unpause\n     * @param paused The new paused state (true=paused, false=unpaused)\n     */\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\n        ensureListed(markets[market]);\n        _actionPaused[market][uint256(action)] = paused;\n        emit ActionPausedMarket(VToken(market), action, paused);\n    }\n\n    /**\n     * @notice Sets a new VAI controller\n     * @dev Admin function to set a new VAI controller\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIController(\n        VAIControllerInterface vaiController_\n    ) external compareAddress(address(vaiController), address(vaiController_)) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(vaiController_));\n\n        VAIControllerInterface oldVaiController = vaiController;\n        vaiController = vaiController_;\n        emit NewVAIController(oldVaiController, vaiController_);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the VAI mint rate\n     * @param newVAIMintRate The new VAI mint rate to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIMintRate(\n        uint256 newVAIMintRate\n    ) external compareValue(vaiMintRate, newVAIMintRate) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        uint256 oldVAIMintRate = vaiMintRate;\n        vaiMintRate = newVAIMintRate;\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the minted VAI amount of the `owner`\n     * @param owner The address of the account to set\n     * @param amount The amount of VAI to set to the account\n     * @return The number of minted VAI by `owner`\n     */\n    function setMintedVAIOf(address owner, uint256 amount) external returns (uint256) {\n        checkProtocolPauseState();\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n        // Check caller is vaiController\n        if (msg.sender != address(vaiController)) {\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\n        }\n        mintedVAIs[owner] = amount;\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the treasury data.\n     * @param newTreasuryGuardian The new address of the treasury guardian to be set\n     * @param newTreasuryAddress The new address of the treasury to be set\n     * @param newTreasuryPercent The new treasury percent to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256) {\n        // Check caller is admin\n        ensureAdminOr(treasuryGuardian);\n\n        require(newTreasuryPercent < 1e18, \"percent >= 100%\");\n        ensureNonzeroAddress(newTreasuryGuardian);\n        ensureNonzeroAddress(newTreasuryAddress);\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint256 oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Venus Distribution ***/\n\n    /**\n     * @dev Set ComptrollerLens contract address\n     * @param comptrollerLens_ The new ComptrollerLens contract address to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptrollerLens(\n        ComptrollerLensInterface comptrollerLens_\n    ) external virtual compareAddress(address(comptrollerLens), address(comptrollerLens_)) returns (uint256) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block to VAI Vault\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\n     */\n    function _setVenusVAIVaultRate(\n        uint256 venusVAIVaultRate_\n    ) external compareValue(venusVAIVaultRate, venusVAIVaultRate_) {\n        ensureAdmin();\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n        uint256 oldVenusVAIVaultRate = venusVAIVaultRate;\n        venusVAIVaultRate = venusVAIVaultRate_;\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n    }\n\n    /**\n     * @notice Set the VAI Vault infos\n     * @param vault_ The address of the VAI Vault\n     * @param releaseStartBlock_ The start block of release to VAI Vault\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\n     */\n    function _setVAIVaultInfo(\n        address vault_,\n        uint256 releaseStartBlock_,\n        uint256 minReleaseAmount_\n    ) external compareAddress(vaiVaultAddress, vault_) {\n        ensureAdmin();\n        ensureNonzeroAddress(vault_);\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n\n        vaiVaultAddress = vault_;\n        releaseStartBlock = releaseStartBlock_;\n        minReleaseAmount = minReleaseAmount_;\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n    }\n\n    /**\n     * @notice Alias to _setPrimeToken to support the Isolated Lending Comptroller Interface\n     * @param _prime The new prime token contract to be set\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function setPrimeToken(IPrime _prime) external returns (uint256) {\n        return __setPrimeToken(_prime);\n    }\n\n    /**\n     * @notice Sets the prime token contract for the comptroller\n     * @param _prime The new prime token contract to be set\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPrimeToken(IPrime _prime) external returns (uint256) {\n        return __setPrimeToken(_prime);\n    }\n\n    /**\n     * @notice Alias to _setForcedLiquidation to support the Isolated Lending Comptroller Interface\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external {\n        __setForcedLiquidation(vTokenBorrowed, enable);\n    }\n\n    /** @notice Enables forced liquidations for a market. If forced liquidation is enabled,\n     * borrows in the market may be liquidated regardless of the account liquidity\n     * @dev Allows a privileged role to set enable/disable forced liquidations\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function _setForcedLiquidation(address vTokenBorrowed, bool enable) external {\n        __setForcedLiquidation(vTokenBorrowed, enable);\n    }\n\n    /**\n     * @notice Enables forced liquidations for user's borrows in a certain market. If forced\n     * liquidation is enabled, user's borrows in the market may be liquidated regardless of\n     * the account liquidity. Forced liquidation may be enabled for a user even if it is not\n     * enabled for the entire market.\n     * @param borrower The address of the borrower\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function _setForcedLiquidationForUser(address borrower, address vTokenBorrowed, bool enable) external {\n        ensureAllowed(\"_setForcedLiquidationForUser(address,address,bool)\");\n        if (vTokenBorrowed != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n        }\n        isForcedLiquidationEnabledForUser[borrower][vTokenBorrowed] = enable;\n        emit IsForcedLiquidationEnabledForUserUpdated(borrower, vTokenBorrowed, enable);\n    }\n\n    /**\n     * @notice Set the whitelisted executor\n     * @param executor The address of the executor to be set\n     * @param status The status of the executor (true=whitelisted, false=not whitelisted)\n     */\n    function _setWhitelistedExecutor(address executor, bool status) external {\n        ensureAllowed(\"_setWhitelistedExecutor(address,bool)\");\n        ensureNonzeroAddress(executor);\n\n        whitelistedExecutors[executor] = status;\n        emit WhitelistedExecutorsUpdated(executor, status);\n    }\n\n    /**\n     * @notice Set the address of the XVS token\n     * @param xvs_ The address of the XVS token\n     */\n    function _setXVSToken(address xvs_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(xvs_);\n\n        emit NewXVSToken(xvs, xvs_);\n        xvs = xvs_;\n    }\n\n    /**\n     * @notice Set the address of the XVS vToken\n     * @param xvsVToken_ The address of the XVS vToken\n     */\n    function _setXVSVToken(address xvsVToken_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(xvsVToken_);\n\n        address underlying = VToken(xvsVToken_).underlying();\n        require(underlying == xvs, \"invalid xvs vtoken address\");\n\n        emit NewXVSVToken(xvsVToken, xvsVToken_);\n        xvsVToken = xvsVToken_;\n    }\n\n    /**\n     * @dev Updates the valid price oracle. Used by _setPriceOracle and setPriceOracle\n     * @param newOracle The new price oracle to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setPriceOracle(\n        ResilientOracleInterface newOracle\n    ) internal compareAddress(address(oracle), address(newOracle)) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        ResilientOracleInterface oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the close factor. Used by _setCloseFactor and setCloseFactor\n     * @param newCloseFactorMantissa The new close factor to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setCloseFactor(\n        uint256 newCloseFactorMantissa\n    ) internal compareValue(closeFactorMantissa, newCloseFactorMantissa) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n\n        Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n\n        //-- Check close factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n        //-- Check close factor >= 0.05\n        Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n\n        if (lessThanExp(highLimit, newCloseFactorExp) || greaterThanExp(lowLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the collateral factor. Used by _setCollateralFactor and setCollateralFactor\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa\n    )\n        internal\n        compareValue(markets[address(vToken)].collateralFactorMantissa, newCollateralFactorMantissa)\n        returns (uint256)\n    {\n        // Check caller is allowed by access control manager\n        ensureAllowed(\"_setCollateralFactor(address,uint256)\");\n        ensureNonzeroAddress(address(vToken));\n\n        // Verify market is listed\n        Market storage market = markets[address(vToken)];\n        ensureListed(market);\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        //-- Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(vToken)) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the liquidation incentive. Used by _setLiquidationIncentive and setLiquidationIncentive\n     * @param newLiquidationIncentiveMantissa The new liquidation incentive to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setLiquidationIncentive(\n        uint256 newLiquidationIncentiveMantissa\n    ) internal compareValue(liquidationIncentiveMantissa, newLiquidationIncentiveMantissa) returns (uint256) {\n        ensureAllowed(\"_setLiquidationIncentive(uint256)\");\n\n        require(newLiquidationIncentiveMantissa >= 1e18, \"incentive < 1e18\");\n\n        // Save current value for use in log\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the borrow caps. Used by _setMarketBorrowCaps and setMarketBorrowCaps\n     * @param vTokens The markets to set the borrow caps on\n     * @param newBorrowCaps The new borrow caps to be set\n     */\n    function __setMarketBorrowCaps(VToken[] memory vTokens, uint256[] memory newBorrowCaps) internal {\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\n\n        uint256 numMarkets = vTokens.length;\n        uint256 numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint256 i; i < numMarkets; ++i) {\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Updates the supply caps. Used by _setMarketSupplyCaps and setMarketSupplyCaps\n     * @param vTokens The markets to set the supply caps on\n     * @param newSupplyCaps The new supply caps to be set\n     */\n    function __setMarketSupplyCaps(VToken[] memory vTokens, uint256[] memory newSupplyCaps) internal {\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\n\n        uint256 numMarkets = vTokens.length;\n        uint256 numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint256 i; i < numMarkets; ++i) {\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Updates the prime token. Used by _setPrimeToken and setPrimeToken\n     * @param _prime The new prime token to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setPrimeToken(IPrime _prime) internal returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(_prime));\n\n        IPrime oldPrime = prime;\n        prime = _prime;\n        emit NewPrimeToken(oldPrime, _prime);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the forced liquidation. Used by _setForcedLiquidation and setForcedLiquidation\n     * @param vTokenBorrowed The market to set the forced liquidation on\n     * @param enable Whether to enable forced liquidations\n     */\n    function __setForcedLiquidation(address vTokenBorrowed, bool enable) internal {\n        ensureAllowed(\"_setForcedLiquidation(address,bool)\");\n        if (vTokenBorrowed != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n        }\n        isForcedLiquidationEnabled[vTokenBorrowed] = enable;\n        emit IsForcedLiquidationEnabledUpdated(vTokenBorrowed, enable);\n    }\n\n    /**\n     * @dev Updates the actions paused. Used by _setActionsPaused and setActionsPaused\n     * @param markets_ The markets to set the actions paused on\n     * @param actions_ The actions to set the paused state on\n     * @param paused_ The new paused state to be set\n     */\n    function __setActionsPaused(address[] memory markets_, Action[] memory actions_, bool paused_) internal {\n        ensureAllowed(\"_setActionsPaused(address[],uint8[],bool)\");\n\n        uint256 numMarkets = markets_.length;\n        uint256 numActions = actions_.length;\n        for (uint256 marketIdx; marketIdx < numMarkets; ++marketIdx) {\n            for (uint256 actionIdx; actionIdx < numActions; ++actionIdx) {\n                setActionPausedInternal(markets_[marketIdx], actions_[actionIdx], paused_);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/XVSRewardsHelper.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\n\n/**\n * @title XVSRewardsHelper\n * @author Venus\n * @dev This contract contains internal functions used in RewardFacet and PolicyFacet\n * @notice This facet contract contains the shared functions used by the RewardFacet and PolicyFacet\n */\ncontract XVSRewardsHelper is FacetBase {\n    /// @notice Emitted when XVS is distributed to a borrower\n    event DistributedBorrowerVenus(\n        VToken indexed vToken,\n        address indexed borrower,\n        uint256 venusDelta,\n        uint256 venusBorrowIndex\n    );\n\n    /// @notice Emitted when XVS is distributed to a supplier\n    event DistributedSupplierVenus(\n        VToken indexed vToken,\n        address indexed supplier,\n        uint256 venusDelta,\n        uint256 venusSupplyIndex\n    );\n\n    /**\n     * @notice Accrue XVS to the market by updating the borrow index\n     * @param vToken The market whose borrow index to update\n     */\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n        uint256 borrowSpeed = venusBorrowSpeeds[vToken];\n        uint32 blockNumber = getBlockNumberAsUint32();\n        uint256 deltaBlocks = sub_(blockNumber, borrowState.block);\n        if (deltaBlocks != 0 && borrowSpeed != 0) {\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n            uint256 accruedVenus = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount != 0 ? fraction(accruedVenus, borrowAmount) : Double({ mantissa: 0 });\n            borrowState.index = safe224(add_(Double({ mantissa: borrowState.index }), ratio).mantissa, \"224\");\n            borrowState.block = blockNumber;\n        } else if (deltaBlocks != 0) {\n            borrowState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Accrue XVS to the market by updating the supply index\n     * @param vToken The market whose supply index to update\n     */\n    function updateVenusSupplyIndex(address vToken) internal {\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        uint256 supplySpeed = venusSupplySpeeds[vToken];\n        uint32 blockNumber = getBlockNumberAsUint32();\n\n        uint256 deltaBlocks = sub_(blockNumber, supplyState.block);\n        if (deltaBlocks != 0 && supplySpeed != 0) {\n            uint256 supplyTokens = VToken(vToken).totalSupply();\n            uint256 accruedVenus = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens != 0 ? fraction(accruedVenus, supplyTokens) : Double({ mantissa: 0 });\n            supplyState.index = safe224(add_(Double({ mantissa: supplyState.index }), ratio).mantissa, \"224\");\n            supplyState.block = blockNumber;\n        } else if (deltaBlocks != 0) {\n            supplyState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\n     * @param vToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute XVS to\n     */\n    function distributeSupplierVenus(address vToken, address supplier) internal {\n        if (address(vaiVaultAddress) != address(0)) {\n            releaseToVault();\n        }\n        uint256 supplyIndex = venusSupplyState[vToken].index;\n        uint256 supplierIndex = venusSupplierIndex[vToken][supplier];\n        // Update supplier's index to the current index since we are distributing accrued XVS\n        venusSupplierIndex[vToken][supplier] = supplyIndex;\n        if (supplierIndex == 0 && supplyIndex >= venusInitialIndex) {\n            // Covers the case where users supplied tokens before the market's supply state index was set.\n            // Rewards the user with XVS accrued from the start of when supplier rewards were first\n            // set for the market.\n            supplierIndex = venusInitialIndex;\n        }\n        // Calculate change in the cumulative sum of the XVS per vToken accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\n        // Multiply of supplierTokens and supplierDelta\n        uint256 supplierDelta = mul_(VToken(vToken).balanceOf(supplier), deltaIndex);\n        // Addition of supplierAccrued and supplierDelta\n        venusAccrued[supplier] = add_(venusAccrued[supplier], supplierDelta);\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex);\n    }\n\n    /**\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol\n     * @param vToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute XVS to\n     */\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\n        if (address(vaiVaultAddress) != address(0)) {\n            releaseToVault();\n        }\n        uint256 borrowIndex = venusBorrowState[vToken].index;\n        uint256 borrowerIndex = venusBorrowerIndex[vToken][borrower];\n        // Update borrowers's index to the current index since we are distributing accrued XVS\n        venusBorrowerIndex[vToken][borrower] = borrowIndex;\n        if (borrowerIndex == 0 && borrowIndex >= venusInitialIndex) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\n            // Rewards the user with XVS accrued from the start of when borrower rewards were first\n            // set for the market.\n            borrowerIndex = venusInitialIndex;\n        }\n        // Calculate change in the cumulative sum of the XVS per borrowed unit accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\n        uint256 borrowerDelta = mul_(div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex), deltaIndex);\n        venusAccrued[borrower] = add_(venusAccrued[borrower], borrowerDelta);\n        emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex);\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    function diamondCut(FacetCut[] calldata _diamondCut) external;\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IFacetBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { Action } from \"../../../Comptroller/ComptrollerInterface.sol\";\n\ninterface IFacetBase {\n    /**\n     * @notice The initial XVS rewards index for a market\n     */\n    function venusInitialIndex() external pure returns (uint224);\n\n    /**\n     * @notice Checks if a certain action is paused on a market\n     * @param action Action id\n     * @param market vToken address\n     */\n    function actionPaused(address market, Action action) external view returns (bool);\n\n    /**\n     * @notice Returns the XVS address\n     * @return The address of XVS token\n     */\n    function getXVSAddress() external view returns (address);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IMarketFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\n\ninterface IMarketFacet {\n    function isComptroller() external pure returns (bool);\n\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function checkMembership(address account, VToken vToken) external view returns (bool);\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory);\n\n    function enterMarket(address user, address vToken) external returns (uint256);\n\n    function exitMarket(address vToken) external returns (uint256);\n\n    function _supportMarket(VToken vToken) external returns (uint256);\n\n    function supportMarket(VToken vToken) external returns (uint256);\n\n    function isMarketListed(VToken vToken) external view returns (bool);\n\n    function getAssetsIn(address account) external view returns (VToken[] memory);\n\n    function getAllMarkets() external view returns (VToken[] memory);\n\n    function updateDelegate(address delegate, bool allowBorrows) external;\n\n    function unlistMarket(address market) external returns (uint256);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IPolicyFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\n\ninterface IPolicyFacet {\n    function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256);\n\n    function mintVerify(address vToken, address minter, uint256 mintAmount, uint256 mintTokens) external;\n\n    function redeemAllowed(address vToken, address redeemer, uint256 redeemTokens) external returns (uint256);\n\n    function redeemVerify(address vToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\n\n    function borrowAllowed(address vToken, address borrower, uint256 borrowAmount) external returns (uint256);\n\n    function borrowAllowed(\n        address vToken,\n        address borrower,\n        address receiver,\n        uint256 borrowAmount\n    ) external returns (uint256);\n\n    function borrowVerify(address vToken, address borrower, uint256 borrowAmount) external;\n\n    function repayBorrowAllowed(\n        address vToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external view returns (uint256);\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenOrExecutor,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(address vToken, address src, address dst, uint256 transferTokens) external;\n\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256);\n\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external view returns (uint256, uint256, uint256);\n\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint256[] calldata supplySpeeds,\n        uint256[] calldata borrowSpeeds\n    ) external;\n\n    function getBorrowingPower(\n        address account\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IRewardFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IFacetBase } from \"./IFacetBase.sol\";\n\ninterface IRewardFacet is IFacetBase {\n    function claimVenus(address holder) external;\n\n    function claimVenus(address holder, VToken[] calldata vTokens) external;\n\n    function claimVenus(address[] calldata holders, VToken[] calldata vTokens, bool borrowers, bool suppliers) external;\n\n    function claimVenusAsCollateral(address holder) external;\n\n    function _grantXVS(address recipient, uint256 amount) external;\n\n    function getXVSVTokenAddress() external view returns (address);\n\n    function claimVenus(\n        address[] calldata holders,\n        VToken[] calldata vTokens,\n        bool borrowers,\n        bool suppliers,\n        bool collateral\n    ) external;\n    function seizeVenus(address[] calldata holders, address recipient) external returns (uint256);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/ISetterFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { VAIControllerInterface } from \"../../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { ComptrollerLensInterface } from \"../../../Comptroller/ComptrollerLensInterface.sol\";\nimport { IPrime } from \"../../../Tokens/Prime/IPrime.sol\";\n\ninterface ISetterFacet {\n    function setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256);\n\n    function _setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256);\n\n    function setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n    function _setAccessControl(address newAccessControlAddress) external returns (uint256);\n\n    function setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256);\n\n    function _setCollateralFactor(VToken vToken, uint256 newCollateralFactorMantissa) external returns (uint256);\n\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\n\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\n\n    function _setLiquidatorContract(address newLiquidatorContract_) external;\n\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint256);\n\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external;\n\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external;\n\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external;\n\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external;\n\n    function _setProtocolPaused(bool state) external returns (bool);\n\n    function setActionsPaused(address[] calldata markets, Action[] calldata actions, bool paused) external;\n\n    function _setActionsPaused(address[] calldata markets, Action[] calldata actions, bool paused) external;\n\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint256);\n\n    function _setVAIMintRate(uint256 newVAIMintRate) external returns (uint256);\n\n    function setMintedVAIOf(address owner, uint256 amount) external returns (uint256);\n\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256);\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external returns (uint256);\n\n    function _setVenusVAIVaultRate(uint256 venusVAIVaultRate_) external;\n\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) external;\n\n    function _setForcedLiquidation(address vToken, bool enable) external;\n\n    function setPrimeToken(IPrime _prime) external returns (uint256);\n\n    function _setPrimeToken(IPrime _prime) external returns (uint);\n\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external;\n\n    function _setForcedLiquidationForUser(address borrower, address vTokenBorrowed, bool enable) external;\n\n    function _setXVSToken(address xvs_) external;\n\n    function _setXVSVToken(address xvsVToken_) external;\n\n    function _setWhitelistedExecutor(address executor, bool status) external;\n}\n"
    },
    "contracts/Comptroller/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { UnitrollerAdminStorage } from \"./ComptrollerStorage.sol\";\nimport { ComptrollerErrorReporter } from \"../Utils/ErrorReporter.sol\";\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * VTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n    /**\n     * @notice Emitted when pendingComptrollerImplementation is changed\n     */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n     * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n        }\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptImplementation() public returns (uint) {\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = comptrollerImplementation;\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller is pendingAdmin\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/DelegateBorrowers/MoveDebtDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\n\nimport { approveOrRevert } from \"../lib/approveOrRevert.sol\";\nimport { IVBep20, IComptroller } from \"../InterfacesV8.sol\";\n\ncontract MoveDebtDelegate is Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @dev VToken return value signalling about successful execution\n    uint256 internal constant NO_ERROR = 0;\n\n    /// @notice A wildcard indicating that repayment is allowed for _any_ user in the market\n    address public constant ANY_USER = address(1);\n\n    /// @notice User to borrow on behalf of\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable newBorrower;\n\n    /// @notice Whether to allow borrowing from the corresponding vToken\n    mapping(address => bool) public borrowAllowed;\n\n    /// @notice Whether to allow repaying to the corresponding vToken on behalf of\n    ///   a certain user. Use ANY_USER to check if repayment is allowed for any user.\n    mapping(address => mapping(address => bool)) public repaymentAllowed;\n\n    /// @notice Emitted when vToken is allowed or denied to be borrowed from\n    event BorrowAllowedSet(address indexed vTokenToBorrow, bool allowed);\n\n    /// @notice Emitted when vToken is allowed or denied to be borrowed from\n    event RepaymentAllowedSet(address indexed vTokenToRepay, address indexed originalBorrower, bool allowed);\n\n    /// @notice Emitted if debt is swapped successfully\n    event DebtMoved(\n        address indexed originalBorrower,\n        address indexed vTokenRepaid,\n        uint256 repaidAmount,\n        address newBorrower,\n        address indexed vTokenBorrowed,\n        uint256 borrowedAmount\n    );\n\n    /// @notice Emitted when the owner transfers tokens, accidentially sent to this contract,\n    ///   to their account\n    event SweptTokens(address indexed token, uint256 amount);\n\n    /// @notice Thrown if VTokens' comptrollers are not equal\n    error ComptrollerMismatch();\n\n    /// @notice Thrown if repayment fails with an error code\n    error RepaymentFailed(uint256 errorCode);\n\n    /// @notice Thrown if borrow fails with an error code\n    error BorrowFailed(uint256 errorCode);\n\n    /// @notice Thrown if borrowing from the corresponding vToken is not allowed\n    error BorrowNotAllowed(address vToken);\n\n    /// @notice Thrown if repaying the debts of the borrower to the corresponding vToken is not allowed\n    error RepaymentNotAllowed(address vToken, address borrower);\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @param newBorrower_ User to borrow on behalf of\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address newBorrower_) {\n        newBorrower = newBorrower_;\n        _disableInitializers();\n    }\n\n    function initialize() external initializer {\n        __Ownable2Step_init();\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @notice Repays originalBorrower's borrow in vTokenToRepay.underlying() and borrows\n     *   vTokenToBorrow.underlying() on behalf of newBorrower.\n     *\n     * @param originalBorrower The address of the borrower, whose debt to repay\n     * @param vTokenToRepay VToken to repay to on behalf of originalBorrower\n     * @param repayAmount The amount to repay in terms of vTokenToRepay.underlying()\n     * @param vTokenToBorrow VToken to borrow from\n     */\n    function moveDebt(\n        IVBep20 vTokenToRepay,\n        address originalBorrower,\n        uint256 repayAmount,\n        IVBep20 vTokenToBorrow\n    ) external nonReentrant {\n        if (!borrowAllowed[address(vTokenToBorrow)]) {\n            revert BorrowNotAllowed(address(vTokenToBorrow));\n        }\n\n        mapping(address => bool) storage repaymentAllowedFor = repaymentAllowed[address(vTokenToRepay)];\n        if (!repaymentAllowedFor[ANY_USER] && !repaymentAllowedFor[originalBorrower]) {\n            revert RepaymentNotAllowed(address(vTokenToRepay), originalBorrower);\n        }\n\n        uint256 actualRepaymentAmount = _repay(vTokenToRepay, originalBorrower, repayAmount);\n        uint256 amountToBorrow = _convert(vTokenToRepay, vTokenToBorrow, actualRepaymentAmount);\n        _borrow(vTokenToBorrow, amountToBorrow);\n        emit DebtMoved(\n            originalBorrower,\n            address(vTokenToRepay),\n            actualRepaymentAmount,\n            newBorrower,\n            address(vTokenToBorrow),\n            amountToBorrow\n        );\n    }\n\n    /**\n     * @notice Allows or denies borrowing from the corresponding vToken\n     * @param vTokenToBorrow VToken to borrow from\n     * @param allow Whether to allow borrowing from the corresponding vToken\n     */\n    function setBorrowAllowed(address vTokenToBorrow, bool allow) external onlyOwner {\n        ensureNonzeroAddress(vTokenToBorrow);\n        if (borrowAllowed[vTokenToBorrow] != allow) {\n            borrowAllowed[vTokenToBorrow] = allow;\n            emit BorrowAllowedSet(vTokenToBorrow, allow);\n        }\n    }\n\n    /**\n     * @notice Allows or denies repaying the debts of originalBorrower to the corresponding vToken\n     * @param vTokenToRepay VToken to repay to\n     * @param originalBorrower The address of the borrower, whose debt to repay (or ANY_USER to allow\n     *   repayments for all users in the market, e.g. if the market is going to be deprecated soon)\n     * @param allow Whether to allow repaying to the corresponding vToken on behalf of originalBorrower\n     */\n    function setRepaymentAllowed(address vTokenToRepay, address originalBorrower, bool allow) external onlyOwner {\n        ensureNonzeroAddress(vTokenToRepay);\n        ensureNonzeroAddress(originalBorrower);\n        if (repaymentAllowed[vTokenToRepay][originalBorrower] != allow) {\n            repaymentAllowed[vTokenToRepay][originalBorrower] = allow;\n            emit RepaymentAllowedSet(vTokenToRepay, originalBorrower, allow);\n        }\n    }\n\n    /**\n     * @notice Transfers tokens, accidentially sent to this contract, to the owner\n     * @param token ERC-20 token to sweep\n     */\n    function sweepTokens(IERC20Upgradeable token) external onlyOwner {\n        uint256 amount = token.balanceOf(address(this));\n        token.safeTransfer(owner(), amount);\n        emit SweptTokens(address(token), amount);\n    }\n\n    /**\n     * @dev Transfers the funds from the sender and repays a borrow in vToken on behalf of the borrower\n     * @param vTokenToRepay VToken to repay to\n     * @param borrower The address of the borrower, whose debt to repay\n     * @param repayAmount The amount to repay in terms of underlying\n     */\n    function _repay(\n        IVBep20 vTokenToRepay,\n        address borrower,\n        uint256 repayAmount\n    ) internal returns (uint256 actualRepaymentAmount) {\n        IERC20Upgradeable underlying = IERC20Upgradeable(vTokenToRepay.underlying());\n        uint256 balanceBefore = underlying.balanceOf(address(this));\n        underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\n        uint256 balanceAfter = underlying.balanceOf(address(this));\n        uint256 repayAmountMinusFee = balanceAfter - balanceBefore;\n\n        uint256 borrowBalanceBefore = vTokenToRepay.borrowBalanceCurrent(borrower);\n        approveOrRevert(underlying, address(vTokenToRepay), repayAmountMinusFee);\n        uint256 err = vTokenToRepay.repayBorrowBehalf(borrower, repayAmountMinusFee);\n        if (err != NO_ERROR) {\n            revert RepaymentFailed(err);\n        }\n        approveOrRevert(underlying, address(vTokenToRepay), 0);\n        uint256 borrowBalanceAfter = vTokenToRepay.borrowBalanceCurrent(borrower);\n        return borrowBalanceBefore - borrowBalanceAfter;\n    }\n\n    /**\n     * @dev Borrows in vToken on behalf of the borrower and transfers the funds to the sender\n     * @param vTokenToBorrow VToken to borrow from\n     * @param borrowAmount The amount to borrow in terms of underlying\n     */\n    function _borrow(IVBep20 vTokenToBorrow, uint256 borrowAmount) internal {\n        IERC20Upgradeable underlying = IERC20Upgradeable(vTokenToBorrow.underlying());\n        uint256 balanceBefore = underlying.balanceOf(address(this));\n        uint256 err = vTokenToBorrow.borrowBehalf(newBorrower, borrowAmount);\n        if (err != NO_ERROR) {\n            revert BorrowFailed(err);\n        }\n        uint256 balanceAfter = underlying.balanceOf(address(this));\n        uint256 actualBorrowedAmount = balanceAfter - balanceBefore;\n        underlying.safeTransfer(msg.sender, actualBorrowedAmount);\n    }\n\n    /**\n     * @dev Converts the value expressed in convertFrom.underlying() to a value\n     *   in convertTo.underlying(), using the oracle price\n     * @param convertFrom VToken to convert from\n     * @param convertTo VToken to convert to\n     * @param amount The amount in convertFrom.underlying()\n     */\n    function _convert(IVBep20 convertFrom, IVBep20 convertTo, uint256 amount) internal view returns (uint256) {\n        IComptroller comptroller = convertFrom.comptroller();\n        if (comptroller != convertTo.comptroller()) {\n            revert ComptrollerMismatch();\n        }\n        ResilientOracleInterface oracle = comptroller.oracle();\n\n        // Decimals are accounted for in the oracle contract\n        uint256 scaledUsdValue = oracle.getUnderlyingPrice(address(convertFrom)) * amount; // the USD value here has 36 decimals\n        return scaledUsdValue / oracle.getUnderlyingPrice(address(convertTo));\n    }\n}\n"
    },
    "contracts/DelegateBorrowers/SwapDebtDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { approveOrRevert } from \"../lib/approveOrRevert.sol\";\nimport { IVBep20, IComptroller } from \"../InterfacesV8.sol\";\n\ncontract SwapDebtDelegate is Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @dev VToken return value signalling about successful execution\n    uint256 internal constant NO_ERROR = 0;\n\n    /// @notice Emitted if debt is swapped successfully\n    event DebtSwapped(\n        address indexed borrower,\n        address indexed vTokenRepaid,\n        uint256 repaidAmount,\n        address indexed vTokenBorrowed,\n        uint256 borrowedAmount\n    );\n\n    /// @notice Emitted when the owner transfers tokens, accidentially sent to this contract,\n    ///   to their account\n    event SweptTokens(address indexed token, uint256 amount);\n\n    /// @notice Thrown if VTokens' comptrollers are not equal\n    error ComptrollerMismatch();\n\n    /// @notice Thrown if repayment fails with an error code\n    error RepaymentFailed(uint256 errorCode);\n\n    /// @notice Thrown if borrow fails with an error code\n    error BorrowFailed(uint256 errorCode);\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    function initialize() external initializer {\n        __Ownable2Step_init();\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @notice Repays a borrow in repayTo.underlying() and borrows borrowFrom.underlying()\n     * @param borrower The address of the borrower, whose debt to swap\n     * @param repayTo VToken to repay the debt to\n     * @param borrowFrom VToken to borrow from\n     * @param repayAmount The amount to repay in terms of repayTo.underlying()\n     */\n    function swapDebt(\n        address borrower,\n        IVBep20 repayTo,\n        IVBep20 borrowFrom,\n        uint256 repayAmount\n    ) external onlyOwner nonReentrant {\n        uint256 actualRepaymentAmount = _repay(repayTo, borrower, repayAmount);\n        uint256 amountToBorrow = _convert(repayTo, borrowFrom, actualRepaymentAmount);\n        _borrow(borrowFrom, borrower, amountToBorrow);\n        emit DebtSwapped(borrower, address(repayTo), actualRepaymentAmount, address(borrowFrom), amountToBorrow);\n    }\n\n    /**\n     * @notice Transfers tokens, accidentially sent to this contract, to the owner\n     * @param token ERC-20 token to sweep\n     */\n    function sweepTokens(IERC20Upgradeable token) external onlyOwner {\n        uint256 amount = token.balanceOf(address(this));\n        token.safeTransfer(owner(), amount);\n        emit SweptTokens(address(token), amount);\n    }\n\n    /**\n     * @dev Transfers the funds from the sender and repays a borrow in vToken on behalf of the borrower\n     * @param vToken VToken to repay the debt to\n     * @param borrower The address of the borrower, whose debt to repay\n     * @param repayAmount The amount to repay in terms of underlying\n     */\n    function _repay(\n        IVBep20 vToken,\n        address borrower,\n        uint256 repayAmount\n    ) internal returns (uint256 actualRepaymentAmount) {\n        IERC20Upgradeable underlying = IERC20Upgradeable(vToken.underlying());\n        uint256 balanceBefore = underlying.balanceOf(address(this));\n        underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\n        uint256 balanceAfter = underlying.balanceOf(address(this));\n        uint256 repayAmountMinusFee = balanceAfter - balanceBefore;\n\n        underlying.safeApprove(address(vToken), 0);\n        underlying.safeApprove(address(vToken), repayAmountMinusFee);\n        uint256 borrowBalanceBefore = vToken.borrowBalanceCurrent(borrower);\n        uint256 err = vToken.repayBorrowBehalf(borrower, repayAmountMinusFee);\n        if (err != NO_ERROR) {\n            revert RepaymentFailed(err);\n        }\n        uint256 borrowBalanceAfter = vToken.borrowBalanceCurrent(borrower);\n        return borrowBalanceBefore - borrowBalanceAfter;\n    }\n\n    /**\n     * @dev Borrows in vToken on behalf of the borrower and transfers the funds to the sender\n     * @param vToken VToken to borrow from\n     * @param borrower The address of the borrower, who will own the borrow\n     * @param borrowAmount The amount to borrow in terms of underlying\n     */\n    function _borrow(IVBep20 vToken, address borrower, uint256 borrowAmount) internal {\n        IERC20Upgradeable underlying = IERC20Upgradeable(vToken.underlying());\n        uint256 balanceBefore = underlying.balanceOf(address(this));\n        uint256 err = vToken.borrowBehalf(borrower, borrowAmount);\n        if (err != NO_ERROR) {\n            revert BorrowFailed(err);\n        }\n        uint256 balanceAfter = underlying.balanceOf(address(this));\n        uint256 actualBorrowedAmount = balanceAfter - balanceBefore;\n        underlying.safeTransfer(msg.sender, actualBorrowedAmount);\n    }\n\n    /**\n     * @dev Converts the value expressed in convertFrom.underlying() to a value\n     *   in convertTo.underlying(), using the oracle price\n     * @param convertFrom VToken to convert from\n     * @param convertTo VToken to convert to\n     * @param amount The amount in convertFrom.underlying()\n     */\n    function _convert(IVBep20 convertFrom, IVBep20 convertTo, uint256 amount) internal view returns (uint256) {\n        IComptroller comptroller = convertFrom.comptroller();\n        if (comptroller != convertTo.comptroller()) {\n            revert ComptrollerMismatch();\n        }\n        ResilientOracleInterface oracle = comptroller.oracle();\n\n        // Decimals are accounted for in the oracle contract\n        uint256 scaledUsdValue = oracle.getUnderlyingPrice(address(convertFrom)) * amount; // the USD value here has 36 decimals\n        return scaledUsdValue / oracle.getUnderlyingPrice(address(convertTo));\n    }\n}\n"
    },
    "contracts/external/IProtocolShareReserve.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IProtocolShareReserve {\n    enum IncomeType {\n        SPREAD,\n        LIQUIDATION\n    }\n\n    function updateAssetsState(address comptroller, address asset, IncomeType incomeType) external;\n}\n"
    },
    "contracts/external/IWBNB.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IWBNB is IERC20Upgradeable {\n    function deposit() external payable;\n}\n"
    },
    "contracts/Governance/TokenRedeemer.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\n\nimport { IVAIController, IVToken, IVBep20, IVBNB } from \"../InterfacesV8.sol\";\nimport { Currency, CurrencyLibrary } from \"../lib/Currency.sol\";\n\ncontract TokenRedeemer is ReentrancyGuard, Ownable2Step {\n    using CurrencyLibrary for Currency;\n\n    struct Repayment {\n        address borrower;\n        uint256 amount;\n    }\n\n    IVBNB public immutable VBNB;\n\n    error AccrueInterestFailed(uint256 errCode);\n    error RedeemFailed(uint256 errCode);\n    error RepaymentFailed(uint256 errCode);\n    error NativeTokenTransferFailed();\n\n    constructor(address owner_, IVBNB vBNB) {\n        ensureNonzeroAddress(owner_);\n        VBNB = vBNB;\n        _transferOwnership(owner_);\n    }\n\n    receive() external payable {}\n\n    function redeemAndTransfer(IVToken vToken, address destination) external nonReentrant onlyOwner {\n        Currency underlying = _underlying(vToken);\n        uint256 err = vToken.redeem(vToken.balanceOf(address(this)));\n        if (err != 0) {\n            revert RedeemFailed(err);\n        }\n        underlying.transferAll(destination);\n    }\n\n    function redeemUnderlyingAndTransfer(\n        IVToken vToken,\n        address destination,\n        uint256 amount,\n        address receiver\n    ) external nonReentrant onlyOwner {\n        Currency underlying = _underlying(vToken);\n        underlying.transferAll(receiver); // Just in case there were some underlying tokens on the contract\n        uint256 err = vToken.redeemUnderlying(amount);\n        if (err != 0) {\n            revert RedeemFailed(err);\n        }\n        underlying.transferAll(destination);\n        Currency.wrap(address(vToken)).transferAll(receiver);\n    }\n\n    function redeemUnderlyingAndRepayBorrowBehalf(\n        IVToken vToken,\n        address borrower,\n        uint256 amount,\n        address receiver\n    ) external nonReentrant onlyOwner {\n        Currency underlying = _underlying(vToken);\n\n        uint256 err = vToken.redeemUnderlying(amount);\n        if (err != 0) {\n            revert RedeemFailed(err);\n        }\n\n        underlying.approve(address(vToken), amount);\n\n        _repay(vToken, borrower, amount);\n\n        underlying.approve(address(vToken), 0);\n\n        underlying.transferAll(receiver);\n        Currency.wrap(address(vToken)).transferAll(receiver);\n    }\n\n    function redeemAndBatchRepay(\n        IVToken vToken,\n        Repayment[] calldata requestedRepayments,\n        address receiver\n    ) external nonReentrant onlyOwner {\n        _accrueInterest(vToken);\n\n        (uint256 totalBorrowedAmount, Repayment[] memory repayments) = _getAmountsToRepay(vToken, requestedRepayments);\n        _redeemUpTo(vToken, totalBorrowedAmount);\n\n        Currency underlying = _underlying(vToken);\n        uint256 balance = underlying.balanceOfSelf();\n        underlying.approve(address(vToken), totalBorrowedAmount);\n        uint256 repaymentsCount = repayments.length;\n        // The code below assumes no fees on transfer\n        if (balance >= totalBorrowedAmount) {\n            // If we're doing a full repayment, we can optimize it by skipping the balance checks\n            for (uint256 i = 0; i < repaymentsCount; ++i) {\n                Repayment memory repayment = repayments[i];\n                _repay(vToken, repayment.borrower, repayment.amount);\n            }\n        } else {\n            // Otherwise, we have to check and update the balance on every iteration\n            for (uint256 i = 0; i < repaymentsCount && balance != 0; ++i) {\n                Repayment memory repayment = repayments[i];\n                _repay(vToken, repayment.borrower, _min(repayment.amount, balance));\n                balance = underlying.balanceOfSelf();\n            }\n        }\n        underlying.approve(address(vToken), 0);\n\n        underlying.transferAll(receiver);\n        Currency.wrap(address(vToken)).transferAll(receiver);\n    }\n\n    function batchRepayVAI(\n        IVAIController vaiController,\n        Repayment[] calldata requestedRepayments,\n        address receiver\n    ) external nonReentrant onlyOwner {\n        vaiController.accrueVAIInterest();\n        Currency vai = Currency.wrap(vaiController.getVAIAddress());\n        uint256 balance = vai.balanceOfSelf();\n        vai.approve(address(vaiController), type(uint256).max);\n        uint256 repaymentsCount = requestedRepayments.length;\n        for (uint256 i = 0; i < repaymentsCount && balance != 0; ++i) {\n            Repayment calldata requestedRepayment = requestedRepayments[i];\n            uint256 repaymentCap = requestedRepayment.amount;\n            uint256 debt = vaiController.getVAIRepayAmount(requestedRepayment.borrower);\n            uint256 amount = _min(repaymentCap, debt);\n            _repayVAI(vaiController, requestedRepayment.borrower, _min(amount, balance));\n            balance = vai.balanceOfSelf();\n        }\n        vai.approve(address(vaiController), 0);\n        vai.transferAll(receiver);\n    }\n\n    function sweepTokens(address token, address destination) external onlyOwner {\n        Currency.wrap(token).transferAll(destination);\n    }\n\n    function _accrueInterest(IVToken vToken) internal {\n        uint256 err = vToken.accrueInterest();\n        if (err != 0) {\n            revert AccrueInterestFailed(err);\n        }\n    }\n\n    function _redeemUpTo(IVToken vToken, uint256 amount) internal {\n        uint256 unredeemedUnderlying = vToken.balanceOfUnderlying(address(this));\n        if (unredeemedUnderlying > 0) {\n            uint256 err = vToken.redeemUnderlying(_min(amount, unredeemedUnderlying));\n            if (err != 0) {\n                revert RedeemFailed(err);\n            }\n        }\n    }\n\n    function _repay(IVToken vToken, address borrower, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n        if (_isVBNB(vToken)) {\n            IVBNB(address(vToken)).repayBorrowBehalf{ value: amount }(borrower);\n        } else {\n            uint256 err = IVBep20(address(vToken)).repayBorrowBehalf(borrower, amount);\n            if (err != 0) {\n                revert RepaymentFailed(err);\n            }\n        }\n    }\n\n    function _repayVAI(IVAIController vaiController, address borrower, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n        (uint256 err, ) = vaiController.repayVAIBehalf(borrower, amount);\n        if (err != 0) {\n            revert RepaymentFailed(err);\n        }\n    }\n\n    function _getAmountsToRepay(\n        IVToken vToken,\n        Repayment[] calldata requestedRepayments\n    ) internal view returns (uint256, Repayment[] memory) {\n        uint256 repaymentsCount = requestedRepayments.length;\n        Repayment[] memory actualRepayments = new Repayment[](repaymentsCount);\n        uint256 totalAmountToRepay = 0;\n        for (uint256 i = 0; i < repaymentsCount; ++i) {\n            Repayment calldata requestedRepayment = requestedRepayments[i];\n            uint256 repaymentCap = requestedRepayment.amount;\n            uint256 debt = vToken.borrowBalanceStored(requestedRepayment.borrower);\n            uint256 amountToRepay = _min(repaymentCap, debt);\n            totalAmountToRepay += amountToRepay;\n            actualRepayments[i] = Repayment({ borrower: requestedRepayment.borrower, amount: amountToRepay });\n        }\n        return (totalAmountToRepay, actualRepayments);\n    }\n\n    function _underlying(IVToken vToken) internal view returns (Currency) {\n        if (_isVBNB(vToken)) {\n            return CurrencyLibrary.NATIVE;\n        }\n        return Currency.wrap(IVBep20(address(vToken)).underlying());\n    }\n\n    function _isVBNB(IVToken vToken) internal view returns (bool) {\n        return address(vToken) == address(VBNB);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/Governance/VTreasuryV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title VTreasuryV8\n * @author Venus\n * @notice Protocol treasury that holds tokens owned by Venus\n */\ncontract VTreasuryV8 is Ownable2Step, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // WithdrawTreasuryToken Event\n    event WithdrawTreasuryToken(address indexed tokenAddress, uint256 withdrawAmount, address indexed withdrawAddress);\n\n    // WithdrawTreasuryNative Event\n    event WithdrawTreasuryNative(uint256 withdrawAmount, address indexed withdrawAddress);\n\n    /// @notice Thrown if the supplied address is a zero address where it is not allowed\n    error ZeroAddressNotAllowed();\n\n    /**\n     * @notice To receive Native when msg.data is not empty\n     */\n    fallback() external payable {}\n\n    /**\n     * @notice To receive Native when msg.data is empty\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Withdraw Treasury  Tokens, Only owner call it\n     * @param tokenAddress The address of treasury token\n     * @param withdrawAmount The withdraw amount to owner\n     * @param withdrawAddress The withdraw address\n     * @custom:error ZeroAddressNotAllowed thrown when token or withdrawAddress is zero.\n     */\n    function withdrawTreasuryToken(\n        address tokenAddress,\n        uint256 withdrawAmount,\n        address withdrawAddress\n    ) external onlyOwner nonReentrant {\n        ensureNonzeroAddress(tokenAddress);\n        ensureNonzeroAddress(withdrawAddress);\n        require(withdrawAmount > 0, \"withdrawAmount must not be zero\");\n\n        uint256 actualWithdrawAmount = withdrawAmount;\n        // Get Treasury Token Balance\n        uint256 treasuryBalance = IERC20(tokenAddress).balanceOf(address(this));\n\n        // Check Withdraw Amount\n        if (withdrawAmount > treasuryBalance) {\n            // Update actualWithdrawAmount\n            actualWithdrawAmount = treasuryBalance;\n        }\n\n        // Transfer Token to withdrawAddress\n        IERC20(tokenAddress).safeTransfer(withdrawAddress, actualWithdrawAmount);\n\n        emit WithdrawTreasuryToken(tokenAddress, actualWithdrawAmount, withdrawAddress);\n    }\n\n    /**\n     * @notice Withdraw Treasury Native, Only owner call it\n     * @param withdrawAmount The withdraw amount to owner\n     * @param withdrawAddress The withdraw address\n     * @custom:error ZeroAddressNotAllowed thrown when withdrawAddress is zero.\n     */\n    function withdrawTreasuryNative(\n        uint256 withdrawAmount,\n        address payable withdrawAddress\n    ) external payable onlyOwner nonReentrant {\n        ensureNonzeroAddress(withdrawAddress);\n        require(withdrawAmount > 0, \"withdrawAmount must not be zero\");\n        uint256 actualWithdrawAmount = withdrawAmount;\n        // Get Treasury Native Balance\n        uint256 nativeBalance = address(this).balance;\n\n        // Check Withdraw Amount\n        if (withdrawAmount > nativeBalance) {\n            // Update actualWithdrawAmount\n            actualWithdrawAmount = nativeBalance;\n        }\n        // Transfer the native token to withdrawAddress\n        (bool sent, ) = withdrawAddress.call{ value: actualWithdrawAmount }(\"\");\n        require(sent, \"Call failed\");\n        emit WithdrawTreasuryNative(actualWithdrawAmount, withdrawAddress);\n    }\n\n    /// @notice Checks if the provided address is nonzero, reverts otherwise\n    /// @param address_ Address to check\n    /// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\n    function ensureNonzeroAddress(address address_) internal pure {\n        if (address_ == address(0)) {\n            revert ZeroAddressNotAllowed();\n        }\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/hardhat-deploy/solc_0.8/openzeppelin/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'hardhat-deploy/solc_0.8/openzeppelin/proxy/transparent/ProxyAdmin.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/hardhat-deploy/solc_0.8/proxy/OptimizedTransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'hardhat-deploy/solc_0.8/proxy/OptimizedTransparentUpgradeableProxy.sol';\n"
    },
    "contracts/InterestRateModels/InterestRateModelV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Venus's InterestRateModelV8 Interface\n * @author Venus\n */\nabstract contract InterestRateModelV8 {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view virtual returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view virtual returns (uint256);\n}\n"
    },
    "contracts/InterestRateModels/TwoKinksInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { InterestRateModelV8 } from \"./InterestRateModelV8.sol\";\n\n/**\n * @title TwoKinksInterestRateModel\n * @author Venus\n * @notice An interest rate model with two different slope increase or decrease each after a certain utilization threshold called **kink** is reached.\n */\ncontract TwoKinksInterestRateModel is InterestRateModelV8 {\n    int256 public immutable BLOCKS_PER_YEAR;\n\n    ////////////////////// SLOPE 1 //////////////////////\n\n    /**\n     * @notice The multiplier of utilization rate per block that gives the slope 1 of the interest rate scaled by EXP_SCALE\n     */\n    int256 public immutable MULTIPLIER_PER_BLOCK;\n\n    /**\n     * @notice The base interest rate per block which is the y-intercept when utilization rate is 0 scaled by EXP_SCALE\n     */\n    int256 public immutable BASE_RATE_PER_BLOCK;\n\n    ////////////////////// SLOPE 2 //////////////////////\n\n    /**\n     * @notice The utilization point at which the multiplier2 is applied\n     */\n    int256 public immutable KINK_1;\n\n    /**\n     * @notice The multiplier of utilization rate per block that gives the slope 2 of the interest rate scaled by EXP_SCALE\n     */\n    int256 public immutable MULTIPLIER_2_PER_BLOCK;\n\n    /**\n     * @notice The base interest rate per block which is the y-intercept when utilization rate hits KINK_1 scaled by EXP_SCALE\n     */\n    int256 public immutable BASE_RATE_2_PER_BLOCK;\n\n    /**\n     * @notice The maximum kink interest rate scaled by EXP_SCALE\n     */\n    int256 public immutable RATE_1;\n\n    ////////////////////// SLOPE 3 //////////////////////\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    int256 public immutable KINK_2;\n\n    /**\n     * @notice The multiplier of utilization rate per block that gives the slope 3 of interest rate scaled by EXP_SCALE\n     */\n    int256 public immutable JUMP_MULTIPLIER_PER_BLOCK;\n\n    /**\n     * @notice The maximum kink interest rate scaled by EXP_SCALE\n     */\n    int256 public immutable RATE_2;\n\n    /// @notice Base unit for computations, usually used in scaling (multiplications, divisions)\n    uint256 internal constant EXP_SCALE = 1e18;\n\n    /**\n     * @notice Thrown when a negative value is not allowed\n     */\n    error NegativeValueNotAllowed();\n\n    /**\n     * @notice Thrown when the kink points are not in the correct order\n     */\n    error InvalidKink();\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear_ The approximate target base APR, as a mantissa (scaled by EXP_SCALE)\n     * @param multiplierPerYear_ The rate of increase or decrease in interest rate wrt utilization (scaled by EXP_SCALE)\n     * @param kink1_ The utilization point at which the multiplier2 is applied\n     * @param multiplier2PerYear_ The rate of increase or decrease in interest rate wrt utilization after hitting KINK_1 (scaled by EXP_SCALE)\n     * @param baseRate2PerYear_ The additional base APR after hitting KINK_1, as a mantissa (scaled by EXP_SCALE)\n     * @param kink2_ The utilization point at which the jump multiplier is applied\n     * @param jumpMultiplierPerYear_ The multiplier after hitting KINK_2\n     * @param blocksPerYear_ The approximate number of blocks per year to assume\n     */\n    constructor(\n        int256 baseRatePerYear_,\n        int256 multiplierPerYear_,\n        int256 kink1_,\n        int256 multiplier2PerYear_,\n        int256 baseRate2PerYear_,\n        int256 kink2_,\n        int256 jumpMultiplierPerYear_,\n        int256 blocksPerYear_\n    ) {\n        if (baseRatePerYear_ < 0 || baseRate2PerYear_ < 0) {\n            revert NegativeValueNotAllowed();\n        }\n\n        if (kink2_ <= kink1_ || kink1_ <= 0) {\n            revert InvalidKink();\n        }\n\n        BLOCKS_PER_YEAR = blocksPerYear_;\n        BASE_RATE_PER_BLOCK = baseRatePerYear_ / BLOCKS_PER_YEAR;\n        MULTIPLIER_PER_BLOCK = multiplierPerYear_ / BLOCKS_PER_YEAR;\n        KINK_1 = kink1_;\n        MULTIPLIER_2_PER_BLOCK = multiplier2PerYear_ / BLOCKS_PER_YEAR;\n        BASE_RATE_2_PER_BLOCK = baseRate2PerYear_ / BLOCKS_PER_YEAR;\n        KINK_2 = kink2_;\n        JUMP_MULTIPLIER_PER_BLOCK = jumpMultiplierPerYear_ / BLOCKS_PER_YEAR;\n\n        int256 expScale = int256(EXP_SCALE);\n        RATE_1 = (((KINK_1 * MULTIPLIER_PER_BLOCK) / expScale) + BASE_RATE_PER_BLOCK);\n\n        int256 slope2Util;\n        unchecked {\n            slope2Util = KINK_2 - KINK_1;\n        }\n        RATE_2 = ((slope2Util * MULTIPLIER_2_PER_BLOCK) / expScale) + BASE_RATE_2_PER_BLOCK;\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per slot (block)\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per slot (block) as a mantissa (scaled by EXP_SCALE)\n     */\n    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view override returns (uint256) {\n        return _getBorrowRate(cash, borrows, reserves);\n    }\n\n    /**\n     * @notice Calculates the current supply rate per slot (block)\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per slot (block) as a mantissa (scaled by EXP_SCALE)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view virtual override returns (uint256) {\n        uint256 oneMinusReserveFactor = EXP_SCALE - reserveFactorMantissa;\n        uint256 borrowRate = _getBorrowRate(cash, borrows, reserves);\n        uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / EXP_SCALE;\n        return (utilizationRate(cash, borrows, reserves) * rateToPool) / EXP_SCALE;\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The utilization rate as a mantissa between [0, EXP_SCALE]\n     */\n    function utilizationRate(uint256 cash, uint256 borrows, uint256 reserves) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        uint256 rate = (borrows * EXP_SCALE) / (cash + borrows - reserves);\n\n        if (rate > EXP_SCALE) {\n            rate = EXP_SCALE;\n        }\n\n        return rate;\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per slot (block), with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per slot (block) as a mantissa (scaled by EXP_SCALE)\n     */\n    function _getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) internal view returns (uint256) {\n        int256 util = int256(utilizationRate(cash, borrows, reserves));\n        int256 expScale = int256(EXP_SCALE);\n\n        if (util < KINK_1) {\n            return _minCap(((util * MULTIPLIER_PER_BLOCK) / expScale) + BASE_RATE_PER_BLOCK);\n        } else if (util < KINK_2) {\n            int256 slope2Util;\n            unchecked {\n                slope2Util = util - KINK_1;\n            }\n            int256 rate2 = ((slope2Util * MULTIPLIER_2_PER_BLOCK) / expScale) + BASE_RATE_2_PER_BLOCK;\n\n            return _minCap(RATE_1 + rate2);\n        } else {\n            int256 slope3Util;\n            unchecked {\n                slope3Util = util - KINK_2;\n            }\n            int256 rate3 = ((slope3Util * JUMP_MULTIPLIER_PER_BLOCK) / expScale);\n\n            return _minCap(RATE_1 + RATE_2 + rate3);\n        }\n    }\n\n    /**\n     * @notice Returns 0 if number is less than 0, otherwise returns the input\n     * @param number The first number\n     * @return The maximum of 0 and input number\n     */\n    function _minCap(int256 number) internal pure returns (uint256) {\n        int256 zero;\n        return uint256(number > zero ? number : zero);\n    }\n}\n"
    },
    "contracts/InterfacesV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\ninterface IVToken is IERC20Upgradeable {\n    function accrueInterest() external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrowBalanceCurrent(address borrower) external returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function comptroller() external view returns (IComptroller);\n\n    function borrowBalanceStored(address account) external view returns (uint256);\n\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\n\n    function underlying() external view returns (address);\n\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint);\n}\n\ninterface IVBep20 is IVToken {\n    function borrowBehalf(address borrower, uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        IVToken vTokenCollateral\n    ) external returns (uint256);\n\n    function underlying() external view returns (address);\n}\n\ninterface IVBNB is IVToken {\n    function repayBorrowBehalf(address borrower) external payable;\n\n    function liquidateBorrow(address borrower, IVToken vTokenCollateral) external payable;\n}\n\ninterface IVAIController {\n    function accrueVAIInterest() external;\n\n    function liquidateVAI(\n        address borrower,\n        uint256 repayAmount,\n        IVToken vTokenCollateral\n    ) external returns (uint256, uint256);\n\n    function repayVAIBehalf(address borrower, uint256 amount) external returns (uint256, uint256);\n\n    function getVAIAddress() external view returns (address);\n\n    function getVAIRepayAmount(address borrower) external view returns (uint256);\n}\n\ninterface IComptroller {\n    enum Action {\n        MINT,\n        REDEEM,\n        BORROW,\n        REPAY,\n        SEIZE,\n        LIQUIDATE,\n        TRANSFER,\n        ENTER_MARKET,\n        EXIT_MARKET\n    }\n\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external;\n\n    function liquidationIncentiveMantissa() external view returns (uint256);\n\n    function vaiController() external view returns (IVAIController);\n\n    function liquidatorContract() external view returns (address);\n\n    function oracle() external view returns (ResilientOracleInterface);\n\n    function actionPaused(address market, Action action) external view returns (bool);\n\n    function markets(address) external view returns (bool, uint256, bool);\n\n    function isForcedLiquidationEnabled(address) external view returns (bool);\n\n    function approvedDelegates(address borrower, address delegate) external view returns (bool);\n\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256);\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory);\n\n    function enterMarket(address user, address vToken) external returns (uint256);\n}\n\ninterface ILiquidator {\n    function restrictLiquidation(address borrower) external;\n\n    function unrestrictLiquidation(address borrower) external;\n\n    function addToAllowlist(address borrower, address liquidator) external;\n\n    function removeFromAllowlist(address borrower, address liquidator) external;\n\n    function liquidateBorrow(\n        address vToken,\n        address borrower,\n        uint256 repayAmount,\n        IVToken vTokenCollateral\n    ) external payable;\n\n    function setTreasuryPercent(uint256 newTreasuryPercentMantissa) external;\n\n    function treasuryPercentMantissa() external view returns (uint256);\n}\n"
    },
    "contracts/Lens/ComptrollerLens.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { ExponentialNoError } from \"../Utils/ExponentialNoError.sol\";\nimport { ComptrollerErrorReporter } from \"../Utils/ErrorReporter.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { ComptrollerLensInterface } from \"../Comptroller/ComptrollerLensInterface.sol\";\nimport { VAIControllerInterface } from \"../Tokens/VAI/VAIControllerInterface.sol\";\n\n/**\n * @title ComptrollerLens Contract\n * @author Venus\n * @notice The ComptrollerLens contract has functions to get the number of tokens that\n * can be seized through liquidation, hypothetical account liquidity and shortfall of an account.\n */\ncontract ComptrollerLens is ComptrollerLensInterface, ComptrollerErrorReporter, ExponentialNoError {\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint sumCollateral;\n        uint sumBorrowPlusEffects;\n        uint vTokenBalance;\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Computes the number of collateral tokens to be seized in a liquidation event\n     * @param comptroller Address of comptroller\n     * @param vTokenBorrowed Address of the borrowed vToken\n     * @param vTokenCollateral Address of collateral for the borrow\n     * @param actualRepayAmount Repayment amount i.e amount to be repaid of total borrowed amount\n     * @return A tuple of error code, and tokens to seize\n     */\n    function liquidateCalculateSeizeTokens(\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(vTokenBorrowed);\n        uint priceCollateralMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(vTokenCollateral);\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(\n            Exp({ mantissa: ComptrollerInterface(comptroller).liquidationIncentiveMantissa() }),\n            Exp({ mantissa: priceBorrowedMantissa })\n        );\n        denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /**\n     * @notice Computes the number of VAI tokens to be seized in a liquidation event\n     * @param comptroller Address of comptroller\n     * @param vTokenCollateral Address of collateral for vToken\n     * @param actualRepayAmount Repayment amount i.e amount to be repaid of the total borrowed amount\n     * @return A tuple of error code, and tokens to seize\n     */\n    function liquidateVAICalculateSeizeTokens(\n        address comptroller,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = 1e18; // Note: this is VAI\n        uint priceCollateralMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(vTokenCollateral);\n        if (priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(\n            Exp({ mantissa: ComptrollerInterface(comptroller).liquidationIncentiveMantissa() }),\n            Exp({ mantissa: priceBorrowedMantissa })\n        );\n        denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /**\n     * @notice Computes the hypothetical liquidity and shortfall of an account given a hypothetical borrow\n     *      A snapshot of the account is taken and the total borrow amount of the account is calculated\n     * @param comptroller Address of comptroller\n     * @param account Address of the borrowed vToken\n     * @param vTokenModify Address of collateral for vToken\n     * @param redeemTokens Number of vTokens being redeemed\n     * @param borrowAmount Amount borrowed\n     * @return Returns a tuple of error code, liquidity, and shortfall\n     */\n    function getHypotheticalAccountLiquidity(\n        address comptroller,\n        address account,\n        VToken vTokenModify,\n        uint redeemTokens,\n        uint borrowAmount\n    ) external view returns (uint, uint, uint) {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint oErr;\n\n        // For each asset the account is in\n        VToken[] memory assets = ComptrollerInterface(comptroller).getAssetsIn(account);\n        uint assetsCount = assets.length;\n        for (uint i = 0; i < assetsCount; ++i) {\n            VToken asset = assets[i];\n\n            // Read the balances and exchange rate from the vToken\n            (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(\n                account\n            );\n            if (oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (uint(Error.SNAPSHOT_ERROR), 0, 0);\n            }\n            (, uint collateralFactorMantissa) = ComptrollerInterface(comptroller).markets(address(asset));\n            vars.collateralFactor = Exp({ mantissa: collateralFactorMantissa });\n            vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(address(asset));\n            if (vars.oraclePriceMantissa == 0) {\n                return (uint(Error.PRICE_ERROR), 0, 0);\n            }\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n            // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * vTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n\n            // Calculate effects of interacting with vTokenModify\n            if (asset == vTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.tokensToDenom,\n                    redeemTokens,\n                    vars.sumBorrowPlusEffects\n                );\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.oraclePrice,\n                    borrowAmount,\n                    vars.sumBorrowPlusEffects\n                );\n            }\n        }\n\n        VAIControllerInterface vaiController = ComptrollerInterface(comptroller).vaiController();\n\n        if (address(vaiController) != address(0)) {\n            vars.sumBorrowPlusEffects = add_(vars.sumBorrowPlusEffects, vaiController.getVAIRepayAmount(account));\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (uint(Error.NO_ERROR), vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (uint(Error.NO_ERROR), 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n}\n"
    },
    "contracts/Lens/SnapshotLens.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { ExponentialNoError } from \"../Utils/ExponentialNoError.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { VBep20 } from \"../Tokens/VTokens/VBep20.sol\";\n\ncontract SnapshotLens is ExponentialNoError {\n    struct AccountSnapshot {\n        address account;\n        string assetName;\n        address vTokenAddress;\n        address underlyingAssetAddress;\n        uint256 supply;\n        uint256 supplyInUsd;\n        uint256 collateral;\n        uint256 borrows;\n        uint256 borrowsInUsd;\n        uint256 assetPrice;\n        uint256 accruedInterest;\n        uint vTokenDecimals;\n        uint underlyingDecimals;\n        uint exchangeRate;\n        bool isACollateral;\n    }\n\n    /** Snapshot calculation **/\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account snapshot.\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountSnapshotLocalVars {\n        uint collateral;\n        uint vTokenBalance;\n        uint borrowBalance;\n        uint borrowsInUsd;\n        uint balanceOfUnderlying;\n        uint supplyInUsd;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n        bool isACollateral;\n    }\n\n    function getAccountSnapshot(\n        address payable account,\n        address comptrollerAddress\n    ) public returns (AccountSnapshot[] memory) {\n        // For each asset the account is in\n        VToken[] memory assets = ComptrollerInterface(comptrollerAddress).getAllMarkets();\n        AccountSnapshot[] memory accountSnapshots = new AccountSnapshot[](assets.length);\n        for (uint256 i = 0; i < assets.length; ++i) {\n            accountSnapshots[i] = getAccountSnapshot(account, comptrollerAddress, assets[i]);\n        }\n        return accountSnapshots;\n    }\n\n    function isACollateral(address account, address asset, address comptrollerAddress) public view returns (bool) {\n        VToken[] memory assetsAsCollateral = ComptrollerInterface(comptrollerAddress).getAssetsIn(account);\n        for (uint256 j = 0; j < assetsAsCollateral.length; ++j) {\n            if (address(assetsAsCollateral[j]) == asset) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function getAccountSnapshot(\n        address payable account,\n        address comptrollerAddress,\n        VToken vToken\n    ) public returns (AccountSnapshot memory) {\n        AccountSnapshotLocalVars memory vars; // Holds all our calculation results\n        uint oErr;\n\n        // Read the balances and exchange rate from the vToken\n        (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = vToken.getAccountSnapshot(account);\n        require(oErr == 0, \"Snapshot Error\");\n        vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n        (, uint collateralFactorMantissa) = ComptrollerInterface(comptrollerAddress).markets(address(vToken));\n        vars.collateralFactor = Exp({ mantissa: collateralFactorMantissa });\n\n        // Get the normalized price of the asset\n        vars.oraclePriceMantissa = ComptrollerInterface(comptrollerAddress).oracle().getUnderlyingPrice(\n            address(vToken)\n        );\n        vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n        // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\n        vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n        //Collateral = tokensToDenom * vTokenBalance\n        vars.collateral = mul_ScalarTruncate(vars.tokensToDenom, vars.vTokenBalance);\n\n        vars.balanceOfUnderlying = vToken.balanceOfUnderlying(account);\n        vars.supplyInUsd = mul_ScalarTruncate(vars.oraclePrice, vars.balanceOfUnderlying);\n\n        vars.borrowsInUsd = mul_ScalarTruncate(vars.oraclePrice, vars.borrowBalance);\n\n        address underlyingAssetAddress;\n        uint underlyingDecimals;\n\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\n            underlyingAssetAddress = address(0);\n            underlyingDecimals = 18;\n        } else {\n            VBep20 vBep20 = VBep20(address(vToken));\n            underlyingAssetAddress = vBep20.underlying();\n            underlyingDecimals = IERC20Metadata(vBep20.underlying()).decimals();\n        }\n\n        vars.isACollateral = isACollateral(account, address(vToken), comptrollerAddress);\n\n        return\n            AccountSnapshot({\n                account: account,\n                assetName: vToken.name(),\n                vTokenAddress: address(vToken),\n                underlyingAssetAddress: underlyingAssetAddress,\n                supply: vars.balanceOfUnderlying,\n                supplyInUsd: vars.supplyInUsd,\n                collateral: vars.collateral,\n                borrows: vars.borrowBalance,\n                borrowsInUsd: vars.borrowsInUsd,\n                assetPrice: vars.oraclePriceMantissa,\n                accruedInterest: vToken.borrowIndex(),\n                vTokenDecimals: vToken.decimals(),\n                underlyingDecimals: underlyingDecimals,\n                exchangeRate: vToken.exchangeRateCurrent(),\n                isACollateral: vars.isACollateral\n            });\n    }\n\n    // utilities\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/Lens/VenusLens.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { ExponentialNoError } from \"../Utils/ExponentialNoError.sol\";\nimport { VBep20 } from \"../Tokens/VTokens/VBep20.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { ComptrollerInterface, Action } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { IXVS } from \"../Tokens/XVS/IXVS.sol\";\n\ncontract VenusLens is ExponentialNoError {\n    /// @notice Blocks Per Day\n    uint public constant BLOCKS_PER_DAY = 28800;\n\n    /// @notice Total actions available on VToken\n    uint public constant VTOKEN_ACTIONS = 8;\n\n    struct VenusMarketState {\n        uint224 index;\n        uint32 block;\n    }\n\n    struct VTokenMetadata {\n        address vToken;\n        uint exchangeRateCurrent;\n        uint supplyRatePerBlock;\n        uint borrowRatePerBlock;\n        uint reserveFactorMantissa;\n        uint totalBorrows;\n        uint totalReserves;\n        uint totalSupply;\n        uint totalCash;\n        bool isListed;\n        uint collateralFactorMantissa;\n        address underlyingAssetAddress;\n        uint vTokenDecimals;\n        uint underlyingDecimals;\n        uint venusSupplySpeed;\n        uint venusBorrowSpeed;\n        uint dailySupplyXvs;\n        uint dailyBorrowXvs;\n        uint pausedActions;\n    }\n\n    struct VTokenBalances {\n        address vToken;\n        uint balanceOf;\n        uint borrowBalanceCurrent;\n        uint balanceOfUnderlying;\n        uint tokenBalance;\n        uint tokenAllowance;\n    }\n\n    struct VTokenUnderlyingPrice {\n        address vToken;\n        uint underlyingPrice;\n    }\n\n    struct AccountLimits {\n        VToken[] markets;\n        uint liquidity;\n        uint shortfall;\n    }\n\n    struct XVSBalanceMetadata {\n        uint balance;\n        uint votes;\n        address delegate;\n    }\n\n    struct XVSBalanceMetadataExt {\n        uint balance;\n        uint votes;\n        address delegate;\n        uint allocated;\n    }\n\n    struct VenusVotes {\n        uint blockNumber;\n        uint votes;\n    }\n\n    struct ClaimVenusLocalVariables {\n        uint totalRewards;\n        uint224 borrowIndex;\n        uint32 borrowBlock;\n        uint224 supplyIndex;\n        uint32 supplyBlock;\n    }\n\n    /**\n     * @dev Struct for Pending Rewards for per market\n     */\n    struct PendingReward {\n        address vTokenAddress;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Struct for Reward of a single reward token.\n     */\n    struct RewardSummary {\n        address distributorAddress;\n        address rewardTokenAddress;\n        uint256 totalRewards;\n        PendingReward[] pendingRewards;\n    }\n\n    /**\n     * @notice Query the metadata of a vToken by its address\n     * @param vToken The address of the vToken to fetch VTokenMetadata\n     * @return VTokenMetadata struct with vToken supply and borrow information.\n     */\n    function vTokenMetadata(VToken vToken) public returns (VTokenMetadata memory) {\n        uint exchangeRateCurrent = vToken.exchangeRateCurrent();\n        address comptrollerAddress = address(vToken.comptroller());\n        ComptrollerInterface comptroller = ComptrollerInterface(comptrollerAddress);\n        (bool isListed, uint collateralFactorMantissa) = comptroller.markets(address(vToken));\n        address underlyingAssetAddress;\n        uint underlyingDecimals;\n\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\n            underlyingAssetAddress = address(0);\n            underlyingDecimals = 18;\n        } else {\n            VBep20 vBep20 = VBep20(address(vToken));\n            underlyingAssetAddress = vBep20.underlying();\n            underlyingDecimals = IERC20Metadata(vBep20.underlying()).decimals();\n        }\n\n        uint venusSupplySpeedPerBlock = comptroller.venusSupplySpeeds(address(vToken));\n        uint venusBorrowSpeedPerBlock = comptroller.venusBorrowSpeeds(address(vToken));\n\n        uint256 pausedActions;\n\n        for (uint8 i; i <= VTOKEN_ACTIONS; ++i) {\n            uint256 paused = comptroller.actionPaused(address(vToken), Action(i)) ? 1 : 0;\n            pausedActions |= paused << i;\n        }\n\n        return\n            VTokenMetadata({\n                vToken: address(vToken),\n                exchangeRateCurrent: exchangeRateCurrent,\n                supplyRatePerBlock: vToken.supplyRatePerBlock(),\n                borrowRatePerBlock: vToken.borrowRatePerBlock(),\n                reserveFactorMantissa: vToken.reserveFactorMantissa(),\n                totalBorrows: vToken.totalBorrows(),\n                totalReserves: vToken.totalReserves(),\n                totalSupply: vToken.totalSupply(),\n                totalCash: vToken.getCash(),\n                isListed: isListed,\n                collateralFactorMantissa: collateralFactorMantissa,\n                underlyingAssetAddress: underlyingAssetAddress,\n                vTokenDecimals: vToken.decimals(),\n                underlyingDecimals: underlyingDecimals,\n                venusSupplySpeed: venusSupplySpeedPerBlock,\n                venusBorrowSpeed: venusBorrowSpeedPerBlock,\n                dailySupplyXvs: venusSupplySpeedPerBlock * BLOCKS_PER_DAY,\n                dailyBorrowXvs: venusBorrowSpeedPerBlock * BLOCKS_PER_DAY,\n                pausedActions: pausedActions\n            });\n    }\n\n    /**\n     * @notice Get VTokenMetadata for an array of vToken addresses\n     * @param vTokens Array of vToken addresses to fetch VTokenMetadata\n     * @return Array of structs with vToken supply and borrow information.\n     */\n    function vTokenMetadataAll(VToken[] calldata vTokens) external returns (VTokenMetadata[] memory) {\n        uint vTokenCount = vTokens.length;\n        VTokenMetadata[] memory res = new VTokenMetadata[](vTokenCount);\n        for (uint i = 0; i < vTokenCount; i++) {\n            res[i] = vTokenMetadata(vTokens[i]);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Get amount of XVS distributed daily to an account\n     * @param account Address of account to fetch the daily XVS distribution\n     * @param comptrollerAddress Address of the comptroller proxy\n     * @return Amount of XVS distributed daily to an account\n     */\n    function getDailyXVS(address payable account, address comptrollerAddress) external returns (uint) {\n        ComptrollerInterface comptrollerInstance = ComptrollerInterface(comptrollerAddress);\n        VToken[] memory vTokens = comptrollerInstance.getAllMarkets();\n        uint dailyXvsPerAccount = 0;\n\n        for (uint i = 0; i < vTokens.length; i++) {\n            VToken vToken = vTokens[i];\n            if (!compareStrings(vToken.symbol(), \"vUST\") && !compareStrings(vToken.symbol(), \"vLUNA\")) {\n                VTokenMetadata memory metaDataItem = vTokenMetadata(vToken);\n\n                //get balanceOfUnderlying and borrowBalanceCurrent from vTokenBalance\n                VTokenBalances memory vTokenBalanceInfo = vTokenBalances(vToken, account);\n\n                VTokenUnderlyingPrice memory underlyingPriceResponse = vTokenUnderlyingPrice(vToken);\n                uint underlyingPrice = underlyingPriceResponse.underlyingPrice;\n                Exp memory underlyingPriceMantissa = Exp({ mantissa: underlyingPrice });\n\n                //get dailyXvsSupplyMarket\n                uint dailyXvsSupplyMarket = 0;\n                uint supplyInUsd = mul_ScalarTruncate(underlyingPriceMantissa, vTokenBalanceInfo.balanceOfUnderlying);\n                uint marketTotalSupply = (metaDataItem.totalSupply * metaDataItem.exchangeRateCurrent) / 1e18;\n                uint marketTotalSupplyInUsd = mul_ScalarTruncate(underlyingPriceMantissa, marketTotalSupply);\n\n                if (marketTotalSupplyInUsd > 0) {\n                    dailyXvsSupplyMarket = (metaDataItem.dailySupplyXvs * supplyInUsd) / marketTotalSupplyInUsd;\n                }\n\n                //get dailyXvsBorrowMarket\n                uint dailyXvsBorrowMarket = 0;\n                uint borrowsInUsd = mul_ScalarTruncate(underlyingPriceMantissa, vTokenBalanceInfo.borrowBalanceCurrent);\n                uint marketTotalBorrowsInUsd = mul_ScalarTruncate(underlyingPriceMantissa, metaDataItem.totalBorrows);\n\n                if (marketTotalBorrowsInUsd > 0) {\n                    dailyXvsBorrowMarket = (metaDataItem.dailyBorrowXvs * borrowsInUsd) / marketTotalBorrowsInUsd;\n                }\n\n                dailyXvsPerAccount += dailyXvsSupplyMarket + dailyXvsBorrowMarket;\n            }\n        }\n\n        return dailyXvsPerAccount;\n    }\n\n    /**\n     * @notice Get the current vToken balance (outstanding borrows) for an account\n     * @param vToken Address of the token to check the balance of\n     * @param account Account address to fetch the balance of\n     * @return VTokenBalances with token balance information\n     */\n    function vTokenBalances(VToken vToken, address payable account) public returns (VTokenBalances memory) {\n        uint balanceOf = vToken.balanceOf(account);\n        uint borrowBalanceCurrent = vToken.borrowBalanceCurrent(account);\n        uint balanceOfUnderlying = vToken.balanceOfUnderlying(account);\n        uint tokenBalance;\n        uint tokenAllowance;\n\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\n            tokenBalance = account.balance;\n            tokenAllowance = account.balance;\n        } else {\n            VBep20 vBep20 = VBep20(address(vToken));\n            IERC20Metadata underlying = IERC20Metadata(vBep20.underlying());\n            tokenBalance = underlying.balanceOf(account);\n            tokenAllowance = underlying.allowance(account, address(vToken));\n        }\n\n        return\n            VTokenBalances({\n                vToken: address(vToken),\n                balanceOf: balanceOf,\n                borrowBalanceCurrent: borrowBalanceCurrent,\n                balanceOfUnderlying: balanceOfUnderlying,\n                tokenBalance: tokenBalance,\n                tokenAllowance: tokenAllowance\n            });\n    }\n\n    /**\n     * @notice Get the current vToken balances (outstanding borrows) for all vTokens on an account\n     * @param vTokens Addresses of the tokens to check the balance of\n     * @param account Account address to fetch the balance of\n     * @return VTokenBalances Array with token balance information\n     */\n    function vTokenBalancesAll(\n        VToken[] calldata vTokens,\n        address payable account\n    ) external returns (VTokenBalances[] memory) {\n        uint vTokenCount = vTokens.length;\n        VTokenBalances[] memory res = new VTokenBalances[](vTokenCount);\n        for (uint i = 0; i < vTokenCount; i++) {\n            res[i] = vTokenBalances(vTokens[i], account);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Get the price for the underlying asset of a vToken\n     * @param vToken address of the vToken\n     * @return response struct with underlyingPrice info of vToken\n     */\n    function vTokenUnderlyingPrice(VToken vToken) public view returns (VTokenUnderlyingPrice memory) {\n        ComptrollerInterface comptroller = ComptrollerInterface(address(vToken.comptroller()));\n        ResilientOracleInterface priceOracle = comptroller.oracle();\n\n        return\n            VTokenUnderlyingPrice({\n                vToken: address(vToken),\n                underlyingPrice: priceOracle.getUnderlyingPrice(address(vToken))\n            });\n    }\n\n    /**\n     * @notice Query the underlyingPrice of an array of vTokens\n     * @param vTokens Array of vToken addresses\n     * @return array of response structs with underlying price information of vTokens\n     */\n    function vTokenUnderlyingPriceAll(\n        VToken[] calldata vTokens\n    ) external view returns (VTokenUnderlyingPrice[] memory) {\n        uint vTokenCount = vTokens.length;\n        VTokenUnderlyingPrice[] memory res = new VTokenUnderlyingPrice[](vTokenCount);\n        for (uint i = 0; i < vTokenCount; i++) {\n            res[i] = vTokenUnderlyingPrice(vTokens[i]);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Query the account liquidity and shortfall of an account\n     * @param comptroller Address of comptroller proxy\n     * @param account Address of the account to query\n     * @return Struct with markets user has entered, liquidity, and shortfall of the account\n     */\n    function getAccountLimits(\n        ComptrollerInterface comptroller,\n        address account\n    ) public view returns (AccountLimits memory) {\n        (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\n        require(errorCode == 0, \"account liquidity error\");\n\n        return AccountLimits({ markets: comptroller.getAssetsIn(account), liquidity: liquidity, shortfall: shortfall });\n    }\n\n    /**\n     * @notice Query the XVSBalance info of an account\n     * @param xvs XVS contract address\n     * @param account Account address\n     * @return Struct with XVS balance and voter details\n     */\n    function getXVSBalanceMetadata(IXVS xvs, address account) external view returns (XVSBalanceMetadata memory) {\n        return\n            XVSBalanceMetadata({\n                balance: xvs.balanceOf(account),\n                votes: uint256(xvs.getCurrentVotes(account)),\n                delegate: xvs.delegates(account)\n            });\n    }\n\n    /**\n     * @notice Query the XVSBalance extended info of an account\n     * @param xvs XVS contract address\n     * @param comptroller Comptroller proxy contract address\n     * @param account Account address\n     * @return Struct with XVS balance and voter details and XVS allocation\n     */\n    function getXVSBalanceMetadataExt(\n        IXVS xvs,\n        ComptrollerInterface comptroller,\n        address account\n    ) external returns (XVSBalanceMetadataExt memory) {\n        uint balance = xvs.balanceOf(account);\n        comptroller.claimVenus(account);\n        uint newBalance = xvs.balanceOf(account);\n        uint accrued = comptroller.venusAccrued(account);\n        uint total = add_(accrued, newBalance, \"sum xvs total\");\n        uint allocated = sub_(total, balance, \"sub allocated\");\n\n        return\n            XVSBalanceMetadataExt({\n                balance: balance,\n                votes: uint256(xvs.getCurrentVotes(account)),\n                delegate: xvs.delegates(account),\n                allocated: allocated\n            });\n    }\n\n    /**\n     * @notice Query the voting power for an account at a specific list of block numbers\n     * @param xvs XVS contract address\n     * @param account Address of the account\n     * @param blockNumbers Array of blocks to query\n     * @return Array of VenusVotes structs with block number and vote count\n     */\n    function getVenusVotes(\n        IXVS xvs,\n        address account,\n        uint32[] calldata blockNumbers\n    ) external view returns (VenusVotes[] memory) {\n        VenusVotes[] memory res = new VenusVotes[](blockNumbers.length);\n        for (uint i = 0; i < blockNumbers.length; i++) {\n            res[i] = VenusVotes({\n                blockNumber: uint256(blockNumbers[i]),\n                votes: uint256(xvs.getPriorVotes(account, blockNumbers[i]))\n            });\n        }\n        return res;\n    }\n\n    /**\n     * @dev Queries the current supply to calculate rewards for an account\n     * @param supplyState VenusMarketState struct\n     * @param vToken Address of a vToken\n     * @param comptroller Address of the comptroller proxy\n     */\n    function updateVenusSupplyIndex(\n        VenusMarketState memory supplyState,\n        address vToken,\n        ComptrollerInterface comptroller\n    ) internal view {\n        uint supplySpeed = comptroller.venusSupplySpeeds(vToken);\n        uint blockNumber = block.number;\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint supplyTokens = VToken(vToken).totalSupply();\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({ mantissa: 0 });\n            Double memory index = add_(Double({ mantissa: supplyState.index }), ratio);\n            supplyState.index = safe224(index.mantissa, \"new index overflows\");\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\n        } else if (deltaBlocks > 0) {\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\n        }\n    }\n\n    /**\n     * @dev Queries the current borrow to calculate rewards for an account\n     * @param borrowState VenusMarketState struct\n     * @param vToken Address of a vToken\n     * @param comptroller Address of the comptroller proxy\n     */\n    function updateVenusBorrowIndex(\n        VenusMarketState memory borrowState,\n        address vToken,\n        Exp memory marketBorrowIndex,\n        ComptrollerInterface comptroller\n    ) internal view {\n        uint borrowSpeed = comptroller.venusBorrowSpeeds(vToken);\n        uint blockNumber = block.number;\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({ mantissa: 0 });\n            Double memory index = add_(Double({ mantissa: borrowState.index }), ratio);\n            borrowState.index = safe224(index.mantissa, \"new index overflows\");\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\n        } else if (deltaBlocks > 0) {\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\n        }\n    }\n\n    /**\n     * @dev Calculate available rewards for an account's supply\n     * @param supplyState VenusMarketState struct\n     * @param vToken Address of a vToken\n     * @param supplier Address of the account supplying\n     * @param comptroller Address of the comptroller proxy\n     * @return Undistributed earned XVS from supplies\n     */\n    function distributeSupplierVenus(\n        VenusMarketState memory supplyState,\n        address vToken,\n        address supplier,\n        ComptrollerInterface comptroller\n    ) internal view returns (uint) {\n        Double memory supplyIndex = Double({ mantissa: supplyState.index });\n        Double memory supplierIndex = Double({ mantissa: comptroller.venusSupplierIndex(vToken, supplier) });\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            supplierIndex.mantissa = comptroller.venusInitialIndex();\n        }\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n        return supplierDelta;\n    }\n\n    /**\n     * @dev Calculate available rewards for an account's borrows\n     * @param borrowState VenusMarketState struct\n     * @param vToken Address of a vToken\n     * @param borrower Address of the account borrowing\n     * @param marketBorrowIndex vToken Borrow index\n     * @param comptroller Address of the comptroller proxy\n     * @return Undistributed earned XVS from borrows\n     */\n    function distributeBorrowerVenus(\n        VenusMarketState memory borrowState,\n        address vToken,\n        address borrower,\n        Exp memory marketBorrowIndex,\n        ComptrollerInterface comptroller\n    ) internal view returns (uint) {\n        Double memory borrowIndex = Double({ mantissa: borrowState.index });\n        Double memory borrowerIndex = Double({ mantissa: comptroller.venusBorrowerIndex(vToken, borrower) });\n        if (borrowerIndex.mantissa > 0) {\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n            return borrowerDelta;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Calculate the total XVS tokens pending and accrued by a user account\n     * @param holder Account to query pending XVS\n     * @param comptroller Address of the comptroller\n     * @return Reward object contraining the totalRewards and pending rewards for each market\n     */\n    function pendingRewards(\n        address holder,\n        ComptrollerInterface comptroller\n    ) external view returns (RewardSummary memory) {\n        VToken[] memory vTokens = comptroller.getAllMarkets();\n        ClaimVenusLocalVariables memory vars;\n        RewardSummary memory rewardSummary;\n        rewardSummary.distributorAddress = address(comptroller);\n        rewardSummary.rewardTokenAddress = comptroller.getXVSAddress();\n        rewardSummary.totalRewards = comptroller.venusAccrued(holder);\n        rewardSummary.pendingRewards = new PendingReward[](vTokens.length);\n        for (uint i; i < vTokens.length; ++i) {\n            (vars.borrowIndex, vars.borrowBlock) = comptroller.venusBorrowState(address(vTokens[i]));\n            VenusMarketState memory borrowState = VenusMarketState({\n                index: vars.borrowIndex,\n                block: vars.borrowBlock\n            });\n\n            (vars.supplyIndex, vars.supplyBlock) = comptroller.venusSupplyState(address(vTokens[i]));\n            VenusMarketState memory supplyState = VenusMarketState({\n                index: vars.supplyIndex,\n                block: vars.supplyBlock\n            });\n\n            Exp memory borrowIndex = Exp({ mantissa: vTokens[i].borrowIndex() });\n\n            PendingReward memory marketReward;\n            marketReward.vTokenAddress = address(vTokens[i]);\n\n            updateVenusBorrowIndex(borrowState, address(vTokens[i]), borrowIndex, comptroller);\n            uint256 borrowReward = distributeBorrowerVenus(\n                borrowState,\n                address(vTokens[i]),\n                holder,\n                borrowIndex,\n                comptroller\n            );\n\n            updateVenusSupplyIndex(supplyState, address(vTokens[i]), comptroller);\n            uint256 supplyReward = distributeSupplierVenus(supplyState, address(vTokens[i]), holder, comptroller);\n\n            marketReward.amount = add_(borrowReward, supplyReward);\n            rewardSummary.pendingRewards[i] = marketReward;\n        }\n        return rewardSummary;\n    }\n\n    // utilities\n    /**\n     * @notice Compares if two strings are equal\n     * @param a First string to compare\n     * @param b Second string to compare\n     * @return Boolean depending on if the strings are equal\n     */\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/lib/approveOrRevert.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @notice Thrown if a contract is unable to approve a transfer\nerror ApproveFailed();\n\n/// @notice Approves a transfer, ensuring that it is successful. This function supports non-compliant\n/// tokens like the ones that don't return a boolean value on success. Thus, such approve call supports\n/// three different kinds of tokens:\n///   * Compliant tokens that revert on failure\n///   * Compliant tokens that return false on failure\n///   * Non-compliant tokens that don't return a value\n/// @param token The contract address of the token which will be transferred\n/// @param spender The spender contract address\n/// @param amount The value of the transfer\nfunction approveOrRevert(IERC20Upgradeable token, address spender, uint256 amount) {\n    bytes memory callData = abi.encodeCall(token.approve, (spender, amount));\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory result) = address(token).call(callData);\n\n    if (!success || (result.length != 0 && !abi.decode(result, (bool)))) {\n        revert ApproveFailed();\n    }\n}\n"
    },
    "contracts/lib/Currency.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n// This library is heavily inspired by Uniswap v4 Currency lib\n// (https://github.com/Uniswap/v4-core/blob/b230769238879e1d4f58ffa57a4696b0c390d188/src/types/Currency.sol)\n// Contrary to the implementation above, this library does not\n// use assembly to save gas. It rather relies on OpenZeppelin's\n// SafeERC20 to simplify the review and audits. This might change\n// in future if it's more heavily used by Venus contracts.\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ntype Currency is address;\n\nlibrary CurrencyLibrary {\n    using CurrencyLibrary for Currency;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    Currency public constant NATIVE = Currency.wrap(0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB);\n\n    /**\n     * @dev If currency is a token, invokes SafeERC20.forceApprove to allow spender\n     *   to spend the amount of tokens on behalf of the current contract. Otherwise,\n     *   does nothing.\n     * @param currency Currency\n     * @param spender The account approved to spend the tokens\n     * @param amount The approved amount\n     */\n    function approve(Currency currency, address spender, uint256 amount) internal {\n        if (!currency.isNative()) {\n            // I'd rather use approveOrRevert instead of forceApprove\n            // once we migrate to OZ v5: force-approve does approve(0)\n            // before approving the amount, and it's not always\n            // desirable. The users will need to pay gas unnecessarily,\n            // and using just approve() is safe as long as we revert on\n            // errors (approveOrRevert handles that) and reset the approvals\n            // after transfers (which is a best practice recommended by\n            // auditors anyway).\n            SafeERC20.forceApprove(IERC20(Currency.unwrap(currency)), spender, amount);\n        }\n    }\n\n    /**\n     * @dev Transfers an amount of currency to the receiver. If currency is a token,\n     *   uses SafeERC20.safeTransfer, otherwise transfers the native currency using\n     *   the recommended approach (`receiver.call{value: amount}(\"\")`).\n     * @param currency Currency\n     * @param receiver The account that would receive the tokens\n     * @param amount The amount to transfer\n     */\n    function transfer(Currency currency, address receiver, uint256 amount) internal {\n        if (currency.isNative()) {\n            (bool success, ) = receiver.call{ value: amount }(\"\");\n            if (!success) {\n                revert NativeTransferFailed();\n            }\n        } else {\n            SafeERC20.safeTransfer(IERC20(Currency.unwrap(currency)), receiver, amount);\n        }\n    }\n\n    function transferAll(Currency currency, address receiver) internal {\n        uint256 balance = currency.balanceOfSelf();\n        if (balance > 0) {\n            currency.transfer(receiver, balance);\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return address(this).balance;\n        }\n        return IERC20(Currency.unwrap(currency)).balanceOf(address(this));\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\n    }\n}\n"
    },
    "contracts/Liquidator/BUSDLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { MANTISSA_ONE } from \"@venusprotocol/solidity-utilities/contracts/constants.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\n\nimport { approveOrRevert } from \"../lib/approveOrRevert.sol\";\nimport { ILiquidator, IComptroller, IVToken, IVBep20, IVBNB, IVAIController } from \"../InterfacesV8.sol\";\n\n/**\n * @title BUSDLiquidator\n * @author Venus\n * @notice A custom contract for force-liquidating BUSD debts\n */\ncontract BUSDLiquidator is Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IVToken;\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IVBep20 public immutable vBUSD;\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IComptroller public immutable comptroller;\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable treasury;\n\n    /// @notice The liquidator's share, scaled by 1e18 (e.g. 1.02 * 1e18 for 102% of the debt covered)\n    uint256 public liquidatorShareMantissa;\n\n    /// @notice Thrown if trying to set liquidator's share lower than 100% of the debt covered\n    error LiquidatorShareTooLow(uint256 liquidatorShareMantissa_);\n\n    /// @notice Thrown if trying to set liquidator's share larger than this contract can receive from a liquidation\n    error LiquidatorShareTooHigh(uint256 maxLiquidatorShareMantissa, uint256 liquidatorShareMantissa_);\n\n    /// @notice Emitted when the liquidator's share is set\n    event NewLiquidatorShare(uint256 oldLiquidatorShareMantissa, uint256 newLiquidatorShareMantissa);\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @param comptroller_ The address of the Comptroller contract\n    /// @param vBUSD_ The address of the VBNB\n    /// @param treasury_ The address of Venus treasury\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address comptroller_, address vBUSD_, address treasury_) {\n        ensureNonzeroAddress(vBUSD_);\n        ensureNonzeroAddress(comptroller_);\n        ensureNonzeroAddress(treasury_);\n        vBUSD = IVBep20(vBUSD_);\n        comptroller = IComptroller(comptroller_);\n        treasury = treasury_;\n        _disableInitializers();\n    }\n\n    /// @notice Initializer for the implementation contract.\n    /// @param liquidatorShareMantissa_ Liquidator's share, scaled by 1e18 (e.g. 1.01 * 1e18 for 101%)\n    /// @custom:error LiquidatorShareTooHigh is thrown if trying to set liquidator percent larger than the liquidation profit\n    function initialize(uint256 liquidatorShareMantissa_) external virtual initializer {\n        __Ownable2Step_init();\n        __ReentrancyGuard_init();\n        _validateLiquidatorShareMantissa(liquidatorShareMantissa_);\n        liquidatorShareMantissa = liquidatorShareMantissa_;\n    }\n\n    /// @notice Liquidate the entire BUSD debt of a borrower, seizing vTokenCollateral\n    /// @param borrower The borrower whose debt should be liquidated\n    /// @param vTokenCollateral The collateral to seize from the borrower\n    function liquidateEntireBorrow(address borrower, IVToken vTokenCollateral) external nonReentrant {\n        uint256 repayAmount = vBUSD.borrowBalanceCurrent(borrower);\n        _unpauseAndLiquidate(borrower, repayAmount, vTokenCollateral);\n    }\n\n    /// @notice Liquidate a BUSD borrow, repaying the repayAmount of BUSD\n    /// @param borrower The borrower whose debt should be liquidated\n    /// @param repayAmount The amount to repay\n    /// @param vTokenCollateral The collateral to seize from the borrower\n    function liquidateBorrow(address borrower, uint256 repayAmount, IVToken vTokenCollateral) external nonReentrant {\n        _unpauseAndLiquidate(borrower, repayAmount, vTokenCollateral);\n    }\n\n    /// @notice Allows Governance to set the liquidator's share\n    /// @param liquidatorShareMantissa_ Liquidator's share, scaled by 1e18 (e.g. 1.01 * 1e18 for 101%)\n    /// @custom:access Only Governance\n    function setLiquidatorShare(uint256 liquidatorShareMantissa_) external onlyOwner {\n        _validateLiquidatorShareMantissa(liquidatorShareMantissa_);\n        uint256 oldLiquidatorShareMantissa = liquidatorShareMantissa;\n        liquidatorShareMantissa = liquidatorShareMantissa_;\n        emit NewLiquidatorShare(oldLiquidatorShareMantissa, liquidatorShareMantissa_);\n    }\n\n    /// @notice Allows to recover token accidentally sent to this contract by sending the entire balance to Governance\n    /// @param token The address of the token to recover\n    /// @custom:access Only Governance\n    function sweepToken(IERC20Upgradeable token) external onlyOwner {\n        token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /// @dev Unpauses the liquidation on the BUSD market, liquidates the borrower's debt,\n    /// and pauses the liquidations back\n    /// @param borrower The borrower whose debt should be liquidated\n    /// @param repayAmount The amount to repay\n    /// @param vTokenCollateral The collateral to seize from the borrower\n    function _unpauseAndLiquidate(address borrower, uint256 repayAmount, IVToken vTokenCollateral) internal {\n        address[] memory vTokens = new address[](1);\n        vTokens[0] = address(vBUSD);\n        IComptroller.Action[] memory actions = new IComptroller.Action[](1);\n        actions[0] = IComptroller.Action.LIQUIDATE;\n\n        comptroller._setActionsPaused(vTokens, actions, false);\n        _liquidateBorrow(borrower, repayAmount, vTokenCollateral);\n        comptroller._setActionsPaused(vTokens, actions, true);\n    }\n\n    /// @dev Performs the actual liquidation, transferring BUSD from the sender to this contract,\n    /// repaying the debt, and transferring the seized collateral to the sender and the treasury\n    /// @param borrower The borrower whose debt should be liquidated\n    /// @param repayAmount The amount to repay\n    /// @param vTokenCollateral The collateral to seize from the borrower\n    function _liquidateBorrow(address borrower, uint256 repayAmount, IVToken vTokenCollateral) internal {\n        ILiquidator liquidatorContract = ILiquidator(comptroller.liquidatorContract());\n        IERC20Upgradeable busd = IERC20Upgradeable(vBUSD.underlying());\n\n        uint256 actualRepayAmount = _transferIn(busd, msg.sender, repayAmount);\n        approveOrRevert(busd, address(liquidatorContract), actualRepayAmount);\n        uint256 balanceBefore = vTokenCollateral.balanceOf(address(this));\n        liquidatorContract.liquidateBorrow(address(vBUSD), borrower, actualRepayAmount, vTokenCollateral);\n        uint256 receivedAmount = vTokenCollateral.balanceOf(address(this)) - balanceBefore;\n        approveOrRevert(busd, address(liquidatorContract), 0);\n\n        (uint256 liquidatorAmount, uint256 treasuryAmount) = _computeShares(receivedAmount);\n        vTokenCollateral.safeTransfer(msg.sender, liquidatorAmount);\n        vTokenCollateral.safeTransfer(treasury, treasuryAmount);\n    }\n\n    /// @dev Transfers tokens to this contract and returns the actual transfer amount\n    /// @param token The token to transfer\n    /// @param from The account to transfer from\n    /// @param amount The amount to transfer\n    /// @return The actual amount transferred\n    function _transferIn(IERC20Upgradeable token, address from, uint256 amount) internal returns (uint256) {\n        uint256 prevBalance = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        return token.balanceOf(address(this)) - prevBalance;\n    }\n\n    /// @dev Computes the liquidator's and treasury's shares of the received amount\n    /// @param receivedAmount The amount received from the liquidation\n    /// @return liquidatorAmount The liquidator's share\n    /// @return treasuryAmount The treasury's share\n    function _computeShares(\n        uint256 receivedAmount\n    ) internal view returns (uint256 liquidatorAmount, uint256 treasuryAmount) {\n        uint256 denominator = _getDenominator();\n        liquidatorAmount = (receivedAmount * liquidatorShareMantissa) / denominator;\n        treasuryAmount = receivedAmount - liquidatorAmount;\n    }\n\n    /// @dev Returns (liquidation incentive - treasury percent), the value used as the denominator\n    /// when calculating the liquidator's share\n    /// @return The denominator for the seized amount used when calculating the liquidator's share\n    function _getDenominator() internal view returns (uint256) {\n        uint256 totalPercentageToDistribute = comptroller.liquidationIncentiveMantissa();\n        uint256 regularTreasuryPercent = ILiquidator(comptroller.liquidatorContract()).treasuryPercentMantissa();\n        uint256 denominator = totalPercentageToDistribute - regularTreasuryPercent;\n        return denominator;\n    }\n\n    /// @dev Checks if the liquidator's share is more than 100% of the debt covered and less\n    /// than (liquidation incentive - treasury percent)\n    /// @param liquidatorShareMantissa_ Liquidator's share, scaled by 1e18 (e.g. 1.01 * 1e18 for 101%)\n    function _validateLiquidatorShareMantissa(uint256 liquidatorShareMantissa_) internal view {\n        uint256 maxLiquidatorShareMantissa = _getDenominator();\n        if (liquidatorShareMantissa_ < MANTISSA_ONE) {\n            revert LiquidatorShareTooLow(liquidatorShareMantissa_);\n        }\n\n        if (liquidatorShareMantissa_ > maxLiquidatorShareMantissa) {\n            revert LiquidatorShareTooHigh(maxLiquidatorShareMantissa, liquidatorShareMantissa_);\n        }\n    }\n}\n"
    },
    "contracts/Liquidator/Liquidator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { IProtocolShareReserve } from \"../external/IProtocolShareReserve.sol\";\nimport { IWBNB } from \"../external/IWBNB.sol\";\nimport { LiquidatorStorage } from \"./LiquidatorStorage.sol\";\nimport { IComptroller, IVToken, IVBep20, IVBNB, IVAIController } from \"../InterfacesV8.sol\";\n\ncontract Liquidator is Ownable2StepUpgradeable, ReentrancyGuardUpgradeable, LiquidatorStorage, AccessControlledV8 {\n    /// @notice Address of vBNB contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IVBNB public immutable vBnb;\n\n    /// @notice Address of Venus Unitroller contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IComptroller public immutable comptroller;\n\n    /// @notice Address of VAIUnitroller contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IVAIController public immutable vaiController;\n\n    /// @notice Address of wBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable wBNB;\n\n    /// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\n    uint256 internal constant MANTISSA_ONE = 1e18;\n\n    /* Events */\n\n    /// @notice Emitted when the percent of the seized amount that goes to treasury changes.\n    event NewLiquidationTreasuryPercent(uint256 oldPercent, uint256 newPercent);\n\n    /// @notice Emitted when a borrow is liquidated\n    event LiquidateBorrowedTokens(\n        address indexed liquidator,\n        address indexed borrower,\n        uint256 repayAmount,\n        address vTokenBorrowed,\n        address indexed vTokenCollateral,\n        uint256 seizeTokensForTreasury,\n        uint256 seizeTokensForLiquidator\n    );\n\n    /// @notice Emitted when the liquidation is restricted for a borrower\n    event LiquidationRestricted(address indexed borrower);\n\n    /// @notice Emitted when the liquidation restrictions are removed for a borrower\n    event LiquidationRestrictionsDisabled(address indexed borrower);\n\n    /// @notice Emitted when a liquidator is added to the allowedLiquidatorsByAccount mapping\n    event AllowlistEntryAdded(address indexed borrower, address indexed liquidator);\n\n    /// @notice Emitted when a liquidator is removed from the allowedLiquidatorsByAccount mapping\n    event AllowlistEntryRemoved(address indexed borrower, address indexed liquidator);\n\n    /// @notice Emitted when the amount of minLiquidatableVAI is updated\n    event NewMinLiquidatableVAI(uint256 oldMinLiquidatableVAI, uint256 newMinLiquidatableVAI);\n\n    /// @notice Emitted when the length of chunk gets updated\n    event NewPendingRedeemChunkLength(uint256 oldPendingRedeemChunkLength, uint256 newPendingRedeemChunkLength);\n\n    /// @notice Emitted when force liquidation is paused\n    event ForceVAILiquidationPaused(address indexed sender);\n\n    /// @notice Emitted when force liquidation is resumed\n    event ForceVAILiquidationResumed(address indexed sender);\n\n    /// @notice Emitted when new address of protocol share reserve is set\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserves);\n\n    /// @notice Emitted when reserves are reduced from liquidator contract to protocol share reserves\n    event ProtocolLiquidationIncentiveTransferred(address indexed sender, address indexed token, uint256 reducedAmount);\n\n    /* Errors */\n\n    /// @notice Thrown if the liquidation is restricted and the liquidator is not in the allowedLiquidatorsByAccount mapping\n    error LiquidationNotAllowed(address borrower, address liquidator);\n\n    /// @notice Thrown if VToken transfer fails after the liquidation\n    error VTokenTransferFailed(address from, address to, uint256 amount);\n\n    /// @notice Thrown if the liquidation is not successful (the error code is from TokenErrorReporter)\n    error LiquidationFailed(uint256 errorCode);\n\n    /// @notice Thrown if trying to restrict liquidations for an already restricted borrower\n    error AlreadyRestricted(address borrower);\n\n    /// @notice Thrown if trying to unrestrict liquidations for a borrower that is not restricted\n    error NoRestrictionsExist(address borrower);\n\n    /// @notice Thrown if the liquidator is already in the allowedLiquidatorsByAccount mapping\n    error AlreadyAllowed(address borrower, address liquidator);\n\n    /// @notice Thrown if trying to remove a liquidator that is not in the allowedLiquidatorsByAccount mapping\n    error AllowlistEntryNotFound(address borrower, address liquidator);\n\n    /// @notice Thrown if BNB amount sent with the transaction doesn't correspond to the\n    ///         intended BNB repayment\n    error WrongTransactionAmount(uint256 expected, uint256 actual);\n\n    /// @notice Thrown if trying to set treasury percent larger than the liquidation profit\n    error TreasuryPercentTooHigh(uint256 maxTreasuryPercentMantissa, uint256 treasuryPercentMantissa_);\n\n    /// @notice Thrown if trying to liquidate any token when VAI debt is too high\n    error VAIDebtTooHigh(uint256 vaiDebt, uint256 minLiquidatableVAI);\n\n    /// @notice Thrown when vToken is not listed\n    error MarketNotListed(address vToken);\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @param comptroller_ The address of the Comptroller contract\n    /// @param vBnb_ The address of the VBNB\n    /// @param wBNB_ The address of wBNB\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address comptroller_, address payable vBnb_, address wBNB_) {\n        ensureNonzeroAddress(vBnb_);\n        ensureNonzeroAddress(comptroller_);\n        ensureNonzeroAddress(wBNB_);\n        vBnb = IVBNB(vBnb_);\n        wBNB = wBNB_;\n        comptroller = IComptroller(comptroller_);\n        vaiController = IVAIController(IComptroller(comptroller_).vaiController());\n        _disableInitializers();\n    }\n\n    receive() external payable {}\n\n    /// @notice Initializer for the implementation contract.\n    /// @param treasuryPercentMantissa_ Treasury share, scaled by 1e18 (e.g. 0.2 * 1e18 for 20%)\n    /// @param accessControlManager_ address of access control manager\n    /// @param protocolShareReserve_ The address of the protocol share reserve contract\n    function initialize(\n        uint256 treasuryPercentMantissa_,\n        address accessControlManager_,\n        address protocolShareReserve_\n    ) external virtual reinitializer(2) {\n        __Liquidator_init(treasuryPercentMantissa_, accessControlManager_, protocolShareReserve_);\n    }\n\n    /// @dev Liquidator initializer for derived contracts.\n    /// @param treasuryPercentMantissa_ Treasury share, scaled by 1e18 (e.g. 0.2 * 1e18 for 20%)\n    /// @param accessControlManager_ address of access control manager\n    /// @param protocolShareReserve_ The address of the protocol share reserve contract\n    function __Liquidator_init(\n        uint256 treasuryPercentMantissa_,\n        address accessControlManager_,\n        address protocolShareReserve_\n    ) internal onlyInitializing {\n        __Ownable2Step_init();\n        __ReentrancyGuard_init();\n        __Liquidator_init_unchained(treasuryPercentMantissa_, protocolShareReserve_);\n        __AccessControlled_init_unchained(accessControlManager_);\n    }\n\n    /// @dev Liquidator initializer for derived contracts that doesn't call parent initializers.\n    /// @param treasuryPercentMantissa_ Treasury share, scaled by 1e18 (e.g. 0.2 * 1e18 for 20%)\n    /// @param protocolShareReserve_ The address of the protocol share reserve contract\n    function __Liquidator_init_unchained(\n        uint256 treasuryPercentMantissa_,\n        address protocolShareReserve_\n    ) internal onlyInitializing {\n        validateTreasuryPercentMantissa(treasuryPercentMantissa_);\n        treasuryPercentMantissa = treasuryPercentMantissa_;\n        _setProtocolShareReserve(protocolShareReserve_);\n    }\n\n    /// @notice An admin function to restrict liquidations to allowed addresses only.\n    /// @dev Use {addTo,removeFrom}AllowList to configure the allowed addresses.\n    /// @param borrower The address of the borrower\n    function restrictLiquidation(address borrower) external {\n        _checkAccessAllowed(\"restrictLiquidation(address)\");\n        if (liquidationRestricted[borrower]) {\n            revert AlreadyRestricted(borrower);\n        }\n        liquidationRestricted[borrower] = true;\n        emit LiquidationRestricted(borrower);\n    }\n\n    /// @notice An admin function to remove restrictions for liquidations.\n    /// @dev Does not impact the allowedLiquidatorsByAccount mapping for the borrower, just turns off the check.\n    /// @param borrower The address of the borrower\n    function unrestrictLiquidation(address borrower) external {\n        _checkAccessAllowed(\"unrestrictLiquidation(address)\");\n        if (!liquidationRestricted[borrower]) {\n            revert NoRestrictionsExist(borrower);\n        }\n        liquidationRestricted[borrower] = false;\n        emit LiquidationRestrictionsDisabled(borrower);\n    }\n\n    /// @notice An admin function to add the liquidator to the allowedLiquidatorsByAccount mapping for a certain\n    ///         borrower. If the liquidations are restricted, only liquidators from the\n    ///         allowedLiquidatorsByAccount mapping can participate in liquidating the positions of this borrower.\n    /// @param borrower The address of the borrower\n    /// @param borrower The address of the liquidator\n    function addToAllowlist(address borrower, address liquidator) external {\n        _checkAccessAllowed(\"addToAllowlist(address,address)\");\n        if (allowedLiquidatorsByAccount[borrower][liquidator]) {\n            revert AlreadyAllowed(borrower, liquidator);\n        }\n        allowedLiquidatorsByAccount[borrower][liquidator] = true;\n        emit AllowlistEntryAdded(borrower, liquidator);\n    }\n\n    /// @notice An admin function to remove the liquidator from the allowedLiquidatorsByAccount mapping of a certain\n    ///         borrower. If the liquidations are restricted, this liquidator will not be\n    ///         able to liquidate the positions of this borrower.\n    /// @param borrower The address of the borrower\n    /// @param borrower The address of the liquidator\n    function removeFromAllowlist(address borrower, address liquidator) external {\n        _checkAccessAllowed(\"removeFromAllowlist(address,address)\");\n        if (!allowedLiquidatorsByAccount[borrower][liquidator]) {\n            revert AllowlistEntryNotFound(borrower, liquidator);\n        }\n        allowedLiquidatorsByAccount[borrower][liquidator] = false;\n        emit AllowlistEntryRemoved(borrower, liquidator);\n    }\n\n    /// @notice Liquidates a borrow and splits the seized amount between protocol share reserve and\n    ///         liquidator. The liquidators should use this interface instead of calling\n    ///         vToken.liquidateBorrow(...) directly.\n    /// @notice Checks force VAI liquidation first; vToken should be address of vaiController if vaiDebt is greater than threshold\n    /// @notice For BNB borrows msg.value should be equal to repayAmount; otherwise msg.value\n    ///      should be zero.\n    /// @param vToken Borrowed vToken\n    /// @param borrower The address of the borrower\n    /// @param repayAmount The amount to repay on behalf of the borrower\n    /// @param vTokenCollateral The collateral to seize\n    function liquidateBorrow(\n        address vToken,\n        address borrower,\n        uint256 repayAmount,\n        IVToken vTokenCollateral\n    ) external payable nonReentrant {\n        ensureNonzeroAddress(borrower);\n        checkRestrictions(borrower, msg.sender);\n        (bool isListed, , ) = IComptroller(comptroller).markets(address(vTokenCollateral));\n        if (!isListed) {\n            revert MarketNotListed(address(vTokenCollateral));\n        }\n\n        _checkForceVAILiquidate(vToken, borrower);\n        uint256 ourBalanceBefore = vTokenCollateral.balanceOf(address(this));\n        if (vToken == address(vBnb)) {\n            if (repayAmount != msg.value) {\n                revert WrongTransactionAmount(repayAmount, msg.value);\n            }\n            vBnb.liquidateBorrow{ value: msg.value }(borrower, vTokenCollateral);\n        } else {\n            if (msg.value != 0) {\n                revert WrongTransactionAmount(0, msg.value);\n            }\n            if (vToken == address(vaiController)) {\n                _liquidateVAI(borrower, repayAmount, vTokenCollateral);\n            } else {\n                _liquidateBep20(IVBep20(vToken), borrower, repayAmount, vTokenCollateral);\n            }\n        }\n        uint256 ourBalanceAfter = vTokenCollateral.balanceOf(address(this));\n        uint256 seizedAmount = ourBalanceAfter - ourBalanceBefore;\n        (uint256 ours, uint256 theirs) = _distributeLiquidationIncentive(vTokenCollateral, seizedAmount);\n        _reduceReservesInternal();\n        emit LiquidateBorrowedTokens(\n            msg.sender,\n            borrower,\n            repayAmount,\n            vToken,\n            address(vTokenCollateral),\n            ours,\n            theirs\n        );\n    }\n\n    /// @notice Sets the new percent of the seized amount that goes to treasury. Should\n    ///         be less than or equal to comptroller.liquidationIncentiveMantissa().sub(1e18).\n    /// @param newTreasuryPercentMantissa New treasury percent (scaled by 10^18).\n    function setTreasuryPercent(uint256 newTreasuryPercentMantissa) external {\n        _checkAccessAllowed(\"setTreasuryPercent(uint256)\");\n        validateTreasuryPercentMantissa(newTreasuryPercentMantissa);\n        emit NewLiquidationTreasuryPercent(treasuryPercentMantissa, newTreasuryPercentMantissa);\n        treasuryPercentMantissa = newTreasuryPercentMantissa;\n    }\n\n    /**\n     * @notice Sets protocol share reserve contract address\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\n     */\n    function setProtocolShareReserve(address payable protocolShareReserve_) external onlyOwner {\n        _setProtocolShareReserve(protocolShareReserve_);\n    }\n\n    /**\n     * @notice Reduce the reserves of the pending accumulated reserves\n     */\n    function reduceReserves() external nonReentrant {\n        _reduceReservesInternal();\n    }\n\n    function _reduceReservesInternal() internal {\n        uint256 _pendingRedeemLength = pendingRedeem.length;\n        uint256 range = _pendingRedeemLength >= pendingRedeemChunkLength\n            ? pendingRedeemChunkLength\n            : _pendingRedeemLength;\n        for (uint256 index = range; index > 0; ) {\n            address vToken = pendingRedeem[index - 1];\n            uint256 vTokenBalance_ = IVToken(vToken).balanceOf(address(this));\n            if (_redeemUnderlying(vToken, vTokenBalance_)) {\n                if (vToken == address(vBnb)) {\n                    _reduceBnbReserves();\n                } else {\n                    _reduceVTokenReserves(vToken);\n                }\n                pendingRedeem[index - 1] = pendingRedeem[pendingRedeem.length - 1];\n                pendingRedeem.pop();\n            }\n            unchecked {\n                index--;\n            }\n        }\n    }\n\n    /// @dev Transfers BEP20 tokens to self, then approves vToken to take these tokens.\n    function _liquidateBep20(IVBep20 vToken, address borrower, uint256 repayAmount, IVToken vTokenCollateral) internal {\n        (bool isListed, , ) = IComptroller(comptroller).markets(address(vToken));\n        if (!isListed) {\n            revert MarketNotListed(address(vToken));\n        }\n\n        IERC20Upgradeable borrowedToken = IERC20Upgradeable(vToken.underlying());\n        uint256 actualRepayAmount = _transferBep20(borrowedToken, msg.sender, address(this), repayAmount);\n        borrowedToken.safeApprove(address(vToken), 0);\n        borrowedToken.safeApprove(address(vToken), actualRepayAmount);\n        requireNoError(vToken.liquidateBorrow(borrower, actualRepayAmount, vTokenCollateral));\n    }\n\n    /// @dev Transfers BEP20 tokens to self, then approves VAI to take these tokens.\n    function _liquidateVAI(address borrower, uint256 repayAmount, IVToken vTokenCollateral) internal {\n        IERC20Upgradeable vai = IERC20Upgradeable(vaiController.getVAIAddress());\n        vai.safeTransferFrom(msg.sender, address(this), repayAmount);\n        vai.safeApprove(address(vaiController), 0);\n        vai.safeApprove(address(vaiController), repayAmount);\n\n        (uint256 err, ) = vaiController.liquidateVAI(borrower, repayAmount, vTokenCollateral);\n        requireNoError(err);\n    }\n\n    /// @dev Distribute seized collateral between liquidator and protocol share reserve\n    function _distributeLiquidationIncentive(\n        IVToken vTokenCollateral,\n        uint256 seizedAmount\n    ) internal returns (uint256 ours, uint256 theirs) {\n        (ours, theirs) = _splitLiquidationIncentive(seizedAmount);\n        if (!vTokenCollateral.transfer(msg.sender, theirs)) {\n            revert VTokenTransferFailed(address(this), msg.sender, theirs);\n        }\n\n        if (ours > 0 && !_redeemUnderlying(address(vTokenCollateral), ours)) {\n            // Check if asset is already present in pendingRedeem array\n            uint256 index;\n            for (index; index < pendingRedeem.length; ) {\n                if (pendingRedeem[index] == address(vTokenCollateral)) {\n                    break;\n                }\n                unchecked {\n                    index++;\n                }\n            }\n            if (index == pendingRedeem.length) {\n                pendingRedeem.push(address(vTokenCollateral));\n            }\n        } else {\n            if (address(vTokenCollateral) == address(vBnb)) {\n                _reduceBnbReserves();\n            } else {\n                _reduceVTokenReserves(address(vTokenCollateral));\n            }\n        }\n    }\n\n    /// @dev Wraps BNB to wBNB and sends to protocol share reserve\n    function _reduceBnbReserves() private {\n        uint256 bnbBalance = address(this).balance;\n        IWBNB(wBNB).deposit{ value: bnbBalance }();\n        IERC20Upgradeable(wBNB).safeTransfer(protocolShareReserve, bnbBalance);\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\n            address(comptroller),\n            wBNB,\n            IProtocolShareReserve.IncomeType.LIQUIDATION\n        );\n        emit ProtocolLiquidationIncentiveTransferred(msg.sender, wBNB, bnbBalance);\n    }\n\n    /// @dev Redeem seized collateral to underlying assets\n    function _redeemUnderlying(address vToken, uint256 amount) private returns (bool) {\n        try IVToken(address(vToken)).redeem(amount) returns (uint256 response) {\n            if (response == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch {\n            return false;\n        }\n    }\n\n    /// @dev Transfers seized collateral other than BNB to protocol share reserve\n    function _reduceVTokenReserves(address vToken) private {\n        address underlying = IVBep20(vToken).underlying();\n        uint256 underlyingBalance = IERC20Upgradeable(underlying).balanceOf(address(this));\n        IERC20Upgradeable(underlying).safeTransfer(protocolShareReserve, underlyingBalance);\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\n            address(comptroller),\n            underlying,\n            IProtocolShareReserve.IncomeType.LIQUIDATION\n        );\n        emit ProtocolLiquidationIncentiveTransferred(msg.sender, underlying, underlyingBalance);\n    }\n\n    /// @dev Transfers tokens and returns the actual transfer amount\n    function _transferBep20(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 prevBalance = token.balanceOf(to);\n        token.safeTransferFrom(from, to, amount);\n        return token.balanceOf(to) - prevBalance;\n    }\n\n    /// @dev Computes the amounts that would go to treasury and to the liquidator.\n    function _splitLiquidationIncentive(uint256 seizedAmount) internal view returns (uint256 ours, uint256 theirs) {\n        uint256 totalIncentive = comptroller.liquidationIncentiveMantissa();\n        ours = (seizedAmount * treasuryPercentMantissa) / totalIncentive;\n        theirs = seizedAmount - ours;\n    }\n\n    function requireNoError(uint256 errCode) internal pure {\n        if (errCode == uint256(0)) {\n            return;\n        }\n\n        revert LiquidationFailed(errCode);\n    }\n\n    function checkRestrictions(address borrower, address liquidator) internal view {\n        if (liquidationRestricted[borrower] && !allowedLiquidatorsByAccount[borrower][liquidator]) {\n            revert LiquidationNotAllowed(borrower, liquidator);\n        }\n    }\n\n    function validateTreasuryPercentMantissa(uint256 treasuryPercentMantissa_) internal view {\n        uint256 maxTreasuryPercentMantissa = comptroller.liquidationIncentiveMantissa() - MANTISSA_ONE;\n        if (treasuryPercentMantissa_ > maxTreasuryPercentMantissa) {\n            revert TreasuryPercentTooHigh(maxTreasuryPercentMantissa, treasuryPercentMantissa_);\n        }\n    }\n\n    /// @dev Checks liquidation action in comptroller and vaiDebt with minLiquidatableVAI threshold\n    function _checkForceVAILiquidate(address vToken_, address borrower_) private view {\n        uint256 _vaiDebt = vaiController.getVAIRepayAmount(borrower_);\n        bool _isVAILiquidationPaused = comptroller.actionPaused(address(vaiController), IComptroller.Action.LIQUIDATE);\n        bool _isForcedLiquidationEnabled = comptroller.isForcedLiquidationEnabled(vToken_);\n        if (\n            _isForcedLiquidationEnabled ||\n            _isVAILiquidationPaused ||\n            !forceVAILiquidate ||\n            _vaiDebt < minLiquidatableVAI ||\n            vToken_ == address(vaiController)\n        ) return;\n        revert VAIDebtTooHigh(_vaiDebt, minLiquidatableVAI);\n    }\n\n    function _setProtocolShareReserve(address protocolShareReserve_) internal {\n        ensureNonzeroAddress(protocolShareReserve_);\n        emit NewProtocolShareReserve(protocolShareReserve, protocolShareReserve_);\n        protocolShareReserve = protocolShareReserve_;\n    }\n\n    /**\n     * @notice Sets the threshold for minimum amount of vaiLiquidate\n     * @param minLiquidatableVAI_ New address for the access control\n     */\n    function setMinLiquidatableVAI(uint256 minLiquidatableVAI_) external {\n        _checkAccessAllowed(\"setMinLiquidatableVAI(uint256)\");\n        emit NewMinLiquidatableVAI(minLiquidatableVAI, minLiquidatableVAI_);\n        minLiquidatableVAI = minLiquidatableVAI_;\n    }\n\n    /**\n     * @notice Length of the pendingRedeem array to be consider while redeeming in Liquidation transaction\n     * @param newLength_ Length of the chunk\n     */\n    function setPendingRedeemChunkLength(uint256 newLength_) external {\n        _checkAccessAllowed(\"setPendingRedeemChunkLength(uint256)\");\n        require(newLength_ > 0, \"Invalid chunk size\");\n        emit NewPendingRedeemChunkLength(pendingRedeemChunkLength, newLength_);\n        pendingRedeemChunkLength = newLength_;\n    }\n\n    /**\n     * @notice Pause Force Liquidation of VAI\n     */\n    function pauseForceVAILiquidate() external {\n        _checkAccessAllowed(\"pauseForceVAILiquidate()\");\n        require(forceVAILiquidate, \"Force Liquidation of VAI is already Paused\");\n        forceVAILiquidate = false;\n        emit ForceVAILiquidationPaused(msg.sender);\n    }\n\n    /**\n     * @notice Resume Force Liquidation of VAI\n     */\n    function resumeForceVAILiquidate() external {\n        _checkAccessAllowed(\"resumeForceVAILiquidate()\");\n        require(!forceVAILiquidate, \"Force Liquidation of VAI is already resumed\");\n        forceVAILiquidate = true;\n        emit ForceVAILiquidationResumed(msg.sender);\n    }\n\n    function renounceOwnership() public override {}\n}\n"
    },
    "contracts/Liquidator/LiquidatorStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\ncontract LiquidatorStorage {\n    /* State */\n\n    /// @notice Percent of seized amount that goes to treasury.\n    uint256 public treasuryPercentMantissa;\n\n    /// @notice Mapping of addresses allowed to liquidate an account if liquidationRestricted[borrower] == true\n    mapping(address => mapping(address => bool)) public allowedLiquidatorsByAccount;\n\n    /// @notice Whether the liquidations are restricted to enabled allowedLiquidatorsByAccount addresses only\n    mapping(address => bool) public liquidationRestricted;\n\n    /// @notice minimum amount of VAI liquidation threshold\n    uint256 public minLiquidatableVAI;\n\n    /// @notice check for liquidation of VAI\n    bool public forceVAILiquidate;\n\n    /// @notice assests whose redeem is pending to reduce reserves\n    address[] public pendingRedeem;\n\n    /// @notice protocol share reserve contract address\n    address public protocolShareReserve;\n\n    /// @dev Size of chunk to consider when redeeming underlying at the time of liquidation\n    uint256 internal pendingRedeemChunkLength;\n\n    /// @notice gap to prevent collision in inheritance\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/PegStability/IVAI.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\ninterface IVAI {\n    function balanceOf(address usr) external returns (uint256);\n\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n\n    function mint(address usr, uint wad) external;\n\n    function burn(address usr, uint wad) external;\n}\n"
    },
    "contracts/PegStability/PegStability.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { IVAI } from \"./IVAI.sol\";\n\n/**\n * @title Peg Stability Contract.\n * @notice Contract for swapping stable token for VAI token and vice versa to maintain the peg stability between them.\n * @author Venus Protocol\n */\ncontract PegStability is AccessControlledV8, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Helper enum for calculation of the fee.\n    enum FeeDirection {\n        IN,\n        OUT\n    }\n\n    /// @notice The divisor used to convert fees to basis points.\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n\n    /// @notice The mantissa value representing 1 (used for calculations).\n    uint256 public constant MANTISSA_ONE = 1e18;\n\n    /// @notice The value representing one dollar in the stable token.\n    /// @dev Our oracle is returning amount depending on the number of decimals of the stable token. (36 - asset_decimals) E.g. 8 decimal asset = 1e28.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable ONE_DOLLAR;\n\n    /// @notice VAI token contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IVAI public immutable VAI;\n\n    /// @notice The address of the stable token contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable STABLE_TOKEN_ADDRESS;\n\n    /// @notice The address of ResilientOracle contract wrapped in its interface.\n    ResilientOracleInterface public oracle;\n\n    /// @notice The address of the Venus Treasury contract.\n    address public venusTreasury;\n\n    /// @notice The incoming stableCoin fee. (Fee for swapStableForVAI).\n    uint256 public feeIn;\n\n    /// @notice The outgoing stableCoin fee. (Fee for swapVAIForStable).\n    uint256 public feeOut;\n\n    /// @notice The maximum amount of VAI that can be minted through this contract.\n    uint256 public vaiMintCap;\n\n    /// @notice The total amount of VAI minted through this contract.\n    uint256 public vaiMinted;\n\n    /// @notice A flag indicating whether the contract is currently paused or not.\n    bool public isPaused;\n\n    /// @notice Event emitted when contract is paused.\n    event PSMPaused(address indexed admin);\n\n    /// @notice Event emitted when the contract is resumed after pause.\n    event PSMResumed(address indexed admin);\n\n    /// @notice Event emitted when feeIn state var is modified.\n    event FeeInChanged(uint256 oldFeeIn, uint256 newFeeIn);\n\n    /// @notice Event emitted when feeOut state var is modified.\n    event FeeOutChanged(uint256 oldFeeOut, uint256 newFeeOut);\n\n    /// @notice Event emitted when vaiMintCap state var is modified.\n    event VAIMintCapChanged(uint256 oldCap, uint256 newCap);\n\n    /// @notice Event emitted when venusTreasury state var is modified.\n    event VenusTreasuryChanged(address indexed oldTreasury, address indexed newTreasury);\n\n    /// @notice Event emitted when oracle state var is modified.\n    event OracleChanged(address indexed oldOracle, address indexed newOracle);\n\n    /// @notice Event emitted when stable token is swapped for VAI.\n    event StableForVAISwapped(uint256 stableIn, uint256 vaiOut, uint256 fee);\n\n    /// @notice Event emitted when stable token is swapped for VAI.\n    event VAIForStableSwapped(uint256 vaiBurnt, uint256 stableOut, uint256 vaiFee);\n\n    /// @notice thrown when contract is in paused state\n    error Paused();\n\n    /// @notice thrown when attempted to pause an already paused contract\n    error AlreadyPaused();\n\n    /// @notice thrown when attempted to resume the contract if it is already resumed\n    error NotPaused();\n\n    /// @notice thrown when stable token has more than 18 decimals\n    error TooManyDecimals();\n\n    /// @notice thrown when fee is >= 100%\n    error InvalidFee();\n\n    /// @notice thrown when a zero address is passed as a function parameter\n    error ZeroAddress();\n\n    /// @notice thrown when a zero amount is passed as stable token amount parameter\n    error ZeroAmount();\n\n    /// @notice thrown when the user doesn't have enough VAI balance to provide for the amount of stable tokens he wishes to get\n    error NotEnoughVAI();\n\n    /// @notice thrown when the amount of VAI to be burnt exceeds the vaiMinted amount\n    error VAIMintedUnderflow();\n\n    /// @notice thrown when the VAI transfer to treasury fails\n    error VAITransferFail();\n\n    /// @notice thrown when VAI to be minted will go beyond the mintCap threshold\n    error VAIMintCapReached();\n    /// @notice thrown when fee calculation will result in rounding down to 0 due to stable token amount being a too small number\n    error AmountTooSmall();\n\n    /**\n     * @dev Prevents functions to execute when contract is paused.\n     */\n    modifier isActive() {\n        if (isPaused) revert Paused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address stableTokenAddress_, address vaiAddress_) {\n        _ensureNonzeroAddress(stableTokenAddress_);\n        _ensureNonzeroAddress(vaiAddress_);\n\n        uint256 decimals_ = IERC20MetadataUpgradeable(stableTokenAddress_).decimals();\n\n        if (decimals_ > 18) {\n            revert TooManyDecimals();\n        }\n\n        ONE_DOLLAR = 10 ** (36 - decimals_); // 1$ scaled to the decimals returned by our Oracle\n        STABLE_TOKEN_ADDRESS = stableTokenAddress_;\n        VAI = IVAI(vaiAddress_);\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract via Proxy Contract with the required parameters.\n     * @param accessControlManager_ The address of the AccessControlManager contract.\n     * @param venusTreasury_ The address where fees will be sent.\n     * @param oracleAddress_ The address of the ResilientOracle contract.\n     * @param feeIn_ The percentage of fees to be applied to a stablecoin -> VAI swap.\n     * @param feeOut_ The percentage of fees to be applied to a VAI -> stablecoin swap.\n     * @param vaiMintCap_ The cap for the total amount of VAI that can be minted.\n     */\n    function initialize(\n        address accessControlManager_,\n        address venusTreasury_,\n        address oracleAddress_,\n        uint256 feeIn_,\n        uint256 feeOut_,\n        uint256 vaiMintCap_\n    ) external initializer {\n        _ensureNonzeroAddress(accessControlManager_);\n        _ensureNonzeroAddress(venusTreasury_);\n        _ensureNonzeroAddress(oracleAddress_);\n        __AccessControlled_init(accessControlManager_);\n        __ReentrancyGuard_init();\n\n        if (feeIn_ >= BASIS_POINTS_DIVISOR || feeOut_ >= BASIS_POINTS_DIVISOR) {\n            revert InvalidFee();\n        }\n\n        feeIn = feeIn_;\n        feeOut = feeOut_;\n        vaiMintCap = vaiMintCap_;\n        venusTreasury = venusTreasury_;\n        oracle = ResilientOracleInterface(oracleAddress_);\n    }\n\n    /*** Swap Functions ***/\n\n    /**\n     * @notice Swaps VAI for a stable token.\n     * @param receiver The address where the stablecoin will be sent.\n     * @param stableTknAmount The amount of stable tokens to receive.\n     * @return The amount of VAI received and burnt from the sender.\n     */\n    // @custom:event Emits VAIForStableSwapped event.\n    function swapVAIForStable(\n        address receiver,\n        uint256 stableTknAmount\n    ) external isActive nonReentrant returns (uint256) {\n        _ensureNonzeroAddress(receiver);\n        _ensureNonzeroAmount(stableTknAmount);\n\n        // update oracle price and calculate USD value of the stable token amount scaled in 18 decimals\n        oracle.updateAssetPrice(STABLE_TOKEN_ADDRESS);\n        uint256 stableTknAmountUSD = _previewTokenUSDAmount(stableTknAmount, FeeDirection.OUT);\n        uint256 fee = _calculateFee(stableTknAmountUSD, FeeDirection.OUT);\n\n        if (VAI.balanceOf(msg.sender) < stableTknAmountUSD + fee) {\n            revert NotEnoughVAI();\n        }\n        if (vaiMinted < stableTknAmountUSD) {\n            revert VAIMintedUnderflow();\n        }\n\n        unchecked {\n            vaiMinted -= stableTknAmountUSD;\n        }\n\n        if (fee != 0) {\n            bool success = VAI.transferFrom(msg.sender, venusTreasury, fee);\n            if (!success) {\n                revert VAITransferFail();\n            }\n        }\n\n        VAI.burn(msg.sender, stableTknAmountUSD);\n        IERC20Upgradeable(STABLE_TOKEN_ADDRESS).safeTransfer(receiver, stableTknAmount);\n        emit VAIForStableSwapped(stableTknAmountUSD, stableTknAmount, fee);\n        return stableTknAmountUSD;\n    }\n\n    /**\n     * @notice Swaps stable tokens for VAI with fees.\n     * @dev This function adds support to fee-on-transfer tokens. The actualTransferAmt is calculated, by recording token balance state before and after the transfer.\n     * @param receiver The address that will receive the VAI tokens.\n     * @param stableTknAmount The amount of stable tokens to be swapped.\n     * @return Amount of VAI minted to the sender.\n     */\n    // @custom:event Emits StableForVAISwapped event.\n    function swapStableForVAI(\n        address receiver,\n        uint256 stableTknAmount\n    ) external isActive nonReentrant returns (uint256) {\n        _ensureNonzeroAddress(receiver);\n        _ensureNonzeroAmount(stableTknAmount);\n        // transfer IN, supporting fee-on-transfer tokens\n        uint256 balanceBefore = IERC20Upgradeable(STABLE_TOKEN_ADDRESS).balanceOf(address(this));\n        IERC20Upgradeable(STABLE_TOKEN_ADDRESS).safeTransferFrom(msg.sender, address(this), stableTknAmount);\n        uint256 balanceAfter = IERC20Upgradeable(STABLE_TOKEN_ADDRESS).balanceOf(address(this));\n\n        //calculate actual transfered amount (in case of fee-on-transfer tokens)\n        uint256 actualTransferAmt = balanceAfter - balanceBefore;\n\n        // update oracle price and calculate USD value of the stable token amount scaled in 18 decimals\n        oracle.updateAssetPrice(STABLE_TOKEN_ADDRESS);\n        uint256 actualTransferAmtInUSD = _previewTokenUSDAmount(actualTransferAmt, FeeDirection.IN);\n\n        //calculate feeIn\n        uint256 fee = _calculateFee(actualTransferAmtInUSD, FeeDirection.IN);\n        uint256 vaiToMint = actualTransferAmtInUSD - fee;\n\n        if (vaiMinted + actualTransferAmtInUSD > vaiMintCap) {\n            revert VAIMintCapReached();\n        }\n        unchecked {\n            vaiMinted += actualTransferAmtInUSD;\n        }\n\n        // mint VAI to receiver\n        VAI.mint(receiver, vaiToMint);\n\n        // mint VAI fee to venus treasury\n        if (fee != 0) {\n            VAI.mint(venusTreasury, fee);\n        }\n\n        emit StableForVAISwapped(actualTransferAmt, vaiToMint, fee);\n        return vaiToMint;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Pause the PSM contract.\n     * @dev Reverts if the contract is already paused.\n     */\n    // @custom:event Emits PSMPaused event.\n    function pause() external {\n        _checkAccessAllowed(\"pause()\");\n        if (isPaused) {\n            revert AlreadyPaused();\n        }\n        isPaused = true;\n        emit PSMPaused(msg.sender);\n    }\n\n    /**\n     * @notice Resume the PSM contract.\n     * @dev Reverts if the contract is not paused.\n     */\n    // @custom:event Emits PSMResumed event.\n    function resume() external {\n        _checkAccessAllowed(\"resume()\");\n        if (!isPaused) {\n            revert NotPaused();\n        }\n        isPaused = false;\n        emit PSMResumed(msg.sender);\n    }\n\n    /**\n     * @notice Set the fee percentage for incoming swaps.\n     * @dev Reverts if the new fee percentage is invalid (greater than or equal to BASIS_POINTS_DIVISOR).\n     * @param feeIn_ The new fee percentage for incoming swaps.\n     */\n    // @custom:event Emits FeeInChanged event.\n    function setFeeIn(uint256 feeIn_) external {\n        _checkAccessAllowed(\"setFeeIn(uint256)\");\n        // feeIn = 10000 = 100%\n        if (feeIn_ >= BASIS_POINTS_DIVISOR) {\n            revert InvalidFee();\n        }\n        uint256 oldFeeIn = feeIn;\n        feeIn = feeIn_;\n        emit FeeInChanged(oldFeeIn, feeIn_);\n    }\n\n    /**\n     * @notice Set the fee percentage for outgoing swaps.\n     * @dev Reverts if the new fee percentage is invalid (greater than or equal to BASIS_POINTS_DIVISOR).\n     * @param feeOut_ The new fee percentage for outgoing swaps.\n     */\n    // @custom:event Emits FeeOutChanged event.\n    function setFeeOut(uint256 feeOut_) external {\n        _checkAccessAllowed(\"setFeeOut(uint256)\");\n        // feeOut = 10000 = 100%\n        if (feeOut_ >= BASIS_POINTS_DIVISOR) {\n            revert InvalidFee();\n        }\n        uint256 oldFeeOut = feeOut;\n        feeOut = feeOut_;\n        emit FeeOutChanged(oldFeeOut, feeOut_);\n    }\n\n    /**\n     * @dev Set the maximum amount of VAI that can be minted through this contract.\n     * @param vaiMintCap_ The new maximum amount of VAI that can be minted.\n     */\n    // @custom:event Emits VAIMintCapChanged event.\n    function setVAIMintCap(uint256 vaiMintCap_) external {\n        _checkAccessAllowed(\"setVAIMintCap(uint256)\");\n        uint256 oldVAIMintCap = vaiMintCap;\n        vaiMintCap = vaiMintCap_;\n        emit VAIMintCapChanged(oldVAIMintCap, vaiMintCap_);\n    }\n\n    /**\n     * @notice Set the address of the Venus Treasury contract.\n     * @dev Reverts if the new address is zero.\n     * @param venusTreasury_ The new address of the Venus Treasury contract.\n     */\n    // @custom:event Emits VenusTreasuryChanged event.\n    function setVenusTreasury(address venusTreasury_) external {\n        _checkAccessAllowed(\"setVenusTreasury(address)\");\n        _ensureNonzeroAddress(venusTreasury_);\n        address oldTreasuryAddress = venusTreasury;\n        venusTreasury = venusTreasury_;\n        emit VenusTreasuryChanged(oldTreasuryAddress, venusTreasury_);\n    }\n\n    /**\n     * @notice Set the address of the ResilientOracle contract.\n     * @dev Reverts if the new address is zero.\n     * @param oracleAddress_ The new address of the ResilientOracle contract.\n     */\n    // @custom:event Emits OracleChanged event.\n    function setOracle(address oracleAddress_) external {\n        _checkAccessAllowed(\"setOracle(address)\");\n        _ensureNonzeroAddress(oracleAddress_);\n        address oldOracleAddress = address(oracle);\n        oracle = ResilientOracleInterface(oracleAddress_);\n        emit OracleChanged(oldOracleAddress, oracleAddress_);\n    }\n\n    /**\n     * @dev Disabling renounceOwnership function.\n     */\n    function renounceOwnership() public override {}\n\n    /*** Helper Functions ***/\n\n    /**\n     * @notice Calculates the amount of VAI that would be burnt from the user.\n     * @dev This calculation might be off with a bit, if the price of the oracle for this asset is not updated in the block this function is invoked.\n     * @param stableTknAmount The amount of stable tokens to be received after the swap.\n     * @return The amount of VAI that would be taken from the user.\n     */\n    function previewSwapVAIForStable(uint256 stableTknAmount) external view returns (uint256) {\n        _ensureNonzeroAmount(stableTknAmount);\n        uint256 stableTknAmountUSD = _previewTokenUSDAmount(stableTknAmount, FeeDirection.OUT);\n        uint256 fee = _calculateFee(stableTknAmountUSD, FeeDirection.OUT);\n\n        if (vaiMinted < stableTknAmountUSD) {\n            revert VAIMintedUnderflow();\n        }\n\n        return stableTknAmountUSD + fee;\n    }\n\n    /**\n     * @notice Calculates the amount of VAI that would be sent to the receiver.\n     * @dev This calculation might be off with a bit, if the price of the oracle for this asset is not updated in the block this function is invoked.\n     * @param stableTknAmount The amount of stable tokens provided for the swap.\n     * @return The amount of VAI that would be sent to the receiver.\n     */\n    function previewSwapStableForVAI(uint256 stableTknAmount) external view returns (uint256) {\n        _ensureNonzeroAmount(stableTknAmount);\n        uint256 stableTknAmountUSD = _previewTokenUSDAmount(stableTknAmount, FeeDirection.IN);\n\n        //calculate feeIn\n        uint256 fee = _calculateFee(stableTknAmountUSD, FeeDirection.IN);\n        uint256 vaiToMint = stableTknAmountUSD - fee;\n\n        if (vaiMinted + stableTknAmountUSD > vaiMintCap) {\n            revert VAIMintCapReached();\n        }\n\n        return vaiToMint;\n    }\n\n    /**\n     * @dev Calculates the USD value of the given amount of stable tokens depending on the swap direction.\n     * @param amount The amount of stable tokens.\n     * @param direction The direction of the swap.\n     * @return The USD value of the given amount of stable tokens scaled by 1e18 taking into account the direction of the swap\n     */\n    function _previewTokenUSDAmount(uint256 amount, FeeDirection direction) internal view returns (uint256) {\n        return (amount * _getPriceInUSD(direction)) / MANTISSA_ONE;\n    }\n\n    /**\n     * @notice Get the price of stable token in USD.\n     * @dev This function returns either min(1$,oraclePrice) or max(1$,oraclePrice) with a decimal scale (36 - asset_decimals). E.g. for 8 decimal token 1$ will be 1e28.\n     * @param direction The direction of the swap: FeeDirection.IN or FeeDirection.OUT.\n     * @return The price in USD, adjusted based on the selected direction.\n     */\n    function _getPriceInUSD(FeeDirection direction) internal view returns (uint256) {\n        // get price with a scale = (36 - asset_decimals)\n        uint256 price = oracle.getPrice(STABLE_TOKEN_ADDRESS);\n\n        if (direction == FeeDirection.IN) {\n            // MIN(1, price)\n            return price < ONE_DOLLAR ? price : ONE_DOLLAR;\n        } else {\n            // MAX(1, price)\n            return price > ONE_DOLLAR ? price : ONE_DOLLAR;\n        }\n    }\n\n    /**\n     * @notice Calculate the fee amount based on the input amount and fee percentage.\n     * @dev Reverts if the fee percentage calculation results in rounding down to 0.\n     * @param amount The input amount to calculate the fee from.\n     * @param direction The direction of the fee: FeeDirection.IN or FeeDirection.OUT.\n     * @return The fee amount.\n     */\n    function _calculateFee(uint256 amount, FeeDirection direction) internal view returns (uint256) {\n        uint256 feePercent;\n        if (direction == FeeDirection.IN) {\n            feePercent = feeIn;\n        } else {\n            feePercent = feeOut;\n        }\n        if (feePercent == 0) {\n            return 0;\n        } else {\n            // checking if the percent calculation will result in rounding down to 0\n            if (amount * feePercent < BASIS_POINTS_DIVISOR) {\n                revert AmountTooSmall();\n            }\n            return (amount * feePercent) / BASIS_POINTS_DIVISOR;\n        }\n    }\n\n    /**\n     * @notice Checks that the address is not the zero address.\n     * @param someone The address to check.\n     */\n    function _ensureNonzeroAddress(address someone) private pure {\n        if (someone == address(0)) revert ZeroAddress();\n    }\n\n    /**\n     * @notice Checks that the amount passed as stable tokens is bigger than zero\n     * @param amount The amount to validate\n     */\n    function _ensureNonzeroAmount(uint256 amount) private pure {\n        if (amount == 0) revert ZeroAmount();\n    }\n}\n"
    },
    "contracts/Swap/interfaces/CustomErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\n// **************\n// *** ERRORS ***\n// **************\n\n///@notice Error indicating that suplying to a given market failed.\nerror SupplyError(address supplier, address vToken, uint256 errorCode);\n\n///@notice Error indicating that repaying to given market failed.\nerror RepayError(address repayer, address vToken, uint256 errorCode);\n\n///@notice Error indicating wBNB address passed is not the expected one.\nerror WrongAddress(address expectedAdddress, address passedAddress);\n\n///@notice Error thrown when deadline for swap has expired\nerror SwapDeadlineExpire(uint256 deadline, uint256 timestemp);\n\n///@notice Error thrown where the input amount parameter for a token is 0\nerror InsufficientInputAmount();\n\n///@notice Error thrown when the amount out passed is 0\nerror InsufficientOutputAmount();\n\n///@notice Error thrown when the amount received from a trade is below the minimum\nerror OutputAmountBelowMinimum(uint256 amountOut, uint256 amountOutMin);\n\n///@notice Error thrown when the amount In is above the amount in maximum\nerror InputAmountAboveMaximum(uint256 amountIn, uint256 amountIntMax);\n\n///@notice Error thrown when amount is above the msg.value(amountMax)\nerror ExcessiveInputAmount(uint256 amount, uint256 amountMax);\n\n///@notice Error thrown when the given reserves are equal to 0\nerror InsufficientLiquidity();\n\n///@notice Error thrown if a zero address is passed\nerror ZeroAddress();\n\n///@notice Error thrown if two token addresses are identical\nerror IdenticalAddresses();\n\n///@notice Error thrown when the trade path[] parameter consists of only 1 token (i.e. path.length<2)\nerror InvalidPath();\n\n///@notice Error thrown when invalid vToken address is passed to swap router\nerror VTokenNotListed(address vToken);\n\n///@notice Error thrown when invalid underlying is passed as per given vToken\nerror VTokenUnderlyingInvalid(address underlying);\n\n///@notice Error thrown when swapamount is less than the amountOutmin\nerror SwapAmountLessThanAmountOutMin(uint256 swapAmount, uint256 amountOutMin);\n\n///@notice Error thrown when swapRouter's balance is less than sweep amount\nerror InsufficientBalance(uint256 sweepAmount, uint256 balance);\n\n///@notice Error thrown when safeApprove failed\nerror SafeApproveFailed();\n\n///@notice Error thrown when safeTransfer failed\nerror SafeTransferFailed();\n\n///@notice Error thrown when transferFrom failed\nerror SafeTransferFromFailed();\n\n///@notice Error thrown when safeTransferBNB failed\nerror SafeTransferBNBFailed();\n\n///@notice Error thrown when reentrant check fails\nerror ReentrantCheck();\n"
    },
    "contracts/Swap/interfaces/InterfaceComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\ninterface InterfaceComptroller {\n    function markets(address) external view returns (bool);\n}\n"
    },
    "contracts/Swap/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint);\n\n    function price1CumulativeLast() external view returns (uint);\n\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/Swap/interfaces/IPancakeSwapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\ninterface IPancakeSwapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/Swap/interfaces/IPancakeSwapV2Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\ninterface IPancakeSwapV2Router {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 swapAmount);\n\n    function swapExactBNBForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactBNBForTokensAtSupportingFee(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 swapAmount);\n\n    function swapExactTokensForBNB(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForBNBAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 swapAmount);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapBNBForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactBNB(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapExactTokensForTokensAndSupplyAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapExactBNBForTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactBNBForTokensAndSupplyAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable;\n\n    function swapTokensForExactTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapBNBForExactTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOut,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForBNBAndSupply(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapExactTokensForBNBAndSupplyAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapTokensForExactBNBAndSupply(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapBNBForFullTokenDebtAndRepay(\n        address vTokenAddress,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapExactTokensForTokensAndRepayAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapExactBNBForTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactBNBForTokensAndRepayAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable;\n\n    function swapTokensForExactTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapTokensForFullTokenDebtAndRepay(\n        address vTokenAddress,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapBNBForExactTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOut,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForBNBAndRepay(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapExactTokensForBNBAndRepayAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapTokensForExactBNBAndRepay(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external;\n\n    function swapTokensForFullBNBDebtAndRepay(uint256 amountInMax, address[] calldata path, uint256 deadline) external;\n}\n"
    },
    "contracts/Swap/interfaces/IVBNB.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\ninterface IVBNB {\n    function repayBorrowBehalf(address borrower) external payable;\n\n    function mint() external payable;\n\n    function balanceOf(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/Swap/interfaces/IVtoken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\ninterface IVToken {\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint);\n\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\n\n    function borrowBalanceCurrent(address account) external returns (uint);\n\n    function underlying() external returns (address);\n}\n"
    },
    "contracts/Swap/interfaces/IWBNB.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\ninterface IWBNB {\n    function deposit() external payable;\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function withdraw(uint) external;\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n}\n"
    },
    "contracts/Swap/IRouterHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\ninterface IRouterHelper {\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/Swap/lib/PancakeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport \"../interfaces/IPancakePair.sol\";\nimport \"../interfaces/CustomErrors.sol\";\n\nlibrary PancakeLibrary {\n    /**\n     * @notice Used to handle return values from pairs sorted in this order\n     * @param tokenA The address of token A\n     * @param tokenB The address of token B\n     * @return token0 token1 Sorted token addresses\n     **/\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        if (tokenA == tokenB) {\n            revert IdenticalAddresses();\n        }\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        if (token0 == address(0)) {\n            revert ZeroAddress();\n        }\n    }\n\n    /**\n     * @notice Calculates the CREATE2 address for a pair without making any external calls\n     * @param factory Address of the pancake swap factory\n     * @param tokenA The address of token A\n     * @param tokenB The address of token B\n     * @return pair Address for a pair\n     **/\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Fetches and sorts the reserves for a pair\n     * @param factory Address of the pancake swap factory\n     * @param tokenA The address of token A\n     * @param tokenB The address of token B\n     * @return reserveA reserveB Reserves for the token A and token B\n     **/\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        address pairAddress = pairFor(factory, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IPancakePair(pairAddress).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    /**\n     * @notice Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     * @param amountA The amount of token A\n     * @param reserveA The amount of reserves for token A before swap\n     * @param reserveB The amount of reserves for token B before swap\n     * @return amountB An equivalent amount of the token B\n     **/\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {\n        if (amountA == 0) {\n            revert InsufficientInputAmount();\n        } else if (reserveA == 0 || reserveB == 0) {\n            revert InsufficientLiquidity();\n        }\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    /**\n     * @notice Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n     * @param amountIn The amount of token A need to swap\n     * @param reserveIn The amount of reserves for token A before swap\n     * @param reserveOut The amount of reserves for token B after swap\n     * @return amountOut The maximum output amount of the token B\n     **/\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        if (amountIn == 0) {\n            revert InsufficientInputAmount();\n        } else if (reserveIn == 0 || reserveOut == 0) {\n            revert InsufficientLiquidity();\n        }\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 10000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    /**\n     * @notice Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n     * @param amountOut The amount of token B after swap\n     * @param reserveIn The amount of reserves for token A before swap\n     * @param reserveOut The amount of reserves for token B after swap\n     * @return amountIn Required input amount of the token A\n     **/\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        if (amountOut == 0) {\n            revert InsufficientOutputAmount();\n        } else if (reserveIn == 0 || reserveOut == 0) {\n            revert InsufficientLiquidity();\n        }\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n\n    /**\n     * @notice Performs chained getAmountOut calculations on any number of pairs\n     * @param factory Address of the pancake swap factory\n     * @param amountIn The amount of tokens to swap.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @return amounts Array of amounts after performing swap for respective pairs in path\n     **/\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        if (path.length <= 1) {\n            revert InvalidPath();\n        }\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; ) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Performs chained getAmountIn calculations on any number of pairs\n     * @param factory Address of the pancake swap factory\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @return amounts Array of amounts after performing swap for respective pairs in path\n     **/\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        if (path.length <= 1) {\n            revert InvalidPath();\n        }\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; ) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n}\n"
    },
    "contracts/Swap/lib/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport \"../interfaces/CustomErrors.sol\";\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    /**\n     * @dev `value` as the allowance of `spender` over the caller's tokens.\n     * @param token Address of the token\n     * @param to Address of the spender\n     * @param value Amount as allowance\n     */\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) {\n            revert SafeApproveFailed();\n        }\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     * @param token Address of the token\n     * @param to Address of the receiver\n     * @param value Amount need to transfer\n     */\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     * @param token Address of the token\n     * @param from Address of the asset'sowner\n     * @param to Address of the receiver\n     * @param value Amount need to transfer\n     */\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) {\n            revert SafeTransferFromFailed();\n        }\n    }\n\n    /**\n     * @dev Transfer `value` amount of `BNB` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     * @param to Address of the receiver\n     * @param value Amount need to transfer\n     */\n    function safeTransferBNB(address to, uint256 value) internal {\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        if (!success) {\n            revert SafeTransferBNBFailed();\n        }\n    }\n}\n"
    },
    "contracts/Swap/RouterHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./lib/PancakeLibrary.sol\";\nimport \"./interfaces/IWBNB.sol\";\nimport \"./lib/TransferHelper.sol\";\n\nimport \"./interfaces/CustomErrors.sol\";\nimport \"./IRouterHelper.sol\";\n\nabstract contract RouterHelper is IRouterHelper {\n    /// @notice Select the type of Token for which either a supporting fee would be deducted or not at the time of transfer.\n    enum TypesOfTokens {\n        NON_SUPPORTING_FEE,\n        SUPPORTING_FEE\n    }\n\n    /// @notice Address of WBNB contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice Address of pancake swap factory contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable factory;\n\n    // **************\n    // *** EVENTS ***\n    // **************\n    /// @notice This event is emitted whenever a successful swap (tokenA -> tokenB) occurs\n    event SwapTokensForTokens(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (tokenA -> tokenB) occurs\n    event SwapTokensForTokensAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @notice This event is emitted whenever a successful swap (BNB -> token) occurs\n    event SwapBnbForTokens(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (BNB -> token) occurs\n    event SwapBnbForTokensAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @notice This event is emitted whenever a successful swap (token -> BNB) occurs\n    event SwapTokensForBnb(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (token -> BNB) occurs\n    event SwapTokensForBnbAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address WBNB_, address factory_) {\n        if (WBNB_ == address(0) || factory_ == address(0)) {\n            revert ZeroAddress();\n        }\n        WBNB = WBNB_;\n        factory = factory_;\n    }\n\n    /**\n     * @notice Perform swap on the path(pairs)\n     * @param amounts Araay of amounts of tokens after performing the swap\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param _to Recipient of the output tokens.\n     */\n    function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint256 i; i < path.length - 1; ) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = PancakeLibrary.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            IPancakePair(PancakeLibrary.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n\n    /**\n     * @notice Perform swap on the path(pairs) for supporting fee\n     * @dev requires the initial amount to have already been sent to the first pair\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param _to Recipient of the output tokens.\n     */\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint256 i; i < path.length - 1; ) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = PancakeLibrary.sortTokens(input, output);\n            IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(factory, input, output));\n            uint256 amountInput;\n            uint256 amountOutput;\n            {\n                // scope to avoid stack too deep errors\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n\n                uint256 balance = IERC20(input).balanceOf(address(pair));\n                amountInput = balance - reserveInput;\n                amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOutput)\n                : (amountOutput, uint256(0));\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Swap token A for token B\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param swapFor TypesOfTokens, either supporing fee or non supporting fee\n     * @return amounts Array of amounts after performing swap for respective pairs in path\n     */\n    function _swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        address pairAddress = PancakeLibrary.pairFor(factory, path[0], path[1]);\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            TransferHelper.safeTransferFrom(path[0], msg.sender, pairAddress, amounts[0]);\n            _swap(amounts, path, to);\n            emit SwapTokensForTokens(msg.sender, path, amounts);\n        } else {\n            TransferHelper.safeTransferFrom(path[0], msg.sender, pairAddress, amountIn);\n            _swapSupportingFeeOnTransferTokens(path, to);\n            emit SwapTokensForTokensAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    /**\n     * @notice Swap exact BNB for token\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param swapFor TypesOfTokens, either supporing fee or non supporting fee\n     * @return amounts Array of amounts after performing swap for respective pairs in path\n     */\n    function _swapExactBNBForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        address wBNBAddress = WBNB;\n        if (path[0] != wBNBAddress) {\n            revert WrongAddress(wBNBAddress, path[0]);\n        }\n        IWBNB(wBNBAddress).deposit{ value: msg.value }();\n        TransferHelper.safeTransfer(wBNBAddress, PancakeLibrary.pairFor(factory, path[0], path[1]), msg.value);\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, msg.value, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            _swap(amounts, path, to);\n            emit SwapBnbForTokens(msg.sender, path, amounts);\n        } else {\n            _swapSupportingFeeOnTransferTokens(path, to);\n            emit SwapBnbForTokensAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    /**\n     * @notice Swap token A for BNB\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of BNB to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param swapFor TypesOfTokens, either supporing fee or non supporting fee\n     * @return amounts Array of amounts after performing swap for respective pairs in path\n     */\n    function _swapExactTokensForBNB(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        if (path[path.length - 1] != WBNB) {\n            revert WrongAddress(WBNB, path[path.length - 1]);\n        }\n        uint256 WBNBAmount;\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            TransferHelper.safeTransferFrom(\n                path[0],\n                msg.sender,\n                PancakeLibrary.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            );\n            _swap(amounts, path, address(this));\n            WBNBAmount = amounts[amounts.length - 1];\n        } else {\n            uint256 balanceBefore = IWBNB(WBNB).balanceOf(address(this));\n            TransferHelper.safeTransferFrom(\n                path[0],\n                msg.sender,\n                PancakeLibrary.pairFor(factory, path[0], path[1]),\n                amountIn\n            );\n            _swapSupportingFeeOnTransferTokens(path, address(this));\n            uint256 balanceAfter = IWBNB(WBNB).balanceOf(address(this));\n            WBNBAmount = balanceAfter - balanceBefore;\n        }\n        IWBNB(WBNB).withdraw(WBNBAmount);\n        if (to != address(this)) {\n            TransferHelper.safeTransferBNB(to, WBNBAmount);\n        }\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            emit SwapTokensForBnb(msg.sender, path, amounts);\n        } else {\n            emit SwapTokensForBnbAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    /**\n     * @notice Swap token A for exact amount of token B\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @return amounts Array of amounts after performing swap for respective pairs in path\n     **/\n    function _swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > amountInMax) {\n            revert InputAmountAboveMaximum(amounts[0], amountInMax);\n        }\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PancakeLibrary.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, to);\n        emit SwapTokensForTokens(msg.sender, path, amounts);\n    }\n\n    /**\n     * @notice Swap BNB for exact amount of token B\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @return amounts Array of amounts after performing swap for respective pairs in path\n     **/\n    function _swapBNBForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        if (path[0] != WBNB) {\n            revert WrongAddress(WBNB, path[0]);\n        }\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > msg.value) {\n            revert ExcessiveInputAmount(amounts[0], msg.value);\n        }\n        IWBNB(WBNB).deposit{ value: amounts[0] }();\n        TransferHelper.safeTransfer(WBNB, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, to);\n        // refund dust BNB, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferBNB(msg.sender, msg.value - amounts[0]);\n        emit SwapBnbForTokens(msg.sender, path, amounts);\n    }\n\n    /**\n     * @notice Swap token A for exact BNB\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @return amounts Array of amounts after performing swap for respective pairs in path\n     **/\n    function _swapTokensForExactBNB(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        if (path[path.length - 1] != WBNB) {\n            revert WrongAddress(WBNB, path[path.length - 1]);\n        }\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > amountInMax) {\n            revert InputAmountAboveMaximum(amounts[amounts.length - 1], amountInMax);\n        }\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PancakeLibrary.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWBNB(WBNB).withdraw(amounts[amounts.length - 1]);\n        if (to != address(this)) {\n            TransferHelper.safeTransferBNB(to, amounts[amounts.length - 1]);\n        }\n        emit SwapTokensForBnb(msg.sender, path, amounts);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n\n    /**\n     * @notice Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     * @param amountA The amount of token A\n     * @param reserveA The amount of reserves for token A before swap\n     * @param reserveB The amount of reserves for token B before swap\n     * @return amountB An equivalent amount of the token B\n     **/\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure virtual override returns (uint256 amountB) {\n        return PancakeLibrary.quote(amountA, reserveA, reserveB);\n    }\n\n    /**\n     * @notice Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n     * @param amountIn The amount of token A need to swap\n     * @param reserveIn The amount of reserves for token A before swap\n     * @param reserveOut The amount of reserves for token B after swap\n     * @return amountOut The maximum output amount of the token B\n     **/\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure virtual override returns (uint256 amountOut) {\n        return PancakeLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    /**\n     * @notice Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n     * @param amountOut The amount of token B after swap\n     * @param reserveIn The amount of reserves for token A before swap\n     * @param reserveOut The amount of reserves for token B after swap\n     * @return amountIn Required input amount of the token A\n     **/\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure virtual override returns (uint256 amountIn) {\n        return PancakeLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    /**\n     * @notice performs chained getAmountOut calculations on any number of pairs.\n     * @param amountIn The amount of tokens to swap.\n     * @param path Array with addresses of the underlying assets to be swapped.\n     */\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] memory path\n    ) external view virtual override returns (uint256[] memory amounts) {\n        return PancakeLibrary.getAmountsOut(factory, amountIn, path);\n    }\n\n    /**\n     * @notice performs chained getAmountIn calculations on any number of pairs.\n     * @param amountOut amountOut The amount of the tokens needs to be as output token.\n     * @param path Array with addresses of the underlying assets to be swapped.\n     */\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] memory path\n    ) external view virtual override returns (uint256[] memory amounts) {\n        return PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    }\n}\n"
    },
    "contracts/Swap/SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IPancakeSwapV2Router.sol\";\nimport \"./interfaces/IVtoken.sol\";\nimport \"./RouterHelper.sol\";\nimport \"./interfaces/IVBNB.sol\";\nimport \"./interfaces/IVtoken.sol\";\nimport \"./interfaces/InterfaceComptroller.sol\";\n\n/**\n * @title Venus's Pancake Swap Integration Contract\n * @notice This contracts allows users to swap a token for another one and supply/repay with the latter.\n * @dev For all functions that do not swap native BNB, user must approve this contract with the amount, prior the calling the swap function.\n * @author 0xlucian\n */\n\ncontract SwapRouter is Ownable2Step, RouterHelper, IPancakeSwapV2Router {\n    using SafeERC20 for IERC20;\n\n    address public immutable comptrollerAddress;\n\n    uint256 private constant _NOT_ENTERED = 1;\n\n    uint256 private constant _ENTERED = 2;\n\n    address public vBNBAddress;\n\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    uint256 internal _status;\n\n    // ***************\n    // ** MODIFIERS **\n    // ***************\n    modifier ensure(uint256 deadline) {\n        if (deadline < block.timestamp) {\n            revert SwapDeadlineExpire(deadline, block.timestamp);\n        }\n        _;\n    }\n\n    modifier ensurePath(address[] calldata path) {\n        if (path.length < 2) {\n            revert InvalidPath();\n        }\n        _;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        if (_status == _ENTERED) {\n            revert ReentrantCheck();\n        }\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    /// @notice event emitted on sweep token success\n    event SweepToken(address indexed token, address indexed to, uint256 sweepAmount);\n\n    /// @notice event emitted on vBNBAddress update\n    event VBNBAddressUpdated(address indexed oldAddress, address indexed newAddress);\n\n    // *********************\n    // **** CONSTRUCTOR ****\n    // *********************\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address WBNB_,\n        address factory_,\n        address _comptrollerAddress,\n        address _vBNBAddress\n    ) RouterHelper(WBNB_, factory_) {\n        if (_comptrollerAddress == address(0) || _vBNBAddress == address(0)) {\n            revert ZeroAddress();\n        }\n        comptrollerAddress = _comptrollerAddress;\n        _status = _NOT_ENTERED;\n        vBNBAddress = _vBNBAddress;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WBNB); // only accept BNB via fallback from the WBNB contract\n    }\n\n    // ****************************\n    // **** EXTERNAL FUNCTIONS ****\n    // ****************************\n\n    /**\n     * @notice Setter for the vBNB address.\n     * @param _vBNBAddress Address of the BNB vToken to update.\n     */\n    function setVBNBAddress(address _vBNBAddress) external onlyOwner {\n        if (_vBNBAddress == address(0)) {\n            revert ZeroAddress();\n        }\n\n        _isVTokenListed(_vBNBAddress);\n\n        address oldAddress = vBNBAddress;\n        vBNBAddress = _vBNBAddress;\n\n        emit VBNBAddressUpdated(oldAddress, vBNBAddress);\n    }\n\n    /**\n     * @notice Swap token A for token B and supply to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     */\n    function swapExactTokensForTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap deflationary (a small amount of fee is deducted at the time of transfer of token) token A for token B and supply to a Venus market.\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     */\n    function swapExactTokensForTokensAndSupplyAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, address(this));\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for another token and supply to a Venus market\n     * @dev The amount to be swapped is obtained from the msg.value, since we are swapping BNB\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactBNBForTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactBNBForTokens(amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for another deflationary token (a small amount of fee is deducted at the time of transfer of token) and supply to a Venus market\n     * @dev The amount to be swapped is obtained from the msg.value, since we are swapping BNB\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactBNBForTokensAndSupplyAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactBNBForTokens(amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, address(this));\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap tokens for Exact tokens and supply to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForExactTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapTokensForExactTokens(amountOut, amountInMax, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for Exact tokens and supply to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapBNBForExactTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOut,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapBNBForExactTokens(amountOut, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap Exact tokens for BNB and supply to a Venus market\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactTokensForBNBAndSupply(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapExactTokensForBNB(amountIn, amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        _mintVBNBandTransfer(swapAmount);\n    }\n\n    /**\n     * @notice Swap Exact deflationary tokens (a small amount of fee is deducted at the time of transfer of tokens) for BNB and supply to a Venus market\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactTokensForBNBAndSupplyAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapExactTokensForBNB(amountIn, amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        if (swapAmount < amountOutMin) {\n            revert SwapAmountLessThanAmountOutMin(swapAmount, amountOutMin);\n        }\n        _mintVBNBandTransfer(swapAmount);\n    }\n\n    /**\n     * @notice Swap tokens for Exact BNB and supply to a Venus market\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForExactBNBAndSupply(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapTokensForExactBNB(amountOut, amountInMax, path, address(this));\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        _mintVBNBandTransfer(swapAmount);\n    }\n\n    /**\n     * @notice Swap token A for token B and repay a borrow from a Venus market\n     * @param vTokenAddress The address of the vToken contract to repay.\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive (and repay)\n     */\n    function swapExactTokensForTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap deflationary token (a small amount of fee is deducted at the time of transfer of token) token A for token B and repay a borrow from a Venus market\n     * @param vTokenAddress The address of the vToken contract to repay.\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive (and repay)\n     */\n    function swapExactTokensForTokensAndRepayAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, address(this));\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for another token and repay a borrow from a Venus market\n     * @dev The amount to be swapped is obtained from the msg.value, since we are swapping BNB\n     * @param vTokenAddress The address of the vToken contract to repay.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered so the swap path tokens are listed first and last asset is the token we receive\n     */\n    function swapExactBNBForTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactBNBForTokens(amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for another deflationary token (a small amount of fee is deducted at the time of transfer of token) and repay a borrow from a Venus market\n     * @dev The amount to be swapped is obtained from the msg.value, since we are swapping BNB\n     * @param vTokenAddress The address of the vToken contract to repay.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered so the swap path tokens are listed first and last asset is the token we receive\n     */\n    function swapExactBNBForTokensAndRepayAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactBNBForTokens(amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, address(this));\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap tokens for Exact tokens and repay to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForExactTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapTokensForExactTokens(amountOut, amountInMax, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap tokens for full tokens debt and repay to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForFullTokenDebtAndRepay(\n        address vTokenAddress,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        uint256 amountOut = IVToken(vTokenAddress).borrowBalanceCurrent(msg.sender);\n        _swapTokensForExactTokens(amountOut, amountInMax, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for Exact tokens and repay to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapBNBForExactTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOut,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapBNBForExactTokens(amountOut, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for Exact tokens and repay to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapBNBForFullTokenDebtAndRepay(\n        address vTokenAddress,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        uint256 amountOut = IVToken(vTokenAddress).borrowBalanceCurrent(msg.sender);\n        _swapBNBForExactTokens(amountOut, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap Exact tokens for BNB and repay to a Venus market\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactTokensForBNBAndRepay(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapExactTokensForBNB(amountIn, amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        IVBNB(vBNBAddress).repayBorrowBehalf{ value: swapAmount }(msg.sender);\n    }\n\n    /**\n     * @notice Swap Exact deflationary tokens (a small amount of fee is deducted at the time of transfer of tokens) for BNB and repay to a Venus market\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactTokensForBNBAndRepayAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapExactTokensForBNB(amountIn, amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        if (swapAmount < amountOutMin) {\n            revert SwapAmountLessThanAmountOutMin(swapAmount, amountOutMin);\n        }\n        IVBNB(vBNBAddress).repayBorrowBehalf{ value: swapAmount }(msg.sender);\n    }\n\n    /**\n     * @notice Swap tokens for Exact BNB and repay to a Venus market\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForExactBNBAndRepay(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapTokensForExactBNB(amountOut, amountInMax, path, address(this));\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        IVBNB(vBNBAddress).repayBorrowBehalf{ value: swapAmount }(msg.sender);\n    }\n\n    /**\n     * @notice Swap tokens for Exact BNB and repay to a Venus market\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForFullBNBDebtAndRepay(\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        uint256 amountOut = IVToken(vBNBAddress).borrowBalanceCurrent(msg.sender);\n        _swapTokensForExactBNB(amountOut, amountInMax, path, address(this));\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        IVBNB(vBNBAddress).repayBorrowBehalf{ value: swapAmount }(msg.sender);\n    }\n\n    /**\n     * @notice Swaps an exact amount of input tokens for as many output tokens as possible,\n     *         along the route determined by the path. The first element of path is the input token,\n     *         the last is the output token, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountIn The address of the vToken contract to repay.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override nonReentrant ensure(deadline) ensurePath(path) returns (uint256[] memory amounts) {\n        amounts = _swapExactTokensForTokens(amountIn, amountOutMin, path, to, TypesOfTokens.NON_SUPPORTING_FEE);\n    }\n\n    /**\n     * @notice Swaps an exact amount of input tokens for as many output tokens as possible,\n     *         along the route determined by the path. The first element of path is the input token,\n     *         the last is the output token, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     *         This method to swap deflationary tokens which would require supporting fee.\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountIn The address of the vToken contract to repay.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactTokensForTokensAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override nonReentrant ensure(deadline) ensurePath(path) returns (uint256 swapAmount) {\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(to);\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, to, TypesOfTokens.SUPPORTING_FEE);\n        swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, to);\n    }\n\n    /**\n     * @notice Swaps an exact amount of BNB for as many output tokens as possible,\n     *         along the route determined by the path. The first element of path must be WBNB,\n     *         the last is the output token, and any intermediate elements represent\n     *         intermediate pairs to trade through (if, for example, a direct pair does not exist).\n     * @dev amountIn is passed through the msg.value of the transaction\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactBNBForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        nonReentrant\n        ensure(deadline)\n        ensurePath(path)\n        returns (uint256[] memory amounts)\n    {\n        amounts = _swapExactBNBForTokens(amountOutMin, path, to, TypesOfTokens.NON_SUPPORTING_FEE);\n    }\n\n    /**\n     * @notice Swaps an exact amount of ETH for as many output tokens as possible,\n     *         along the route determined by the path. The first element of path must be WBNB,\n     *         the last is the output token, and any intermediate elements represent\n     *         intermediate pairs to trade through (if, for example, a direct pair does not exist).\n     *         This method to swap deflationary tokens which would require supporting fee.\n     * @dev amountIn is passed through the msg.value of the transaction\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactBNBForTokensAtSupportingFee(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override nonReentrant ensure(deadline) ensurePath(path) returns (uint256 swapAmount) {\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(to);\n        _swapExactBNBForTokens(amountOutMin, path, to, TypesOfTokens.SUPPORTING_FEE);\n        swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, to);\n    }\n\n    /**\n     * @notice Swaps an exact amount of input tokens for as many output ETH as possible,\n     *         along the route determined by the path. The first element of path is the input token,\n     *         the last is the output ETH, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountIn The address of the vToken contract to repay.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactTokensForBNB(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) returns (uint256[] memory amounts) {\n        amounts = _swapExactTokensForBNB(amountIn, amountOutMin, path, to, TypesOfTokens.NON_SUPPORTING_FEE);\n    }\n\n    /**\n     * @notice Swaps an exact amount of input tokens for as many output ETH as possible,\n     *         along the route determined by the path. The first element of path is the input token,\n     *         the last is the output ETH, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     *         This method to swap deflationary tokens which would require supporting fee.\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountIn The address of the vToken contract to repay.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactTokensForBNBAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) returns (uint256 swapAmount) {\n        uint256 balanceBefore = to.balance;\n        _swapExactTokensForBNB(amountIn, amountOutMin, path, to, TypesOfTokens.SUPPORTING_FEE);\n        uint256 balanceAfter = to.balance;\n        swapAmount = balanceAfter - balanceBefore;\n        if (swapAmount < amountOutMin) {\n            revert SwapAmountLessThanAmountOutMin(swapAmount, amountOutMin);\n        }\n    }\n\n    /**\n     * @notice Swaps an as many amount of input tokens for as exact amount of tokens as output,\n     *         along the route determined by the path. The first element of path is the input token,\n     *         the last is the output token, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     **/\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override nonReentrant ensure(deadline) ensurePath(path) returns (uint256[] memory amounts) {\n        amounts = _swapTokensForExactTokens(amountOut, amountInMax, path, to);\n    }\n\n    /**\n     * @notice Swaps an as ETH as input tokens for as exact amount of tokens as output,\n     *         along the route determined by the path. The first element of path is the input WBNB,\n     *         the last is the output as token, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     **/\n    function swapBNBForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        nonReentrant\n        ensure(deadline)\n        ensurePath(path)\n        returns (uint256[] memory amounts)\n    {\n        amounts = _swapBNBForExactTokens(amountOut, path, to);\n    }\n\n    /**\n     * @notice Swaps an as many amount of input tokens for as exact amount of ETH as output,\n     *         along the route determined by the path. The first element of path is the input token,\n     *         the last is the output as ETH, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     **/\n    function swapTokensForExactBNB(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override nonReentrant ensure(deadline) ensurePath(path) returns (uint256[] memory amounts) {\n        amounts = _swapTokensForExactBNB(amountOut, amountInMax, path, to);\n    }\n\n    /**\n     * @notice A public function to sweep accidental BEP-20 transfers to this contract. Tokens are sent to the address `to`, provided in input\n     * @param token The address of the ERC-20 token to sweep\n     * @param to Recipient of the output tokens.\n     * @param sweepAmount The ampunt of the tokens to sweep\n     * @custom:access Only Governance\n     */\n    function sweepToken(IERC20 token, address to, uint256 sweepAmount) external onlyOwner nonReentrant {\n        if (to == address(0)) {\n            revert ZeroAddress();\n        }\n        uint256 balance = token.balanceOf(address(this));\n        if (sweepAmount > balance) {\n            revert InsufficientBalance(sweepAmount, balance);\n        }\n        token.safeTransfer(to, sweepAmount);\n\n        emit SweepToken(address(token), to, sweepAmount);\n    }\n\n    /**\n     * @notice Supply token to a Venus market\n     * @param path The addresses of the underlying token\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param swapAmount The amount of tokens supply to Venus Market.\n     */\n    function _supply(address path, address vTokenAddress, uint256 swapAmount) internal {\n        TransferHelper.safeApprove(path, vTokenAddress, 0);\n        TransferHelper.safeApprove(path, vTokenAddress, swapAmount);\n        uint256 response = IVToken(vTokenAddress).mintBehalf(msg.sender, swapAmount);\n        if (response != 0) {\n            revert SupplyError(msg.sender, vTokenAddress, response);\n        }\n    }\n\n    /**\n     * @notice Repay a borrow from Venus market\n     * @param path The addresses of the underlying token\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param swapAmount The amount of tokens repay to Venus Market.\n     */\n    function _repay(address path, address vTokenAddress, uint256 swapAmount) internal {\n        TransferHelper.safeApprove(path, vTokenAddress, 0);\n        TransferHelper.safeApprove(path, vTokenAddress, swapAmount);\n        uint256 response = IVToken(vTokenAddress).repayBorrowBehalf(msg.sender, swapAmount);\n        if (response != 0) {\n            revert RepayError(msg.sender, vTokenAddress, response);\n        }\n    }\n\n    /**\n     * @notice Check if the balance of to minus the balanceBefore is greater or equal to the amountOutMin.\n     * @param asset The address of the underlying token\n     * @param balanceBefore Balance before the swap.\n     * @param amountOutMin Min amount out threshold.\n     * @param to Recipient of the output tokens.\n     */\n    function _checkForAmountOut(\n        address asset,\n        uint256 balanceBefore,\n        uint256 amountOutMin,\n        address to\n    ) internal view returns (uint256 swapAmount) {\n        uint256 balanceAfter = IERC20(asset).balanceOf(to);\n        swapAmount = balanceAfter - balanceBefore;\n        if (swapAmount < amountOutMin) {\n            revert SwapAmountLessThanAmountOutMin(swapAmount, amountOutMin);\n        }\n    }\n\n    /**\n     * @notice Returns the difference between the balance of this and the balanceBefore\n     * @param asset The address of the underlying token\n     * @param balanceBefore Balance before the swap.\n     */\n    function _getSwapAmount(address asset, uint256 balanceBefore) internal view returns (uint256 swapAmount) {\n        uint256 balanceAfter = IERC20(asset).balanceOf(address(this));\n        swapAmount = balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @notice Check isVTokenListed and last address in the path should be vToken underlying.\n     * @param vTokenAddress Address of the vToken.\n     * @param underlying Address of the underlying asset.\n     */\n    function _ensureVTokenChecks(address vTokenAddress, address underlying) internal {\n        _isVTokenListed(vTokenAddress);\n        if (IVToken(vTokenAddress).underlying() != underlying) {\n            revert VTokenUnderlyingInvalid(underlying);\n        }\n    }\n\n    /**\n     * @notice Check is vToken listed in the pool.\n     * @param vToken Address of the vToken.\n     */\n    function _isVTokenListed(address vToken) internal view {\n        bool isListed = InterfaceComptroller(comptrollerAddress).markets(vToken);\n        if (!isListed) {\n            revert VTokenNotListed(vToken);\n        }\n    }\n\n    /**\n     * @notice Mint vBNB tokens to the market then transfer them to user\n     * @param swapAmount Swapped BNB amount\n     */\n    function _mintVBNBandTransfer(uint256 swapAmount) internal {\n        uint256 vBNBBalanceBefore = IVBNB(vBNBAddress).balanceOf(address(this));\n        IVBNB(vBNBAddress).mint{ value: swapAmount }();\n        uint256 vBNBBalanceAfter = IVBNB(vBNBAddress).balanceOf(address(this));\n        IERC20(vBNBAddress).safeTransfer(msg.sender, (vBNBBalanceAfter - vBNBBalanceBefore));\n    }\n}\n"
    },
    "contracts/test/AccessControlManagerMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\ncontract AccessControlManagerMock {\n    address public owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    function isAllowedToCall(address account, string calldata functionSig) public view returns (bool) {\n        if (account == owner) {\n            return true;\n        }\n\n        functionSig;\n\n        return false;\n    }\n}\n"
    },
    "contracts/test/ComptrollerHarness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"./ComptrollerMock.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\ncontract ComptrollerHarness is ComptrollerMock {\n    address internal xvsAddress;\n    address internal vXVSAddress;\n    uint public blockNumber;\n\n    constructor() ComptrollerMock() {}\n\n    function setVenusSupplyState(address vToken, uint224 index, uint32 blockNumber_) public {\n        venusSupplyState[vToken].index = index;\n        venusSupplyState[vToken].block = blockNumber_;\n    }\n\n    function setVenusBorrowState(address vToken, uint224 index, uint32 blockNumber_) public {\n        venusBorrowState[vToken].index = index;\n        venusBorrowState[vToken].block = blockNumber_;\n    }\n\n    function setVenusAccrued(address user, uint userAccrued) public {\n        venusAccrued[user] = userAccrued;\n    }\n\n    function setXVSAddress(address xvsAddress_) public {\n        xvsAddress = xvsAddress_;\n    }\n\n    function setXVSVTokenAddress(address vXVSAddress_) public {\n        vXVSAddress = vXVSAddress_;\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block\n     * @param venusRate_ The amount of XVS wei per block to distribute\n     */\n    function harnessSetVenusRate(uint venusRate_) public {\n        venusRate = venusRate_;\n    }\n\n    /**\n     * @notice Recalculate and update XVS speeds for all XVS markets\n     */\n    function harnessRefreshVenusSpeeds() public {\n        VToken[] memory allMarkets_ = allMarkets;\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusSupplyIndex(address(vToken));\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n        }\n\n        Exp memory totalUtility = Exp({ mantissa: 0 });\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            if (venusSpeeds[address(vToken)] > 0) {\n                Exp memory assetPrice = Exp({ mantissa: oracle.getUnderlyingPrice(address(vToken)) });\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\n                utilities[i] = utility;\n                totalUtility = add_(totalUtility, utility);\n            }\n        }\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets[i];\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\n            setVenusSpeedInternal(vToken, newSpeed, newSpeed);\n        }\n    }\n\n    function setVenusBorrowerIndex(address vToken, address borrower, uint index) public {\n        venusBorrowerIndex[vToken][borrower] = index;\n    }\n\n    function setVenusSupplierIndex(address vToken, address supplier, uint index) public {\n        venusSupplierIndex[vToken][supplier] = index;\n    }\n\n    function harnessDistributeAllBorrowerVenus(\n        address vToken,\n        address borrower,\n        uint marketBorrowIndexMantissa\n    ) public {\n        distributeBorrowerVenus(vToken, borrower, Exp({ mantissa: marketBorrowIndexMantissa }));\n        venusAccrued[borrower] = grantXVSInternal(borrower, venusAccrued[borrower], 0, false);\n    }\n\n    function harnessDistributeAllSupplierVenus(address vToken, address supplier) public {\n        distributeSupplierVenus(vToken, supplier);\n        venusAccrued[supplier] = grantXVSInternal(supplier, venusAccrued[supplier], 0, false);\n    }\n\n    function harnessUpdateVenusBorrowIndex(address vToken, uint marketBorrowIndexMantissa) public {\n        updateVenusBorrowIndex(vToken, Exp({ mantissa: marketBorrowIndexMantissa }));\n    }\n\n    function harnessUpdateVenusSupplyIndex(address vToken) public {\n        updateVenusSupplyIndex(vToken);\n    }\n\n    function harnessDistributeBorrowerVenus(address vToken, address borrower, uint marketBorrowIndexMantissa) public {\n        distributeBorrowerVenus(vToken, borrower, Exp({ mantissa: marketBorrowIndexMantissa }));\n    }\n\n    function harnessDistributeSupplierVenus(address vToken, address supplier) public {\n        distributeSupplierVenus(vToken, supplier);\n    }\n\n    function harnessTransferVenus(address user, uint userAccrued, uint threshold) public returns (uint) {\n        if (userAccrued > 0 && userAccrued >= threshold) {\n            return grantXVSInternal(user, userAccrued, 0, false);\n        }\n        return userAccrued;\n    }\n\n    function harnessAddVenusMarkets(address[] memory vTokens) public {\n        for (uint i = 0; i < vTokens.length; i++) {\n            // temporarily set venusSpeed to 1 (will be fixed by `harnessRefreshVenusSpeeds`)\n            setVenusSpeedInternal(VToken(vTokens[i]), 1, 1);\n        }\n    }\n\n    function harnessSetMintedVAIs(address user, uint amount) public {\n        mintedVAIs[user] = amount;\n    }\n\n    function harnessFastForward(uint blocks) public returns (uint) {\n        blockNumber += blocks;\n        return blockNumber;\n    }\n\n    function setBlockNumber(uint number) public {\n        blockNumber = number;\n    }\n\n    function getBlockNumber() internal view override returns (uint) {\n        return blockNumber;\n    }\n\n    function getVenusMarkets() public view returns (address[] memory) {\n        uint m = allMarkets.length;\n        uint n = 0;\n        for (uint i = 0; i < m; i++) {\n            if (venusSpeeds[address(allMarkets[i])] > 0) {\n                n++;\n            }\n        }\n\n        address[] memory venusMarkets = new address[](n);\n        uint k = 0;\n        for (uint i = 0; i < m; i++) {\n            if (venusSpeeds[address(allMarkets[i])] > 0) {\n                venusMarkets[k++] = address(allMarkets[i]);\n            }\n        }\n        return venusMarkets;\n    }\n\n    function harnessSetReleaseStartBlock(uint startBlock) external {\n        releaseStartBlock = startBlock;\n    }\n\n    function harnessAddVtoken(address vToken) external {\n        markets[vToken].isListed = true;\n    }\n}\n\ncontract EchoTypesComptroller is UnitrollerAdminStorage {\n    function stringy(string memory s) public pure returns (string memory) {\n        return s;\n    }\n\n    function addresses(address a) public pure returns (address) {\n        return a;\n    }\n\n    function booly(bool b) public pure returns (bool) {\n        return b;\n    }\n\n    function listOInts(uint[] memory u) public pure returns (uint[] memory) {\n        return u;\n    }\n\n    function reverty() public pure {\n        require(false, \"gotcha sucka\");\n    }\n\n    function becomeBrains(address payable unitroller) public {\n        Unitroller(unitroller)._acceptImplementation();\n    }\n}\n"
    },
    "contracts/test/ComptrollerMock.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/facets/MarketFacet.sol\";\nimport \"../Comptroller/Diamond/facets/PolicyFacet.sol\";\nimport \"../Comptroller/Diamond/facets/RewardFacet.sol\";\nimport \"../Comptroller/Diamond/facets/SetterFacet.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\n// This contract contains all methods of Comptroller implementation in different facets at one place for testing purpose\n// This contract does not have diamond functionality(i.e delegate call to facets methods)\ncontract ComptrollerMock is MarketFacet, PolicyFacet, RewardFacet, SetterFacet {\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external override returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/test/ComptrollerMockR1.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/facets/MarketFacet.sol\";\nimport \"../Comptroller/Diamond/facets/PolicyFacet.sol\";\nimport \"../Comptroller/Diamond/facets/RewardFacet.sol\";\nimport \"../Comptroller/Diamond/facets/SetterFacet.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\n// This contract contains all methods of Comptroller implementation in different facets at one place for testing purpose\n// This contract does not have diamond functionality(i.e delegate call to facets methods)\ncontract ComptrollerMockR1 is MarketFacet, PolicyFacet, RewardFacet, SetterFacet {\n    event MarketListed(address vToken);\n    event NewCollateralFactor(address vToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n    event MarketEntered(address vToken, address account);\n    event MarketExited(address vToken, address account);\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external override returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/test/ComptrollerScenario.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"./ComptrollerMock.sol\";\n\ncontract ComptrollerScenario is ComptrollerMock {\n    uint public blockNumber;\n    address public xvsAddress;\n    address public vaiAddress;\n\n    constructor() ComptrollerMock() {}\n\n    function setXVSAddress(address xvsAddress_) public {\n        xvsAddress = xvsAddress_;\n    }\n\n    // function getXVSAddress() public view returns (address) {\n    //     return xvsAddress;\n    // }\n\n    function setVAIAddress(address vaiAddress_) public {\n        vaiAddress = vaiAddress_;\n    }\n\n    function getVAIAddress() public view returns (address) {\n        return vaiAddress;\n    }\n\n    function membershipLength(VToken vToken) public view returns (uint) {\n        return accountAssets[address(vToken)].length;\n    }\n\n    function fastForward(uint blocks) public returns (uint) {\n        blockNumber += blocks;\n\n        return blockNumber;\n    }\n\n    function setBlockNumber(uint number) public {\n        blockNumber = number;\n    }\n\n    function getBlockNumber() internal view override returns (uint) {\n        return blockNumber;\n    }\n\n    function getVenusMarkets() public view returns (address[] memory) {\n        uint m = allMarkets.length;\n        uint n = 0;\n        for (uint i = 0; i < m; i++) {\n            if (markets[address(allMarkets[i])].isVenus) {\n                n++;\n            }\n        }\n\n        address[] memory venusMarkets = new address[](n);\n        uint k = 0;\n        for (uint i = 0; i < m; i++) {\n            if (markets[address(allMarkets[i])].isVenus) {\n                venusMarkets[k++] = address(allMarkets[i]);\n            }\n        }\n        return venusMarkets;\n    }\n\n    function unlist(VToken vToken) public {\n        markets[address(vToken)].isListed = false;\n    }\n\n    /**\n     * @notice Recalculate and update XVS speeds for all XVS markets\n     */\n    function refreshVenusSpeeds() public {\n        VToken[] memory allMarkets_ = allMarkets;\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusSupplyIndex(address(vToken));\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n        }\n\n        Exp memory totalUtility = Exp({ mantissa: 0 });\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            if (venusSpeeds[address(vToken)] > 0) {\n                Exp memory assetPrice = Exp({ mantissa: oracle.getUnderlyingPrice(address(vToken)) });\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\n                utilities[i] = utility;\n                totalUtility = add_(totalUtility, utility);\n            }\n        }\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets[i];\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\n            setVenusSpeedInternal(vToken, newSpeed, newSpeed);\n        }\n    }\n}\n"
    },
    "contracts/test/DiamondHarness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/Diamond.sol\";\n\ncontract DiamondHarness is Diamond {\n    function getFacetAddress(bytes4 sig) public view returns (address) {\n        address facet = _selectorToFacetAndPosition[sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        return facet;\n    }\n}\n"
    },
    "contracts/test/DiamondHarnessInterface.sol": {
      "content": "pragma solidity 0.8.25;\n\ninterface DiamondHarnessInterface {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition;\n    }\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    function getFacetAddress(bytes4 sig) external view returns (address);\n\n    function diamondCut(FacetCut[] calldata _diamondCut) external;\n\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory _facetFunctionSelectors);\n\n    function facetPosition(address _facet) external view returns (uint256);\n\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    function facets() external view returns (Facet[] memory facets);\n\n    function facetAddress(bytes4 _functionSelector) external view returns (FacetAddressAndPosition memory);\n}\n"
    },
    "contracts/test/EvilXDelegator.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport { InterestRateModelV8 } from \"../InterestRateModels/InterestRateModelV8.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { VTokenInterface, VBep20Interface, VDelegatorInterface } from \"../Tokens/VTokens/VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20Delegator Contract\n * @notice VTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Venus\n */\ncontract EvilXDelegator is VTokenInterface, VBep20Interface, VDelegatorInterface {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address implementation_,\n        bytes memory becomeImplementationData\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"initialize(address,address,address,uint256,string,string,uint8)\",\n                underlying_,\n                comptroller_,\n                interestRateModel_,\n                initialExchangeRateMantissa_,\n                name_,\n                symbol_,\n                decimals_\n            )\n        );\n\n        // New implementations always get set via the settor (post-initialize)\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) public {\n        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n\n        if (allowResign) {\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n        }\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint256 mintAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mint(uint256)\", mintAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintBehalf(address receiver, uint256 mintAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"mintBehalf(address,uint256)\", receiver, mintAmount)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(uint256 borrowAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint256 repayAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"liquidateBorrow(address,uint256,address)\", borrower, repayAmount, vTokenCollateral)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount));\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", src, dst, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"allowance(address,address)\", owner, spender)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"balanceOf(address)\", owner));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint256, uint256, uint256, uint256) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"getAccountSnapshot(address)\", account)\n        );\n        return abi.decode(data, (uint256, uint256, uint256, uint256));\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this vToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"borrowBalanceStored(address)\", account)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getCash()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves.\n     * @dev This calculates interest accrued from the last checkpointed block\n     *      up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(address liquidator, address borrower, uint256 seizeTokens) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"seize(address,address,uint256)\", liquidator, borrower, seizeTokens)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Admin function to set a new comptroller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactor(uint256 newReserveFactorMantissa) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrues interest and adds reserves by transferring from admin\n     * @param addAmount Amount of reserves to add\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint256 addAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint256 reduceAmount) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel) public override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * @notice Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n        return delegateTo(implementation, data);\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(\n            abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data)\n        );\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/EvilXToken.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VTokens/VBep20Immutable.sol\";\nimport \"../Tokens/VTokens/VBep20Delegator.sol\";\nimport \"../Tokens/VTokens/VBep20Delegate.sol\";\nimport \"./ComptrollerScenario.sol\";\nimport \"../Comptroller/ComptrollerInterface.sol\";\n\ncontract VBep20Scenario is VBep20Immutable {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\n// doTransferOut method of this token supposed to be compromised and contians malicious code which\n// can be used by attacker to compromise the protocol working.\ncontract EvilXToken is VBep20Delegate {\n    event Log(string x, address y);\n    event Log(string x, uint y);\n    event LogLiquidity(uint liquidity);\n\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    address public comptrollerAddress;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    function setComptrollerAddress(address _comptrollerAddress) external {\n        comptrollerAddress = _comptrollerAddress;\n    }\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        super.doTransferOut(to, amount);\n\n        // Checking the Liquidity of the user after the tranfer.\n        // solhint-disable-next-line no-unused-vars\n        (uint errorCode, uint liquidity, uint shortfall) = ComptrollerInterface(comptrollerAddress).getAccountLiquidity(\n            msg.sender\n        );\n        emit LogLiquidity(liquidity);\n        return;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\n        totalBorrows = totalBorrows + addtlBorrow_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, msg.sender, amount);\n    }\n}\n"
    },
    "contracts/test/LiquidatorHarness.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport \"../Liquidator/Liquidator.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract LiquidatorHarness is Liquidator {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address comptroller_, address payable vBnb_, address wBnb_) Liquidator(comptroller_, vBnb_, wBnb_) {}\n\n    function initialize(\n        uint256 liquidationIncentiveMantissa_,\n        address accessControlManager_,\n        address protocolShareReserve_\n    ) external override initializer {\n        __Liquidator_init(liquidationIncentiveMantissa_, accessControlManager_, protocolShareReserve_);\n    }\n\n    event DistributeLiquidationIncentive(uint256 seizeTokensForTreasury, uint256 seizeTokensForLiquidator);\n\n    /// @dev Splits the received vTokens between the liquidator and treasury.\n    function distributeLiquidationIncentive(\n        IVToken vTokenCollateral,\n        uint256 siezedAmount\n    ) public returns (uint256 ours, uint256 theirs) {\n        (ours, theirs) = super._distributeLiquidationIncentive(vTokenCollateral, siezedAmount);\n        emit DistributeLiquidationIncentive(ours, theirs);\n        return (ours, theirs);\n    }\n\n    /// @dev Computes the amounts that would go to treasury and to the liquidator.\n    function splitLiquidationIncentive(uint256 seizedAmount) public view returns (uint256 ours, uint256 theirs) {\n        return super._splitLiquidationIncentive(seizedAmount);\n    }\n}\n"
    },
    "contracts/test/MockProtocolShareReserve.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { SafeERC20Upgradeable, IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ninterface IIncomeDestination {\n    function updateAssetsState(address comptroller, address asset) external;\n}\n\ninterface IVToken {\n    function underlying() external view returns (address);\n}\n\ninterface IPrime is IIncomeDestination {\n    function accrueInterest(address vToken) external;\n\n    function vTokenForAsset(address asset) external view returns (address);\n\n    function getAllMarkets() external view returns (address[] memory);\n}\n\ninterface IPoolRegistry {\n    /// @notice Get VToken in the Pool for an Asset\n    function getVTokenForAsset(address comptroller, address asset) external view returns (address);\n\n    /// @notice Get the addresss of the Pools supported that include a market for the provided asset\n    function getPoolsSupportedByAsset(address asset) external view returns (address[] memory);\n}\n\ninterface IMockProtocolShareReserve {\n    /// @notice it represents the type of vToken income\n    enum IncomeType {\n        SPREAD,\n        LIQUIDATION\n    }\n\n    function updateAssetsState(address comptroller, address asset, IncomeType incomeType) external;\n}\n\ninterface IComptroller {\n    function isComptroller() external view returns (bool);\n\n    function markets(address) external view returns (bool);\n\n    function getAllMarkets() external view returns (address[] memory);\n}\n\nerror InvalidAddress();\nerror UnsupportedAsset();\nerror InvalidTotalPercentage();\nerror InvalidMaxLoopsLimit();\n\n/**\n * @title MaxLoopsLimitHelper\n * @author Venus\n * @notice Abstract contract used to avoid collection with too many items that would generate gas errors and DoS.\n */\nabstract contract MaxLoopsLimitHelper {\n    // Limit for the loops to avoid the DOS\n    uint256 public maxLoopsLimit;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n\n    /// @notice Emitted when max loops limit is set\n    event MaxLoopsLimitUpdated(uint256 oldMaxLoopsLimit, uint256 newmaxLoopsLimit);\n\n    /// @notice Thrown an error on maxLoopsLimit exceeds for any loop\n    error MaxLoopsLimitExceeded(uint256 loopsLimit, uint256 requiredLoops);\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param limit Limit for the max loops can execute at a time\n     */\n    function _setMaxLoopsLimit(uint256 limit) internal {\n        require(limit > maxLoopsLimit, \"Comptroller: Invalid maxLoopsLimit\");\n\n        uint256 oldMaxLoopsLimit = maxLoopsLimit;\n        maxLoopsLimit = limit;\n\n        emit MaxLoopsLimitUpdated(oldMaxLoopsLimit, limit);\n    }\n\n    /**\n     * @notice Compare the maxLoopsLimit with number of the times loop iterate\n     * @param len Length of the loops iterate\n     * @custom:error MaxLoopsLimitExceeded error is thrown when loops length exceeds maxLoopsLimit\n     */\n    function _ensureMaxLoops(uint256 len) internal view {\n        if (len > maxLoopsLimit) {\n            revert MaxLoopsLimitExceeded(maxLoopsLimit, len);\n        }\n    }\n}\n\ncontract MockProtocolShareReserve is\n    AccessControlledV8,\n    ReentrancyGuardUpgradeable,\n    MaxLoopsLimitHelper,\n    IMockProtocolShareReserve\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice protocol income is categorized into two schemas.\n    /// The first schema is the default one\n    /// The second schema is for spread income from prime markets in core protocol\n    enum Schema {\n        DEFAULT,\n        SPREAD_PRIME_CORE\n    }\n\n    struct DistributionConfig {\n        Schema schema;\n        /// @dev percenatge is represented without any scale\n        uint256 percentage;\n        address destination;\n    }\n\n    /// @notice address of core pool comptroller contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable CORE_POOL_COMPTROLLER;\n\n    /// @notice address of WBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice address of vBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vBNB;\n\n    /// @notice address of Prime contract\n    address public prime;\n\n    /// @notice address of pool registry contract\n    address public poolRegistry;\n\n    uint256 private constant MAX_PERCENT = 100;\n\n    /// @notice comptroller => asset => schema => balance\n    mapping(address => mapping(address => mapping(Schema => uint256))) public assetsReserves;\n\n    /// @notice asset => balance\n    mapping(address => uint256) public totalAssetReserve;\n\n    /// @notice configuration for different income distribution targets\n    DistributionConfig[] public distributionTargets;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    /// @notice Emitted when prime address is updated\n    event PrimeUpdated(address indexed oldPrime, address indexed newPrime);\n\n    /// @notice Event emitted after the updation of the assets reserves.\n    event AssetsReservesUpdated(\n        address indexed comptroller,\n        address indexed asset,\n        uint256 amount,\n        IncomeType incomeType,\n        Schema schema\n    );\n\n    /// @notice Event emitted when an asset is released to a target\n    event AssetReleased(\n        address indexed destination,\n        address indexed asset,\n        Schema schema,\n        uint256 percent,\n        uint256 amount\n    );\n\n    /// @notice Event emitted when asset reserves state is updated\n    event ReservesUpdated(\n        address indexed comptroller,\n        address indexed asset,\n        Schema schema,\n        uint256 oldBalance,\n        uint256 newBalance\n    );\n\n    /// @notice Event emitted when distribution configuration is updated\n    event DistributionConfigUpdated(\n        address indexed destination,\n        uint256 oldPercentage,\n        uint256 newPercentage,\n        Schema schema\n    );\n\n    /// @notice Event emitted when distribution configuration is added\n    event DistributionConfigAdded(address indexed destination, uint256 percentage, Schema schema);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _corePoolComptroller, address _wbnb, address _vbnb) {\n        if (_corePoolComptroller == address(0)) revert InvalidAddress();\n        if (_wbnb == address(0)) revert InvalidAddress();\n        if (_vbnb == address(0)) revert InvalidAddress();\n\n        CORE_POOL_COMPTROLLER = _corePoolComptroller;\n        WBNB = _wbnb;\n        vBNB = _vbnb;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the deployer to owner.\n     * @param _accessControlManager The address of ACM contract\n     * @param _loopsLimit Limit for the loops in the contract to avoid DOS\n     */\n    function initialize(address _accessControlManager, uint256 _loopsLimit) external initializer {\n        __AccessControlled_init(_accessControlManager);\n        __ReentrancyGuard_init();\n        _setMaxLoopsLimit(_loopsLimit);\n    }\n\n    /**\n     * @dev Pool registry setter.\n     * @param _poolRegistry Address of the pool registry\n     * @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\n     */\n    function setPoolRegistry(address _poolRegistry) external onlyOwner {\n        if (_poolRegistry == address(0)) revert InvalidAddress();\n        emit PoolRegistryUpdated(poolRegistry, _poolRegistry);\n        poolRegistry = _poolRegistry;\n    }\n\n    /**\n     * @dev Prime contract address setter.\n     * @param _prime Address of the prime contract\n     */\n    function setPrime(address _prime) external onlyOwner {\n        if (_prime == address(0)) revert InvalidAddress();\n        emit PrimeUpdated(prime, _prime);\n        prime = _prime;\n    }\n\n    /**\n     * @dev Add or update destination targets based on destination address\n     * @param configs configurations of the destinations.\n     */\n    function addOrUpdateDistributionConfigs(DistributionConfig[] memory configs) external nonReentrant {\n        _checkAccessAllowed(\"addOrUpdateDistributionConfigs(DistributionConfig[])\");\n\n        //we need to accrue and release funds to prime before updating the distribution configuration\n        //because prime relies on getUnreleasedFunds and its return value may change after config update\n        _accrueAndReleaseFundsToPrime();\n        for (uint256 i = 0; i < configs.length; ) {\n            DistributionConfig memory _config = configs[i];\n            require(_config.destination != address(0), \"ProtocolShareReserve: Destination address invalid\");\n\n            bool updated = false;\n            for (uint256 j = 0; j < distributionTargets.length; ) {\n                DistributionConfig storage config = distributionTargets[j];\n\n                if (_config.schema == config.schema && config.destination == _config.destination) {\n                    emit DistributionConfigUpdated(\n                        _config.destination,\n                        config.percentage,\n                        _config.percentage,\n                        _config.schema\n                    );\n                    config.percentage = _config.percentage;\n                    updated = true;\n                    break;\n                }\n\n                unchecked {\n                    ++j;\n                }\n            }\n\n            if (!updated) {\n                distributionTargets.push(_config);\n                emit DistributionConfigAdded(_config.destination, _config.percentage, _config.schema);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _ensurePercentages();\n        _ensureMaxLoops(distributionTargets.length);\n    }\n\n    /**\n     * @dev Release funds\n     * @param comptroller the comptroller address of the pool\n     * @param assets assets to be released to distribution targets\n     */\n    function releaseFunds(address comptroller, address[] memory assets) external nonReentrant {\n        _accruePrimeInterest();\n\n        for (uint256 i = 0; i < assets.length; ) {\n            _releaseFund(comptroller, assets[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Used to find out the amount of funds that's going to be released when release funds is called.\n     * @param comptroller the comptroller address of the pool\n     * @param schema the schema of the distribution target\n     * @param destination the destination address of the distribution target\n     * @param asset the asset address which will be released\n     */\n    function getUnreleasedFunds(\n        address comptroller,\n        Schema schema,\n        address destination,\n        address asset\n    ) external view returns (uint256) {\n        for (uint256 i = 0; i < distributionTargets.length; ) {\n            DistributionConfig storage _config = distributionTargets[i];\n            if (_config.schema == schema && _config.destination == destination) {\n                uint256 total = assetsReserves[comptroller][asset][schema];\n                return (total * _config.percentage) / MAX_PERCENT;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the total number of distribution targets\n     */\n    function totalDistributions() external view returns (uint256) {\n        return distributionTargets.length;\n    }\n\n    /**\n     * @dev Update the reserve of the asset for the specific pool after transferring to the protocol share reserve.\n     * @param comptroller Comptroller address (pool)\n     * @param asset Asset address.\n     * @param incomeType type of income\n     */\n    function updateAssetsState(\n        address comptroller,\n        address asset,\n        IncomeType incomeType\n    ) public override(IMockProtocolShareReserve) nonReentrant {\n        if (!IComptroller(comptroller).isComptroller()) revert InvalidAddress();\n        if (asset == address(0)) revert InvalidAddress();\n        if (\n            comptroller != CORE_POOL_COMPTROLLER &&\n            IPoolRegistry(poolRegistry).getVTokenForAsset(comptroller, asset) == address(0)\n        ) revert InvalidAddress();\n\n        Schema schema = getSchema(comptroller, asset, incomeType);\n        uint256 currentBalance = IERC20Upgradeable(asset).balanceOf(address(this));\n        uint256 assetReserve = totalAssetReserve[asset];\n\n        if (currentBalance > assetReserve) {\n            uint256 balanceDifference;\n            unchecked {\n                balanceDifference = currentBalance - assetReserve;\n            }\n\n            assetsReserves[comptroller][asset][schema] += balanceDifference;\n            totalAssetReserve[asset] += balanceDifference;\n            emit AssetsReservesUpdated(comptroller, asset, balanceDifference, incomeType, schema);\n        }\n    }\n\n    /**\n     * @dev Fetches the list of prime markets and then accrues interest and\n     * releases the funds to prime for each market\n     */\n    function _accrueAndReleaseFundsToPrime() internal {\n        address[] memory markets = IPrime(prime).getAllMarkets();\n        for (uint256 i = 0; i < markets.length; ) {\n            address market = markets[i];\n            IPrime(prime).accrueInterest(market);\n            _releaseFund(CORE_POOL_COMPTROLLER, _getUnderlying(market));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Fetches the list of prime markets and then accrues interest\n     * to prime for each market\n     */\n    function _accruePrimeInterest() internal {\n        // address[] memory markets = IPrime(prime).getAllMarkets();\n        address[] memory markets = IPrime(prime).getAllMarkets();\n\n        for (uint256 i = 0; i < markets.length; ) {\n            address market = markets[i];\n            IPrime(prime).accrueInterest(market);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev asset from a particular pool to be release to distribution targets\n     * @param comptroller  Comptroller address(pool)\n     * @param asset Asset address.\n     */\n    function _releaseFund(address comptroller, address asset) internal {\n        uint256 totalSchemas = uint256(type(Schema).max) + 1;\n        uint256[] memory schemaBalances = new uint256[](totalSchemas);\n        uint256 totalBalance;\n        for (uint256 schemaValue; schemaValue < totalSchemas; ) {\n            schemaBalances[schemaValue] = assetsReserves[comptroller][asset][Schema(schemaValue)];\n            totalBalance += schemaBalances[schemaValue];\n\n            unchecked {\n                ++schemaValue;\n            }\n        }\n\n        if (totalBalance == 0) {\n            return;\n        }\n\n        uint256[] memory totalTransferAmounts = new uint256[](totalSchemas);\n        for (uint256 i = 0; i < distributionTargets.length; ) {\n            DistributionConfig memory _config = distributionTargets[i];\n\n            uint256 transferAmount = (schemaBalances[uint256(_config.schema)] * _config.percentage) / MAX_PERCENT;\n            totalTransferAmounts[uint256(_config.schema)] += transferAmount;\n\n            IERC20Upgradeable(asset).safeTransfer(_config.destination, transferAmount);\n            IIncomeDestination(_config.destination).updateAssetsState(comptroller, asset);\n\n            emit AssetReleased(_config.destination, asset, _config.schema, _config.percentage, transferAmount);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256[] memory newSchemaBalances = new uint256[](totalSchemas);\n        for (uint256 schemaValue = 0; schemaValue < totalSchemas; ) {\n            newSchemaBalances[schemaValue] = schemaBalances[schemaValue] - totalTransferAmounts[schemaValue];\n            assetsReserves[comptroller][asset][Schema(schemaValue)] = newSchemaBalances[schemaValue];\n            totalAssetReserve[asset] = totalAssetReserve[asset] - totalTransferAmounts[schemaValue];\n\n            emit ReservesUpdated(\n                comptroller,\n                asset,\n                Schema(schemaValue),\n                schemaBalances[schemaValue],\n                newSchemaBalances[schemaValue]\n            );\n\n            unchecked {\n                ++schemaValue;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the schema based on comptroller, asset and income type\n     * @param comptroller  Comptroller address(pool)\n     * @param asset Asset address.\n     * @param incomeType type of income\n     * @return schema schema for distribution\n     */\n    function getSchema(\n        address comptroller,\n        address asset,\n        IncomeType incomeType\n    ) internal view returns (Schema schema) {\n        schema = Schema.DEFAULT;\n        address vToken = IPrime(prime).vTokenForAsset(asset);\n        if (vToken != address(0) && comptroller == CORE_POOL_COMPTROLLER && incomeType == IncomeType.SPREAD) {\n            schema = Schema.SPREAD_PRIME_CORE;\n        }\n    }\n\n    function _ensurePercentages() internal view {\n        uint256 totalSchemas = uint256(type(Schema).max) + 1;\n        uint256[] memory totalPercentages = new uint256[](totalSchemas);\n\n        for (uint256 i = 0; i < distributionTargets.length; ) {\n            DistributionConfig memory config = distributionTargets[i];\n            totalPercentages[uint256(config.schema)] += config.percentage;\n\n            unchecked {\n                ++i;\n            }\n        }\n        for (uint256 schemaValue = 0; schemaValue < totalSchemas; ) {\n            if (totalPercentages[schemaValue] != MAX_PERCENT && totalPercentages[schemaValue] != 0)\n                revert InvalidTotalPercentage();\n\n            unchecked {\n                ++schemaValue;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the underlying asset address for the vToken\n     * @param vToken vToken address\n     * @return asset address of asset\n     */\n    function _getUnderlying(address vToken) internal view returns (address) {\n        if (vToken == vBNB) {\n            return WBNB;\n        } else {\n            return IVToken(vToken).underlying();\n        }\n    }\n}\n"
    },
    "contracts/test/MockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    uint8 private immutable _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function faucet(uint256 amount) external {\n        _mint(msg.sender, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/test/MockVBNB.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VTokens/VToken.sol\";\n\n/**\n * @title Venus's vBNB Contract\n * @notice vToken which wraps BNB\n * @author Venus\n */\ncontract MockVBNB is VToken {\n    /**\n     * @notice Construct a new vBNB money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n    constructor(\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Send BNB to VBNB to mint\n     */\n    receive() external payable {\n        (uint err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Reverts upon any failure\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits Mint event\n    function mint() external payable {\n        (uint err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @dev Reverts upon any failure\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrow() external payable {\n        (uint err, ) = repayBorrowInternal(msg.value);\n        requireNoError(err, \"repayBorrow failed\");\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @dev Reverts upon any failure\n     * @param borrower The account with the debt being payed off\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrowBehalf(address borrower) external payable {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, msg.value);\n        requireNoError(err, \"repayBorrowBehalf failed\");\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev Reverts upon any failure\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     */\n    // @custom:event Emit LiquidateBorrow event on success\n    function liquidateBorrow(address borrower, VToken vTokenCollateral) external payable {\n        (uint err, ) = liquidateBorrowInternal(borrower, msg.value, vTokenCollateral);\n        requireNoError(err, \"liquidateBorrow failed\");\n    }\n\n    function setTotalReserves(uint totalReserves_) external payable {\n        totalReserves = totalReserves_;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Perform the actual transfer in, which is a no-op\n     * @param from Address sending the BNB\n     * @param amount Amount of BNB being sent\n     * @return The actual amount of BNB transferred\n     */\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\n        // Sanity checks\n        require(msg.sender == from, \"sender mismatch\");\n        require(msg.value == amount, \"value mismatch\");\n        return amount;\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        /* Send the BNB, with minimal gas and revert on failure */\n        to.transfer(amount);\n    }\n\n    /**\n     * @notice Gets balance of this contract in terms of BNB, before this message\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of BNB owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n        require(err == MathError.NO_ERROR, \"cash prior math error\");\n        return startingBalance;\n    }\n\n    function requireNoError(uint errCode, string memory message) internal pure {\n        if (errCode == uint(Error.NO_ERROR)) {\n            return;\n        }\n\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\n        uint i;\n\n        for (i = 0; i < bytes(message).length; i++) {\n            fullMessage[i] = bytes(message)[i];\n        }\n\n        fullMessage[i + 0] = bytes1(uint8(32));\n        fullMessage[i + 1] = bytes1(uint8(40));\n        fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 10)));\n        fullMessage[i + 3] = bytes1(uint8(48 + (errCode % 10)));\n        fullMessage[i + 4] = bytes1(uint8(41));\n\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _reduceReservesFresh(uint reduceAmount) internal override returns (uint) {\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(admin, reduceAmount);\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits ReservesReduced event\n    function _reduceReserves(uint reduceAmount) external override nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    // @custom:event Emits AccrueInterest event\n    function accrueInterest() public override returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            reservesPrior\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return uint(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/test/PrimeScenario.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport \"../Tokens/Prime/Prime.sol\";\n\ncontract PrimeScenario is Prime {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wbnb,\n        address _vbnb,\n        uint256 _blocksPerYear,\n        uint256 _stakingPeriod,\n        uint256 _minimumStakedXVS,\n        uint256 _maximumXVSCap,\n        bool _timeBased\n    ) Prime(_wbnb, _vbnb, _blocksPerYear, _stakingPeriod, _minimumStakedXVS, _maximumXVSCap, _timeBased) {}\n\n    function calculateScore(uint256 xvs, uint256 capital) external view returns (uint256) {\n        return Scores._calculateScore(xvs, capital, alphaNumerator, alphaDenominator);\n    }\n\n    function setPLP(address plp) external {\n        primeLiquidityProvider = plp;\n    }\n\n    function mintForUser(address user) external {\n        tokens[user] = Token(true, true);\n    }\n\n    function burnForUser(address user) external {\n        tokens[user] = Token(false, false);\n    }\n}\n"
    },
    "contracts/test/SimplePriceOracle.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport \"../Tokens/VTokens/VBep20.sol\";\n\ncontract SimplePriceOracle is ResilientOracleInterface {\n    mapping(address => uint) internal prices;\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n    function getUnderlyingPrice(address vToken) public view returns (uint) {\n        string memory symbol = VToken(vToken).symbol();\n        if (compareStrings(symbol, \"vBNB\")) {\n            return 1e18;\n        } else if (compareStrings(symbol, \"VAI\")) {\n            return prices[address(vToken)];\n        } else {\n            return prices[address(VBep20(address(vToken)).underlying())];\n        }\n    }\n\n    function getPrice(address asset) external view returns (uint256) {\n        return prices[asset];\n    }\n\n    function updatePrice(address vToken) external {}\n\n    function updateAssetPrice(address asset) external {}\n\n    function setUnderlyingPrice(VToken vToken, uint underlyingPriceMantissa) public {\n        address asset = address(VBep20(address(vToken)).underlying());\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n        prices[asset] = underlyingPriceMantissa;\n    }\n\n    function setDirectPrice(address asset, uint price) public {\n        emit PricePosted(asset, prices[asset], price, price);\n        prices[asset] = price;\n    }\n\n    // v1 price oracle interface for use as backing of proxy\n    function assetPrices(address asset) external view returns (uint) {\n        return prices[asset];\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/test/VAIControllerHarness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VAI/VAIController.sol\";\n\ncontract VAIControllerHarness is VAIController {\n    uint public blockNumber;\n    uint public blocksPerYear;\n\n    constructor() VAIController() {\n        admin = msg.sender;\n    }\n\n    function setVenusVAIState(uint224 index, uint32 blockNumber_) public {\n        venusVAIState.index = index;\n        venusVAIState.block = blockNumber_;\n    }\n\n    function setVAIAddress(address vaiAddress_) public {\n        vai = vaiAddress_;\n    }\n\n    function getVAIAddress() public view override returns (address) {\n        return vai;\n    }\n\n    function harnessRepayVAIFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayVAIFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateVAIFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateVAIFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessFastForward(uint blocks) public returns (uint) {\n        blockNumber += blocks;\n        return blockNumber;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function setBlockNumber(uint number) public {\n        blockNumber = number;\n    }\n\n    function setBlocksPerYear(uint number) public {\n        blocksPerYear = number;\n    }\n\n    function getBlockNumber() internal view override returns (uint) {\n        return blockNumber;\n    }\n\n    function getBlocksPerYear() public view override returns (uint) {\n        return blocksPerYear;\n    }\n}\n"
    },
    "contracts/test/VBep20Harness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VTokens/VBep20Immutable.sol\";\nimport \"../Tokens/VTokens/VBep20Delegator.sol\";\nimport \"../Tokens/VTokens/VBep20Delegate.sol\";\nimport \"./ComptrollerScenario.sol\";\n\ncontract VBep20Harness is VBep20Immutable {\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        return super.doTransferOut(to, amount);\n    }\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, msg.sender, amount);\n    }\n}\n\ncontract VBep20Scenario is VBep20Immutable {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\ncontract VEvil is VBep20Scenario {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Scenario(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function evilSeize(VToken treasure, address liquidator, address borrower, uint seizeTokens) public returns (uint) {\n        return treasure.seize(liquidator, borrower, seizeTokens);\n    }\n}\n\ncontract VBep20DelegatorScenario is VBep20Delegator {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address implementation_,\n        bytes memory becomeImplementationData\n    )\n        VBep20Delegator(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_,\n            implementation_,\n            becomeImplementationData\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n}\n\ncontract VBep20DelegateHarness is VBep20Delegate {\n    event Log(string x, address y);\n    event Log(string x, uint y);\n\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        return super.doTransferOut(to, amount);\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\n        totalBorrows = totalBorrows + addtlBorrow_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, msg.sender, amount);\n    }\n}\n\ncontract VBep20DelegateScenario is VBep20Delegate {\n    constructor() {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\ncontract VBep20DelegateScenarioExtra is VBep20DelegateScenario {\n    function iHaveSpoken() public pure returns (string memory) {\n        return \"i have spoken\";\n    }\n\n    function itIsTheWay() public {\n        admin = payable(address(1)); // make a change to test effect\n    }\n\n    function babyYoda() public pure {\n        revert(\"protect the baby\");\n    }\n}\n"
    },
    "contracts/test/VBep20MockDelegate.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { InterestRateModelV8 } from \"../InterestRateModels/InterestRateModelV8.sol\";\nimport { VBep20Interface, VTokenInterface } from \"../Tokens/VTokens/VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20 Contract\n * @notice VTokens which wrap an EIP-20 underlying\n * @author Venus\n */\ncontract VBep20MockDelegate is VToken, VBep20Interface {\n    using SafeERC20 for IERC20;\n\n    uint internal blockNumber = 100000;\n\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        // VToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) public {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() public {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err, ) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param receiver the account which is receiving the vTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\n        (uint err, ) = mintBehalfInternal(receiver, mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint) {\n        (uint err, ) = liquidateBorrowInternal(borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard BEP-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\n        IERC20 token = IERC20(underlying);\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard BEP-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal override {\n        IERC20 token = IERC20(underlying);\n        token.safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/Tokens/Prime/Interfaces/InterfaceComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\ninterface InterfaceComptroller {\n    function markets(address) external view returns (bool);\n}\n"
    },
    "contracts/Tokens/Prime/Interfaces/IPoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\n/**\n * @title PoolRegistryInterface\n * @author Venus\n * @notice Interface implemented by `PoolRegistry`.\n */\ninterface PoolRegistryInterface {\n    /**\n     * @notice Struct for a Venus interest rate pool.\n     */\n    struct VenusPool {\n        string name;\n        address creator;\n        address comptroller;\n        uint256 blockPosted;\n        uint256 timestampPosted;\n    }\n\n    /// @notice Get a pool by comptroller address\n    function getPoolByComptroller(address comptroller) external view returns (VenusPool memory);\n}\n"
    },
    "contracts/Tokens/Prime/Interfaces/IPrime.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport { PrimeStorageV1 } from \"../PrimeStorage.sol\";\n\n/**\n * @title IPrime\n * @author Venus\n * @notice Interface for Prime Token\n */\ninterface IPrime {\n    struct APRInfo {\n        // supply APR of the user in BPS\n        uint256 supplyAPR;\n        // borrow APR of the user in BPS\n        uint256 borrowAPR;\n        // total score of the market\n        uint256 totalScore;\n        // score of the user\n        uint256 userScore;\n        // capped XVS balance of the user\n        uint256 xvsBalanceForScore;\n        // capital of the user\n        uint256 capital;\n        // capped supply of the user\n        uint256 cappedSupply;\n        // capped borrow of the user\n        uint256 cappedBorrow;\n        // capped supply of user in USD\n        uint256 supplyCapUSD;\n        // capped borrow of user in USD\n        uint256 borrowCapUSD;\n    }\n\n    struct Capital {\n        // capital of the user\n        uint256 capital;\n        // capped supply of the user\n        uint256 cappedSupply;\n        // capped borrow of the user\n        uint256 cappedBorrow;\n        // capped supply of user in USD\n        uint256 supplyCapUSD;\n        // capped borrow of user in USD\n        uint256 borrowCapUSD;\n    }\n\n    /**\n     * @notice Returns boosted pending interest accrued for a user for all markets\n     * @param user the account for which to get the accrued interests\n     * @return pendingRewards the number of underlying tokens accrued by the user for all markets\n     */\n    function getPendingRewards(address user) external returns (PrimeStorageV1.PendingReward[] memory pendingRewards);\n\n    /**\n     * @notice Update total score of multiple users and market\n     * @param users accounts for which we need to update score\n     */\n    function updateScores(address[] memory users) external;\n\n    /**\n     * @notice Update value of alpha\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     */\n    function updateAlpha(uint128 _alphaNumerator, uint128 _alphaDenominator) external;\n\n    /**\n     * @notice Update multipliers for a market\n     * @param market address of the market vToken\n     * @param supplyMultiplier new supply multiplier for the market, scaled by 1e18\n     * @param borrowMultiplier new borrow multiplier for the market, scaled by 1e18\n     */\n    function updateMultipliers(address market, uint256 supplyMultiplier, uint256 borrowMultiplier) external;\n\n    /**\n     * @notice Add a market to prime program\n     * @param comptroller address of the comptroller\n     * @param market address of the market vToken\n     * @param supplyMultiplier the multiplier for supply cap. It should be converted to 1e18\n     * @param borrowMultiplier the multiplier for borrow cap. It should be converted to 1e18\n     */\n    function addMarket(\n        address comptroller,\n        address market,\n        uint256 supplyMultiplier,\n        uint256 borrowMultiplier\n    ) external;\n\n    /**\n     * @notice Set limits for total tokens that can be minted\n     * @param _irrevocableLimit total number of irrevocable tokens that can be minted\n     * @param _revocableLimit total number of revocable tokens that can be minted\n     */\n    function setLimit(uint256 _irrevocableLimit, uint256 _revocableLimit) external;\n\n    /**\n     * @notice Directly issue prime tokens to users\n     * @param isIrrevocable are the tokens being issued\n     * @param users list of address to issue tokens to\n     */\n    function issue(bool isIrrevocable, address[] calldata users) external;\n\n    /**\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\n     * @param user the account address whose balance was updated\n     */\n    function xvsUpdated(address user) external;\n\n    /**\n     * @notice accrues interest and updates score for an user for a specific market\n     * @param user the account address for which to accrue interest and update score\n     * @param market the market for which to accrue interest and update score\n     */\n    function accrueInterestAndUpdateScore(address user, address market) external;\n\n    /**\n     * @notice For claiming prime token when staking period is completed\n     */\n    function claim() external;\n\n    /**\n     * @notice For burning any prime token\n     * @param user the account address for which the prime token will be burned\n     */\n    function burn(address user) external;\n\n    /**\n     * @notice To pause or unpause claiming of interest\n     */\n    function togglePause() external;\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function claimInterest(address vToken) external returns (uint256);\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     * @param user the user for which to claim the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function claimInterest(address vToken, address user) external returns (uint256);\n\n    /**\n     * @notice Distributes income from market since last distribution\n     * @param vToken the market for which to distribute the income\n     */\n    function accrueInterest(address vToken) external;\n\n    /**\n     * @notice Returns boosted interest accrued for a user\n     * @param vToken the market for which to fetch the accrued interest\n     * @param user the account for which to get the accrued interest\n     * @return interestAccrued the number of underlying tokens accrued by the user since the last accrual\n     */\n    function getInterestAccrued(address vToken, address user) external returns (uint256);\n\n    /**\n     * @notice Retrieves an array of all available markets\n     * @return an array of addresses representing all available markets\n     */\n    function getAllMarkets() external view returns (address[] memory);\n\n    /**\n     * @notice fetch the numbers of seconds remaining for staking period to complete\n     * @param user the account address for which we are checking the remaining time\n     * @return timeRemaining the number of seconds the user needs to wait to claim prime token\n     */\n    function claimTimeRemaining(address user) external view returns (uint256);\n\n    /**\n     * @notice Returns supply and borrow APR for user for a given market\n     * @param market the market for which to fetch the APR\n     * @param user the account for which to get the APR\n     * @return aprInfo APR information for the user for the given market\n     */\n    function calculateAPR(address market, address user) external view returns (APRInfo memory aprInfo);\n\n    /**\n     * @notice Returns supply and borrow APR for estimated supply, borrow and XVS staked\n     * @param market the market for which to fetch the APR\n     * @param user the account for which to get the APR\n     * @param borrow hypothetical borrow amount\n     * @param supply hypothetical supply amount\n     * @param xvsStaked hypothetical staked XVS amount\n     * @return aprInfo APR information for the user for the given market\n     */\n    function estimateAPR(\n        address market,\n        address user,\n        uint256 borrow,\n        uint256 supply,\n        uint256 xvsStaked\n    ) external view returns (APRInfo memory aprInfo);\n\n    /**\n     * @notice the total income that's going to be distributed in a year to prime token holders\n     * @param vToken the market for which to fetch the total income that's going to distributed in a year\n     * @return amount the total income\n     */\n    function incomeDistributionYearly(address vToken) external view returns (uint256 amount);\n\n    /**\n     * @notice Returns if user is a prime holder\n     * @return isPrimeHolder true if user is a prime holder\n     */\n    function isUserPrimeHolder(address user) external view returns (bool);\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param loopsLimit Number of loops limit\n     */\n    function setMaxLoopsLimit(uint256 loopsLimit) external;\n\n    /**\n     * @notice Update staked at timestamp for multiple users\n     * @param users accounts for which we need to update staked at timestamp\n     * @param timestamps new staked at timestamp for the users\n     */\n    function setStakedAt(address[] calldata users, uint256[] calldata timestamps) external;\n}\n"
    },
    "contracts/Tokens/Prime/Interfaces/IPrimeLiquidityProvider.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title IPrimeLiquidityProvider\n * @author Venus\n * @notice Interface for PrimeLiquidityProvider\n */\ninterface IPrimeLiquidityProvider {\n    /**\n     * @notice Initialize the distribution of the token\n     * @param tokens_ Array of addresses of the tokens to be intialized\n     */\n    function initializeTokens(address[] calldata tokens_) external;\n\n    /**\n     * @notice Pause fund transfer of tokens to Prime contract\n     */\n    function pauseFundsTransfer() external;\n\n    /**\n     * @notice Resume fund transfer of tokens to Prime contract\n     */\n    function resumeFundsTransfer() external;\n\n    /**\n     * @notice Set distribution speed (amount of token distribute per block or second)\n     * @param tokens_ Array of addresses of the tokens\n     * @param distributionSpeeds_ New distribution speeds for tokens\n     */\n    function setTokensDistributionSpeed(address[] calldata tokens_, uint256[] calldata distributionSpeeds_) external;\n\n    /**\n     * @notice Set max distribution speed for token (amount of maximum token distribute per block or second)\n     * @param tokens_ Array of addresses of the tokens\n     * @param maxDistributionSpeeds_ New distribution speeds for tokens\n     */\n    function setMaxTokensDistributionSpeed(\n        address[] calldata tokens_,\n        uint256[] calldata maxDistributionSpeeds_\n    ) external;\n\n    /**\n     * @notice Set the prime token contract address\n     * @param prime_ The new address of the prime token contract\n     */\n    function setPrimeToken(address prime_) external;\n\n    /**\n     * @notice Claim all the token accrued till last block or second\n     * @param token_ The token to release to the Prime contract\n     */\n    function releaseFunds(address token_) external;\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to user\n     * @param token_ The address of the ERC-20 token to sweep\n     * @param to_ The address of the recipient\n     * @param amount_ The amount of tokens needs to transfer\n     */\n    function sweepToken(IERC20Upgradeable token_, address to_, uint256 amount_) external;\n\n    /**\n     * @notice Accrue token by updating the distribution state\n     * @param token_ Address of the token\n     */\n    function accrueTokens(address token_) external;\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param loopsLimit Limit for the max loops can execute at a time\n     */\n    function setMaxLoopsLimit(uint256 loopsLimit) external;\n\n    /**\n     * @notice Get rewards per block or second for token\n     * @param token_ Address of the token\n     * @return speed returns the per block or second reward\n     */\n    function getEffectiveDistributionSpeed(address token_) external view returns (uint256);\n\n    /**\n     * @notice Get the amount of tokens accrued\n     * @param token_ Address of the token\n     * @return Amount of tokens that are accrued\n     */\n    function tokenAmountAccrued(address token_) external view returns (uint256);\n}\n"
    },
    "contracts/Tokens/Prime/Interfaces/IVToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\ninterface IVToken {\n    function borrowBalanceStored(address account) external view returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function totalBorrows() external view returns (uint256);\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Tokens/Prime/Interfaces/IXVSVault.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\ninterface IXVSVault {\n    function getUserInfo(\n        address _rewardToken,\n        uint256 _pid,\n        address _user\n    ) external view returns (uint256 amount, uint256 rewardDebt, uint256 pendingWithdrawals);\n\n    function xvsAddress() external view returns (address);\n}\n"
    },
    "contracts/Tokens/Prime/IPrime.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title IPrime\n * @author Venus\n * @notice Interface for Prime Token\n */\ninterface IPrime {\n    /**\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\n     * @param user the account address whose balance was updated\n     */\n    function xvsUpdated(address user) external;\n\n    /**\n     * @notice accrues interest and updates score for an user for a specific market\n     * @param user the account address for which to accrue interest and update score\n     * @param market the market for which to accrue interest and update score\n     */\n    function accrueInterestAndUpdateScore(address user, address market) external;\n\n    /**\n     * @notice Distributes income from market since last distribution\n     * @param vToken the market for which to distribute the income\n     */\n    function accrueInterest(address vToken) external;\n\n    /**\n     * @notice Returns if user is a prime holder\n     * @param isPrimeHolder returns if the user is a prime holder\n     */\n    function isUserPrimeHolder(address user) external view returns (bool isPrimeHolder);\n}\n"
    },
    "contracts/Tokens/Prime/libs/FixedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.8.25;\n\nimport { SafeCastUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport { FixedMath0x } from \"./FixedMath0x.sol\";\n\nusing SafeCastUpgradeable for uint256;\n\nerror InvalidFixedPoint();\n\n/**\n * @title FixedMath\n * @author Venus\n * @notice FixedMath library is used for complex mathematical operations\n */\nlibrary FixedMath {\n    error InvalidFraction(uint256 n, uint256 d);\n\n    /**\n     * @notice Convert some uint256 fraction `n` numerator / `d` denominator to a fixed-point number `f`.\n     * @param n numerator\n     * @param d denominator\n     * @return fixed-point number\n     */\n    function _toFixed(uint256 n, uint256 d) internal pure returns (int256) {\n        if (d.toInt256() < n.toInt256()) revert InvalidFraction(n, d);\n\n        return (n.toInt256() * FixedMath0x.FIXED_1) / int256(d.toInt256());\n    }\n\n    /**\n     * @notice Divide some unsigned int `u` by a fixed point number `f`\n     * @param u unsigned dividend\n     * @param f fixed point divisor, in FIXED_1 units\n     * @return unsigned int quotient\n     */\n    function _uintDiv(uint256 u, int256 f) internal pure returns (uint256) {\n        if (f < 0) revert InvalidFixedPoint();\n        // multiply `u` by FIXED_1 to cancel out the built-in FIXED_1 in f\n        return uint256((u.toInt256() * FixedMath0x.FIXED_1) / f);\n    }\n\n    /**\n     * @notice Multiply some unsigned int `u` by a fixed point number `f`\n     * @param u unsigned multiplicand\n     * @param f fixed point multiplier, in FIXED_1 units\n     * @return unsigned int product\n     */\n    function _uintMul(uint256 u, int256 f) internal pure returns (uint256) {\n        if (f < 0) revert InvalidFixedPoint();\n        // divide the product by FIXED_1 to cancel out the built-in FIXED_1 in f\n        return uint256((u.toInt256() * f) / FixedMath0x.FIXED_1);\n    }\n\n    /// @notice see FixedMath0x\n    function _ln(int256 x) internal pure returns (int256) {\n        return FixedMath0x._ln(x);\n    }\n\n    /// @notice see FixedMath0x\n    function _exp(int256 x) internal pure returns (int256) {\n        return FixedMath0x._exp(x);\n    }\n}\n"
    },
    "contracts/Tokens/Prime/libs/FixedMath0x.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable max-line-length\n\npragma solidity 0.8.25;\n\n// Below is code from 0x's LibFixedMath.sol. Changes:\n// - addition of 0.8-style errors\n// - removal of unused functions\n// - added comments for clarity\n// https://github.com/0xProject/exchange-v3/blob/aae46bef841bfd1cc31028f41793db4fe7197084/contracts/staking/contracts/src/libs/LibFixedMath.sol\n\n/*\n\n  Copyright 2017 Bprotocol Foundation, 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n/// Thrown when the natural log function is given too large of an argument\nerror LnTooLarge(int256 x);\n/// Thrown when the natural log would have returned a number outside of ℝ\nerror LnNonRealResult(int256 x);\n/// Thrown when exp is given too large of an argument\nerror ExpTooLarge(int256 x);\n/// Thrown when an unsigned value is too large to be converted to a signed value\nerror UnsignedValueTooLarge(uint256 x);\n\n/**\n * @title FixedMath0x\n * @notice Signed, fixed-point, 127-bit precision math library\n */\nlibrary FixedMath0x {\n    // Base for the fixed point numbers (this is our 1)\n    int256 internal constant FIXED_1 = int256(0x0000000000000000000000000000000080000000000000000000000000000000);\n    // Maximum ln argument (1)\n    int256 private constant LN_MAX_VAL = FIXED_1;\n    // Minimum ln argument. Notice this is related to EXP_MIN_VAL (e ^ -63.875)\n    int256 private constant LN_MIN_VAL = int256(0x0000000000000000000000000000000000000000000000000000000733048c5a);\n    // Maximum exp argument (0)\n    int256 private constant EXP_MAX_VAL = 0;\n    // Minimum exp argument. Notice this is related to LN_MIN_VAL (-63.875)\n    int256 private constant EXP_MIN_VAL = -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n\n    /// @dev Get the natural logarithm of a fixed-point number 0 < `x` <= LN_MAX_VAL\n    function _ln(int256 x) internal pure returns (int256 r) {\n        if (x > LN_MAX_VAL) {\n            revert LnTooLarge(x);\n        }\n        if (x <= 0) {\n            revert LnNonRealResult(x);\n        }\n        if (x == FIXED_1) {\n            return 0;\n        }\n        if (x <= LN_MIN_VAL) {\n            return EXP_MIN_VAL;\n        }\n\n        int256 y;\n        int256 z;\n        int256 w;\n\n        // Rewrite the input as a quotient of negative natural exponents and a single residual q, such that 1 < q < 2\n        // For example: log(0.3) = log(e^-1 * e^-0.25 * 1.0471028872385522)\n        //              = 1 - 0.25 - log(1 + 0.0471028872385522)\n        // e ^ -32\n        if (x <= int256(0x00000000000000000000000000000000000000000001c8464f76164760000000)) {\n            r -= int256(0x0000000000000000000000000000001000000000000000000000000000000000); // - 32\n            x = (x * FIXED_1) / int256(0x00000000000000000000000000000000000000000001c8464f76164760000000); // / e ^ -32\n        }\n        // e ^ -16\n        if (x <= int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000)) {\n            r -= int256(0x0000000000000000000000000000000800000000000000000000000000000000); // - 16\n            x = (x * FIXED_1) / int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000); // / e ^ -16\n        }\n        // e ^ -8\n        if (x <= int256(0x00000000000000000000000000000000000afe10820813d78000000000000000)) {\n            r -= int256(0x0000000000000000000000000000000400000000000000000000000000000000); // - 8\n            x = (x * FIXED_1) / int256(0x00000000000000000000000000000000000afe10820813d78000000000000000); // / e ^ -8\n        }\n        // e ^ -4\n        if (x <= int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000)) {\n            r -= int256(0x0000000000000000000000000000000200000000000000000000000000000000); // - 4\n            x = (x * FIXED_1) / int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000); // / e ^ -4\n        }\n        // e ^ -2\n        if (x <= int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000)) {\n            r -= int256(0x0000000000000000000000000000000100000000000000000000000000000000); // - 2\n            x = (x * FIXED_1) / int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000); // / e ^ -2\n        }\n        // e ^ -1\n        if (x <= int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000)) {\n            r -= int256(0x0000000000000000000000000000000080000000000000000000000000000000); // - 1\n            x = (x * FIXED_1) / int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000); // / e ^ -1\n        }\n        // e ^ -0.5\n        if (x <= int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000)) {\n            r -= int256(0x0000000000000000000000000000000040000000000000000000000000000000); // - 0.5\n            x = (x * FIXED_1) / int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000); // / e ^ -0.5\n        }\n        // e ^ -0.25\n        if (x <= int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000)) {\n            r -= int256(0x0000000000000000000000000000000020000000000000000000000000000000); // - 0.25\n            x = (x * FIXED_1) / int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000); // / e ^ -0.25\n        }\n        // e ^ -0.125\n        if (x <= int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) {\n            r -= int256(0x0000000000000000000000000000000010000000000000000000000000000000); // - 0.125\n            x = (x * FIXED_1) / int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d); // / e ^ -0.125\n        }\n        // `x` is now our residual in the range of 1 <= x <= 2 (or close enough).\n\n        // Add the taylor series for log(1 + z), where z = x - 1\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        r += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\n        r += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\n        r += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\n        r += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\n        r += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\n        r += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\n        r += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\n        r += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\n    }\n\n    /// @dev Compute the natural exponent for a fixed-point number EXP_MIN_VAL <= `x` <= 1\n    function _exp(int256 x) internal pure returns (int256 r) {\n        if (x < EXP_MIN_VAL) {\n            // Saturate to zero below EXP_MIN_VAL.\n            return 0;\n        }\n        if (x == 0) {\n            return FIXED_1;\n        }\n        if (x > EXP_MAX_VAL) {\n            revert ExpTooLarge(x);\n        }\n\n        // Rewrite the input as a product of natural exponents and a\n        // single residual q, where q is a number of small magnitude.\n        // For example: e^-34.419 = e^(-32 - 2 - 0.25 - 0.125 - 0.044)\n        //              = e^-32 * e^-2 * e^-0.25 * e^-0.125 * e^-0.044\n        //              -> q = -0.044\n\n        // Multiply with the taylor series for e^q\n        int256 y;\n        int256 z;\n        // q = x % 0.125 (the residual)\n        z = y = x % 0x0000000000000000000000000000000010000000000000000000000000000000;\n        z = (z * y) / FIXED_1;\n        r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        // Multiply with the non-residual terms.\n        x = -x;\n        // e ^ -32\n        if ((x & int256(0x0000000000000000000000000000001000000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x00000000000000000000000000000000000000f1aaddd7742e56d32fb9f99744)) /\n                int256(0x0000000000000000000000000043cbaf42a000812488fc5c220ad7b97bf6e99e); // * e ^ -32\n        }\n        // e ^ -16\n        if ((x & int256(0x0000000000000000000000000000000800000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x00000000000000000000000000000000000afe10820813d65dfe6a33c07f738f)) /\n                int256(0x000000000000000000000000000005d27a9f51c31b7c2f8038212a0574779991); // * e ^ -16\n        }\n        // e ^ -8\n        if ((x & int256(0x0000000000000000000000000000000400000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x0000000000000000000000000000000002582ab704279e8efd15e0265855c47a)) /\n                int256(0x0000000000000000000000000000001b4c902e273a58678d6d3bfdb93db96d02); // * e ^ -8\n        }\n        // e ^ -4\n        if ((x & int256(0x0000000000000000000000000000000200000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x000000000000000000000000000000001152aaa3bf81cb9fdb76eae12d029571)) /\n                int256(0x00000000000000000000000000000003b1cc971a9bb5b9867477440d6d157750); // * e ^ -4\n        }\n        // e ^ -2\n        if ((x & int256(0x0000000000000000000000000000000100000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x000000000000000000000000000000002f16ac6c59de6f8d5d6f63c1482a7c86)) /\n                int256(0x000000000000000000000000000000015bf0a8b1457695355fb8ac404e7a79e3); // * e ^ -2\n        }\n        // e ^ -1\n        if ((x & int256(0x0000000000000000000000000000000080000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x000000000000000000000000000000004da2cbf1be5827f9eb3ad1aa9866ebb3)) /\n                int256(0x00000000000000000000000000000000d3094c70f034de4b96ff7d5b6f99fcd8); // * e ^ -1\n        }\n        // e ^ -0.5\n        if ((x & int256(0x0000000000000000000000000000000040000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x0000000000000000000000000000000063afbe7ab2082ba1a0ae5e4eb1b479dc)) /\n                int256(0x00000000000000000000000000000000a45af1e1f40c333b3de1db4dd55f29a7); // * e ^ -0.5\n        }\n        // e ^ -0.25\n        if ((x & int256(0x0000000000000000000000000000000020000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) /\n                int256(0x00000000000000000000000000000000910b022db7ae67ce76b441c27035c6a1); // * e ^ -0.25\n        }\n        // e ^ -0.125\n        if ((x & int256(0x0000000000000000000000000000000010000000000000000000000000000000)) != 0) {\n            r =\n                (r * int256(0x00000000000000000000000000000000783eafef1c0a8f3978c7f81824d62ebf)) /\n                int256(0x0000000000000000000000000000000088415abbe9a76bead8d00cf112e4d4a8); // * e ^ -0.125\n        }\n    }\n}\n"
    },
    "contracts/Tokens/Prime/libs/Scores.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { SafeCastUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport { FixedMath } from \"./FixedMath.sol\";\n\nusing SafeCastUpgradeable for uint256;\n\n/**\n * @title Scores\n * @author Venus\n * @notice Scores library is used to calculate score of users\n */\nlibrary Scores {\n    /**\n     * @notice Calculate a membership score given some amount of `xvs` and `capital`, along\n     *  with some 𝝰 = `alphaNumerator` / `alphaDenominator`.\n     * @param xvs amount of xvs (xvs, 1e18 decimal places)\n     * @param capital amount of capital (1e18 decimal places)\n     * @param alphaNumerator alpha param numerator\n     * @param alphaDenominator alpha param denominator\n     * @return membership score with 1e18 decimal places\n     *\n     * @dev 𝝰 must be in the range [0, 1]\n     */\n    function _calculateScore(\n        uint256 xvs,\n        uint256 capital,\n        uint256 alphaNumerator,\n        uint256 alphaDenominator\n    ) internal pure returns (uint256) {\n        // Score function is:\n        // xvs^𝝰 * capital^(1-𝝰)\n        //    = capital * capital^(-𝝰) * xvs^𝝰\n        //    = capital * (xvs / capital)^𝝰\n        //    = capital * (e ^ (ln(xvs / capital))) ^ 𝝰\n        //    = capital * e ^ (𝝰 * ln(xvs / capital))     (1)\n        // or\n        //    = capital / ( 1 / e ^ (𝝰 * ln(xvs / capital)))\n        //    = capital / (e ^ (𝝰 * ln(xvs / capital)) ^ -1)\n        //    = capital / e ^ (𝝰 * -1 * ln(xvs / capital))\n        //    = capital / e ^ (𝝰 * ln(capital / xvs))     (2)\n        //\n        // To avoid overflows, use (1) when xvs < capital and\n        // use (2) when capital < xvs\n\n        // If any side is 0, exit early\n        if (xvs == 0 || capital == 0) return 0;\n\n        // If both sides are equal, we have:\n        // xvs^𝝰 * capital^(1-𝝰)\n        //    = xvs^𝝰 * xvs^(1-𝝰)\n        //    = xvs^(𝝰 + 1 - 𝝰)     = xvs\n        if (xvs == capital) return xvs;\n\n        bool lessxvsThanCapital = xvs < capital;\n\n        // (xvs / capital) or (capital / xvs), always in range (0, 1)\n        int256 ratio = lessxvsThanCapital ? FixedMath._toFixed(xvs, capital) : FixedMath._toFixed(capital, xvs);\n\n        // e ^ ( ln(ratio) * 𝝰 )\n        int256 exponentiation = FixedMath._exp(\n            (FixedMath._ln(ratio) * alphaNumerator.toInt256()) / alphaDenominator.toInt256()\n        );\n\n        if (lessxvsThanCapital) {\n            // capital * e ^ (𝝰 * ln(xvs / capital))\n            return FixedMath._uintMul(capital, exponentiation);\n        }\n\n        // capital / e ^ (𝝰 * ln(capital / xvs))\n        return FixedMath._uintDiv(capital, exponentiation);\n    }\n}\n"
    },
    "contracts/Tokens/Prime/Prime.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { SafeERC20Upgradeable, IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { MaxLoopsLimitHelper } from \"@venusprotocol/solidity-utilities/contracts/MaxLoopsLimitHelper.sol\";\nimport { TimeManagerV8 } from \"@venusprotocol/solidity-utilities/contracts/TimeManagerV8.sol\";\n\nimport { IERC20MetadataUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport { PrimeStorageV1 } from \"./PrimeStorage.sol\";\nimport { Scores } from \"./libs/Scores.sol\";\n\nimport { IPrimeLiquidityProvider } from \"./Interfaces/IPrimeLiquidityProvider.sol\";\nimport { IPrime } from \"./Interfaces/IPrime.sol\";\nimport { IXVSVault } from \"./Interfaces/IXVSVault.sol\";\nimport { IVToken } from \"./Interfaces/IVToken.sol\";\nimport { InterfaceComptroller } from \"./Interfaces/InterfaceComptroller.sol\";\nimport { PoolRegistryInterface } from \"./Interfaces/IPoolRegistry.sol\";\n\n/**\n * @title Prime\n * @author Venus\n * @notice Prime Token is used to provide extra rewards to the users who have staked a minimum of `MINIMUM_STAKED_XVS` XVS in the XVSVault for `STAKING_PERIOD` days\n * @custom:security-contact https://github.com/VenusProtocol/venus-protocol\n */\ncontract Prime is IPrime, AccessControlledV8, PausableUpgradeable, MaxLoopsLimitHelper, PrimeStorageV1, TimeManagerV8 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice address of wrapped native token contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WRAPPED_NATIVE_TOKEN;\n\n    /// @notice address of native market contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable NATIVE_MARKET;\n\n    /// @notice minimum amount of XVS user needs to stake to become a prime member\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable MINIMUM_STAKED_XVS;\n\n    /// @notice maximum XVS taken in account when calculating user score\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable MAXIMUM_XVS_CAP;\n\n    /// @notice number of days user need to stake to claim prime token\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable STAKING_PERIOD;\n\n    /// @notice Emitted when prime token is minted\n    event Mint(address indexed user, bool isIrrevocable);\n\n    /// @notice Emitted when prime token is burned\n    event Burn(address indexed user);\n\n    /// @notice Emitted when a market is added to prime program\n    event MarketAdded(\n        address indexed comptroller,\n        address indexed market,\n        uint256 supplyMultiplier,\n        uint256 borrowMultiplier\n    );\n\n    /// @notice Emitted when mint limits are updated\n    event MintLimitsUpdated(\n        uint256 indexed oldIrrevocableLimit,\n        uint256 indexed oldRevocableLimit,\n        uint256 indexed newIrrevocableLimit,\n        uint256 newRevocableLimit\n    );\n\n    /// @notice Emitted when user score is updated\n    event UserScoreUpdated(address indexed user);\n\n    /// @notice Emitted when alpha is updated\n    event AlphaUpdated(\n        uint128 indexed oldNumerator,\n        uint128 indexed oldDenominator,\n        uint128 indexed newNumerator,\n        uint128 newDenominator\n    );\n\n    /// @notice Emitted when multiplier is updated\n    event MultiplierUpdated(\n        address indexed market,\n        uint256 indexed oldSupplyMultiplier,\n        uint256 indexed oldBorrowMultiplier,\n        uint256 newSupplyMultiplier,\n        uint256 newBorrowMultiplier\n    );\n\n    /// @notice Emitted when interest is claimed\n    event InterestClaimed(address indexed user, address indexed market, uint256 amount);\n\n    /// @notice Emitted when revocable token is upgraded to irrevocable token\n    event TokenUpgraded(address indexed user);\n\n    /// @notice Emitted when stakedAt is updated\n    event StakedAtUpdated(address indexed user, uint256 timestamp);\n\n    /// @notice Error thrown when market is not supported\n    error MarketNotSupported();\n\n    /// @notice Error thrown when mint limit is reached\n    error InvalidLimit();\n\n    /// @notice Error thrown when user is not eligible to claim prime token\n    error IneligibleToClaim();\n\n    /// @notice Error thrown when user needs to wait more time to claim prime token\n    error WaitMoreTime();\n\n    /// @notice Error thrown when user has no prime token\n    error UserHasNoPrimeToken();\n\n    /// @notice Error thrown when no score updates are required\n    error NoScoreUpdatesRequired();\n\n    /// @notice Error thrown when market already exists\n    error MarketAlreadyExists();\n\n    /// @notice Error thrown when asset already exists\n    error AssetAlreadyExists();\n\n    /// @notice Error thrown when invalid address is passed\n    error InvalidAddress();\n\n    /// @notice Error thrown when invalid alpha arguments are passed\n    error InvalidAlphaArguments();\n\n    /// @notice Error thrown when invalid vToken is passed\n    error InvalidVToken();\n\n    /// @notice Error thrown when invalid length is passed\n    error InvalidLength();\n\n    /// @notice Error thrown when timestamp is invalid\n    error InvalidTimestamp();\n\n    /// @notice Error thrown when invalid comptroller is passed\n    error InvalidComptroller();\n\n    /**\n     * @notice Prime constructor\n     * @param _wrappedNativeToken Address of wrapped native token\n     * @param _nativeMarket Address of native market\n     * @param _blocksPerYear total blocks per year\n     * @param _stakingPeriod total number of seconds for which user needs to stake to claim prime token\n     * @param _minimumStakedXVS minimum amount of XVS user needs to stake to become a prime member (scaled by 1e18)\n     * @param _maximumXVSCap maximum XVS taken in account when calculating user score (scaled by 1e18)\n     * @param _timeBased A boolean indicating whether the contract is based on time or block.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeToken,\n        address _nativeMarket,\n        uint256 _blocksPerYear,\n        uint256 _stakingPeriod,\n        uint256 _minimumStakedXVS,\n        uint256 _maximumXVSCap,\n        bool _timeBased\n    ) TimeManagerV8(_timeBased, _blocksPerYear) {\n        WRAPPED_NATIVE_TOKEN = _wrappedNativeToken;\n        NATIVE_MARKET = _nativeMarket;\n        STAKING_PERIOD = _stakingPeriod;\n        MINIMUM_STAKED_XVS = _minimumStakedXVS;\n        MAXIMUM_XVS_CAP = _maximumXVSCap;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Prime initializer\n     * @param xvsVault_ Address of XVSVault\n     * @param xvsVaultRewardToken_ Address of XVSVault reward token\n     * @param xvsVaultPoolId_ Pool id of XVSVault\n     * @param alphaNumerator_ numerator of alpha. If alpha is 0.5 then numerator is 1.\n              alphaDenominator_ must be greater than alphaNumerator_, alphaDenominator_ cannot be zero and alphaNumerator_ cannot be zero\n     * @param alphaDenominator_ denominator of alpha. If alpha is 0.5 then denominator is 2.\n              alpha is alphaNumerator_/alphaDenominator_. So, 0 < alpha < 1\n     * @param accessControlManager_ Address of AccessControlManager\n     * @param primeLiquidityProvider_ Address of PrimeLiquidityProvider\n     * @param comptroller_ Address of core pool comptroller\n     * @param oracle_ Address of Oracle\n     * @param loopsLimit_ Maximum number of loops allowed in a single transaction\n     * @custom:error Throw InvalidAddress if any of the address is invalid\n     */\n    function initialize(\n        address xvsVault_,\n        address xvsVaultRewardToken_,\n        uint256 xvsVaultPoolId_,\n        uint128 alphaNumerator_,\n        uint128 alphaDenominator_,\n        address accessControlManager_,\n        address primeLiquidityProvider_,\n        address comptroller_,\n        address oracle_,\n        uint256 loopsLimit_\n    ) external initializer {\n        if (xvsVault_ == address(0)) revert InvalidAddress();\n        if (xvsVaultRewardToken_ == address(0)) revert InvalidAddress();\n        if (oracle_ == address(0)) revert InvalidAddress();\n        if (primeLiquidityProvider_ == address(0)) revert InvalidAddress();\n\n        _checkAlphaArguments(alphaNumerator_, alphaDenominator_);\n\n        alphaNumerator = alphaNumerator_;\n        alphaDenominator = alphaDenominator_;\n        xvsVaultRewardToken = xvsVaultRewardToken_;\n        xvsVaultPoolId = xvsVaultPoolId_;\n        xvsVault = xvsVault_;\n        nextScoreUpdateRoundId = 0;\n        primeLiquidityProvider = primeLiquidityProvider_;\n        corePoolComptroller = comptroller_;\n        oracle = ResilientOracleInterface(oracle_);\n\n        __AccessControlled_init(accessControlManager_);\n        __Pausable_init();\n        _setMaxLoopsLimit(loopsLimit_);\n\n        _pause();\n    }\n\n    /**\n     * @notice Prime initializer V2 for initializing pool registry\n     * @param poolRegistry_ Address of IL pool registry\n     */\n    function initializeV2(address poolRegistry_) external reinitializer(2) {\n        poolRegistry = poolRegistry_;\n    }\n\n    /**\n     * @notice Returns boosted pending interest accrued for a user for all markets\n     * @param user the account for which to get the accrued interests\n     * @return pendingRewards the number of underlying tokens accrued by the user for all markets\n     */\n    function getPendingRewards(address user) external returns (PendingReward[] memory pendingRewards) {\n        address[] storage allMarkets = _allMarkets;\n        uint256 marketsLength = allMarkets.length;\n\n        pendingRewards = new PendingReward[](marketsLength);\n        for (uint256 i; i < marketsLength; ) {\n            address market = allMarkets[i];\n            uint256 interestAccrued = getInterestAccrued(market, user);\n            uint256 accrued = interests[market][user].accrued;\n\n            pendingRewards[i] = PendingReward({\n                vToken: market,\n                rewardToken: _getUnderlying(market),\n                amount: interestAccrued + accrued\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Update total score of multiple users and market\n     * @param users accounts for which we need to update score\n     * @custom:error Throw NoScoreUpdatesRequired if no score updates are required\n     * @custom:error Throw UserHasNoPrimeToken if user has no prime token\n     * @custom:event Emits UserScoreUpdated event\n     */\n    function updateScores(address[] calldata users) external {\n        if (pendingScoreUpdates == 0) revert NoScoreUpdatesRequired();\n        if (nextScoreUpdateRoundId == 0) revert NoScoreUpdatesRequired();\n\n        for (uint256 i; i < users.length; ) {\n            address user = users[i];\n\n            if (!tokens[user].exists) revert UserHasNoPrimeToken();\n            if (isScoreUpdated[nextScoreUpdateRoundId][user]) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            address[] storage allMarkets = _allMarkets;\n            uint256 marketsLength = allMarkets.length;\n\n            for (uint256 j; j < marketsLength; ) {\n                address market = allMarkets[j];\n                _executeBoost(user, market);\n                _updateScore(user, market);\n\n                unchecked {\n                    ++j;\n                }\n            }\n\n            --pendingScoreUpdates;\n            isScoreUpdated[nextScoreUpdateRoundId][user] = true;\n\n            unchecked {\n                ++i;\n            }\n\n            emit UserScoreUpdated(user);\n        }\n    }\n\n    /**\n     * @notice Update value of alpha\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     * @custom:event Emits AlphaUpdated event\n     * @custom:access Controlled by ACM\n     */\n    function updateAlpha(uint128 _alphaNumerator, uint128 _alphaDenominator) external {\n        _checkAccessAllowed(\"updateAlpha(uint128,uint128)\");\n        _checkAlphaArguments(_alphaNumerator, _alphaDenominator);\n\n        emit AlphaUpdated(alphaNumerator, alphaDenominator, _alphaNumerator, _alphaDenominator);\n\n        alphaNumerator = _alphaNumerator;\n        alphaDenominator = _alphaDenominator;\n\n        uint256 marketslength = _allMarkets.length;\n\n        for (uint256 i; i < marketslength; ) {\n            accrueInterest(_allMarkets[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Update multipliers for a market\n     * @param market address of the market vToken\n     * @param supplyMultiplier new supply multiplier for the market, scaled by 1e18\n     * @param borrowMultiplier new borrow multiplier for the market, scaled by 1e18\n     * @custom:error Throw MarketNotSupported if market is not supported\n     * @custom:event Emits MultiplierUpdated event\n     * @custom:access Controlled by ACM\n     */\n    function updateMultipliers(address market, uint256 supplyMultiplier, uint256 borrowMultiplier) external {\n        _checkAccessAllowed(\"updateMultipliers(address,uint256,uint256)\");\n\n        Market storage _market = markets[market];\n        if (!_market.exists) revert MarketNotSupported();\n\n        accrueInterest(market);\n\n        emit MultiplierUpdated(\n            market,\n            _market.supplyMultiplier,\n            _market.borrowMultiplier,\n            supplyMultiplier,\n            borrowMultiplier\n        );\n        _market.supplyMultiplier = supplyMultiplier;\n        _market.borrowMultiplier = borrowMultiplier;\n\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Update staked at timestamp for multiple users\n     * @param users accounts for which we need to update staked at timestamp\n     * @param timestamps new staked at timestamp for the users\n     * @custom:error Throw InvalidLength if users and timestamps length are not equal\n     * @custom:event Emits StakedAtUpdated event for each user\n     * @custom:access Controlled by ACM\n     */\n    function setStakedAt(address[] calldata users, uint256[] calldata timestamps) external {\n        _checkAccessAllowed(\"setStakedAt(address[],uint256[])\");\n        if (users.length != timestamps.length) revert InvalidLength();\n\n        for (uint256 i; i < users.length; ) {\n            if (timestamps[i] > block.timestamp) revert InvalidTimestamp();\n\n            stakedAt[users[i]] = timestamps[i];\n            emit StakedAtUpdated(users[i], timestamps[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Add a market to prime program\n     * @param comptroller address of the comptroller\n     * @param market address of the market vToken\n     * @param supplyMultiplier the multiplier for supply cap. It should be converted to 1e18\n     * @param borrowMultiplier the multiplier for borrow cap. It should be converted to 1e18\n     * @custom:error Throw MarketAlreadyExists if market already exists\n     * @custom:error Throw InvalidVToken if market is not valid\n     * @custom:event Emits MarketAdded event\n     * @custom:access Controlled by ACM\n     */\n    function addMarket(\n        address comptroller,\n        address market,\n        uint256 supplyMultiplier,\n        uint256 borrowMultiplier\n    ) external {\n        _checkAccessAllowed(\"addMarket(address,address,uint256,uint256)\");\n\n        if (comptroller == address(0)) revert InvalidComptroller();\n\n        if (\n            comptroller != corePoolComptroller &&\n            PoolRegistryInterface(poolRegistry).getPoolByComptroller(comptroller).comptroller != comptroller\n        ) revert InvalidComptroller();\n\n        Market storage _market = markets[market];\n        if (_market.exists) revert MarketAlreadyExists();\n\n        bool isMarketExist = InterfaceComptroller(comptroller).markets(market);\n        if (!isMarketExist) revert InvalidVToken();\n\n        delete _market.rewardIndex;\n        _market.supplyMultiplier = supplyMultiplier;\n        _market.borrowMultiplier = borrowMultiplier;\n        delete _market.sumOfMembersScore;\n        _market.exists = true;\n\n        address underlying = _getUnderlying(market);\n\n        if (vTokenForAsset[underlying] != address(0)) revert AssetAlreadyExists();\n        vTokenForAsset[underlying] = market;\n\n        _allMarkets.push(market);\n        _startScoreUpdateRound();\n\n        _ensureMaxLoops(_allMarkets.length);\n\n        emit MarketAdded(comptroller, market, supplyMultiplier, borrowMultiplier);\n    }\n\n    /**\n     * @notice Set limits for total tokens that can be minted\n     * @param _irrevocableLimit total number of irrevocable tokens that can be minted\n     * @param _revocableLimit total number of revocable tokens that can be minted\n     * @custom:error Throw InvalidLimit if any of the limit is less than total tokens minted\n     * @custom:event Emits MintLimitsUpdated event\n     * @custom:access Controlled by ACM\n     */\n    function setLimit(uint256 _irrevocableLimit, uint256 _revocableLimit) external {\n        _checkAccessAllowed(\"setLimit(uint256,uint256)\");\n        if (_irrevocableLimit < totalIrrevocable || _revocableLimit < totalRevocable) revert InvalidLimit();\n\n        emit MintLimitsUpdated(irrevocableLimit, revocableLimit, _irrevocableLimit, _revocableLimit);\n\n        revocableLimit = _revocableLimit;\n        irrevocableLimit = _irrevocableLimit;\n    }\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param loopsLimit Number of loops limit\n     * @custom:event Emits MaxLoopsLimitUpdated event on success\n     * @custom:access Controlled by ACM\n     */\n    function setMaxLoopsLimit(uint256 loopsLimit) external {\n        _checkAccessAllowed(\"setMaxLoopsLimit(uint256)\");\n        _setMaxLoopsLimit(loopsLimit);\n    }\n\n    /**\n     * @notice Directly issue prime tokens to users\n     * @param isIrrevocable are the tokens being issued\n     * @param users list of address to issue tokens to\n     * @custom:access Controlled by ACM\n     */\n    function issue(bool isIrrevocable, address[] calldata users) external {\n        _checkAccessAllowed(\"issue(bool,address[])\");\n\n        if (isIrrevocable) {\n            for (uint256 i; i < users.length; ) {\n                Token storage userToken = tokens[users[i]];\n                if (userToken.exists && !userToken.isIrrevocable) {\n                    _upgrade(users[i]);\n                } else {\n                    _mint(true, users[i]);\n                    _initializeMarkets(users[i]);\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            for (uint256 i; i < users.length; ) {\n                _mint(false, users[i]);\n                _initializeMarkets(users[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\n     * @param user the account address whose balance was updated\n     */\n    function xvsUpdated(address user) external {\n        uint256 totalStaked = _xvsBalanceOfUser(user);\n        bool isAccountEligible = _isEligible(totalStaked);\n\n        uint256 userStakedAt = stakedAt[user];\n        Token memory token = tokens[user];\n\n        if (token.exists && !isAccountEligible) {\n            delete stakedAt[user];\n            emit StakedAtUpdated(user, 0);\n\n            if (token.isIrrevocable) {\n                _accrueInterestAndUpdateScore(user);\n            } else {\n                _burn(user);\n            }\n        } else if (!isAccountEligible && !token.exists && userStakedAt != 0) {\n            delete stakedAt[user];\n            emit StakedAtUpdated(user, 0);\n        } else if (userStakedAt == 0 && isAccountEligible && !token.exists) {\n            stakedAt[user] = block.timestamp;\n            emit StakedAtUpdated(user, block.timestamp);\n        } else if (token.exists && isAccountEligible) {\n            _accrueInterestAndUpdateScore(user);\n\n            if (stakedAt[user] == 0) {\n                stakedAt[user] = block.timestamp;\n                emit StakedAtUpdated(user, block.timestamp);\n            }\n        }\n    }\n\n    /**\n     * @notice accrues interes and updates score for an user for a specific market\n     * @param user the account address for which to accrue interest and update score\n     * @param market the market for which to accrue interest and update score\n     */\n    function accrueInterestAndUpdateScore(address user, address market) external {\n        _executeBoost(user, market);\n        _updateScore(user, market);\n    }\n\n    /**\n     * @notice For claiming prime token when staking period is completed\n     */\n    function claim() external {\n        uint256 userStakedAt = stakedAt[msg.sender];\n        if (userStakedAt == 0) revert IneligibleToClaim();\n        if (block.timestamp - userStakedAt < STAKING_PERIOD) revert WaitMoreTime();\n\n        _mint(false, msg.sender);\n        _initializeMarkets(msg.sender);\n    }\n\n    /**\n     * @notice For burning any prime token\n     * @param user the account address for which the prime token will be burned\n     * @custom:access Controlled by ACM\n     */\n    function burn(address user) external {\n        _checkAccessAllowed(\"burn(address)\");\n        _burn(user);\n    }\n\n    /**\n     * @notice To pause or unpause claiming of interest\n     * @custom:access Controlled by ACM\n     */\n    function togglePause() external {\n        _checkAccessAllowed(\"togglePause()\");\n        if (paused()) {\n            _unpause();\n        } else {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     * @return amount the amount of tokens transferred to the msg.sender\n     */\n    function claimInterest(address vToken) external whenNotPaused returns (uint256) {\n        return _claimInterest(vToken, msg.sender);\n    }\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     * @param user the user for which to claim the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function claimInterest(address vToken, address user) external whenNotPaused returns (uint256) {\n        return _claimInterest(vToken, user);\n    }\n\n    /**\n     * @notice Retrieves an array of all available markets\n     * @return an array of addresses representing all available markets\n     */\n    function getAllMarkets() external view returns (address[] memory) {\n        return _allMarkets;\n    }\n\n    /**\n     * @notice Retrieves the core pool comptroller address\n     * @return the core pool comptroller address\n     */\n    function comptroller() external view returns (address) {\n        return corePoolComptroller;\n    }\n\n    /**\n     * @notice fetch the numbers of seconds remaining for staking period to complete\n     * @param user the account address for which we are checking the remaining time\n     * @return timeRemaining the number of seconds the user needs to wait to claim prime token\n     */\n    function claimTimeRemaining(address user) external view returns (uint256) {\n        uint256 userStakedAt = stakedAt[user];\n        if (userStakedAt == 0) return STAKING_PERIOD;\n\n        uint256 totalTimeStaked;\n        unchecked {\n            totalTimeStaked = block.timestamp - userStakedAt;\n        }\n\n        if (totalTimeStaked < STAKING_PERIOD) {\n            unchecked {\n                return STAKING_PERIOD - totalTimeStaked;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Returns if user is a prime holder\n     * @return isPrimeHolder true if user is a prime holder\n     */\n    function isUserPrimeHolder(address user) external view returns (bool) {\n        return tokens[user].exists;\n    }\n\n    /**\n     * @notice Returns supply and borrow APR for user for a given market\n     * @param market the market for which to fetch the APR\n     * @param user the account for which to get the APR\n     * @return aprInfo APR information for the user for the given market\n     */\n    function calculateAPR(address market, address user) external view returns (APRInfo memory aprInfo) {\n        IVToken vToken = IVToken(market);\n        uint256 borrow = vToken.borrowBalanceStored(user);\n        uint256 exchangeRate = vToken.exchangeRateStored();\n        uint256 balanceOfAccount = vToken.balanceOf(user);\n        uint256 supply = (exchangeRate * balanceOfAccount) / EXP_SCALE;\n\n        aprInfo.userScore = interests[market][user].score;\n        aprInfo.totalScore = markets[market].sumOfMembersScore;\n\n        aprInfo.xvsBalanceForScore = _xvsBalanceForScore(_xvsBalanceOfUser(user));\n        Capital memory capital = _capitalForScore(aprInfo.xvsBalanceForScore, borrow, supply, address(vToken));\n\n        aprInfo.capital = capital.capital;\n        aprInfo.cappedSupply = capital.cappedSupply;\n        aprInfo.cappedBorrow = capital.cappedBorrow;\n        aprInfo.supplyCapUSD = capital.supplyCapUSD;\n        aprInfo.borrowCapUSD = capital.borrowCapUSD;\n\n        (aprInfo.supplyAPR, aprInfo.borrowAPR) = _calculateUserAPR(\n            market,\n            supply,\n            borrow,\n            aprInfo.cappedSupply,\n            aprInfo.cappedBorrow,\n            aprInfo.userScore,\n            aprInfo.totalScore\n        );\n    }\n\n    /**\n     * @notice Returns supply and borrow APR for estimated supply, borrow and XVS staked\n     * @param market the market for which to fetch the APR\n     * @param user the account for which to get the APR\n     * @return aprInfo APR information for the user for the given market\n     */\n    function estimateAPR(\n        address market,\n        address user,\n        uint256 borrow,\n        uint256 supply,\n        uint256 xvsStaked\n    ) external view returns (APRInfo memory aprInfo) {\n        aprInfo.totalScore = markets[market].sumOfMembersScore - interests[market][user].score;\n\n        aprInfo.xvsBalanceForScore = _xvsBalanceForScore(xvsStaked);\n        Capital memory capital = _capitalForScore(aprInfo.xvsBalanceForScore, borrow, supply, market);\n\n        aprInfo.capital = capital.capital;\n        aprInfo.cappedSupply = capital.cappedSupply;\n        aprInfo.cappedBorrow = capital.cappedBorrow;\n        aprInfo.supplyCapUSD = capital.supplyCapUSD;\n        aprInfo.borrowCapUSD = capital.borrowCapUSD;\n\n        uint256 decimals = IERC20MetadataUpgradeable(_getUnderlying(market)).decimals();\n        aprInfo.capital = aprInfo.capital * (10 ** (18 - decimals));\n\n        aprInfo.userScore = Scores._calculateScore(\n            aprInfo.xvsBalanceForScore,\n            aprInfo.capital,\n            alphaNumerator,\n            alphaDenominator\n        );\n\n        aprInfo.totalScore = aprInfo.totalScore + aprInfo.userScore;\n\n        (aprInfo.supplyAPR, aprInfo.borrowAPR) = _calculateUserAPR(\n            market,\n            supply,\n            borrow,\n            aprInfo.cappedSupply,\n            aprInfo.cappedBorrow,\n            aprInfo.userScore,\n            aprInfo.totalScore\n        );\n    }\n\n    /**\n     * @notice Distributes income from market since last distribution\n     * @param vToken the market for which to distribute the income\n     * @custom:error Throw MarketNotSupported if market is not supported\n     */\n    function accrueInterest(address vToken) public {\n        Market storage market = markets[vToken];\n\n        if (!market.exists) revert MarketNotSupported();\n\n        address underlying = _getUnderlying(vToken);\n\n        IPrimeLiquidityProvider _primeLiquidityProvider = IPrimeLiquidityProvider(primeLiquidityProvider);\n        _primeLiquidityProvider.accrueTokens(underlying);\n        uint256 totalAccruedInPLP = _primeLiquidityProvider.tokenAmountAccrued(underlying);\n        uint256 unreleasedPLPAccruedInterest = totalAccruedInPLP - unreleasedPLPIncome[underlying];\n        uint256 distributionIncome = unreleasedPLPAccruedInterest;\n\n        if (distributionIncome == 0) {\n            return;\n        }\n\n        unreleasedPLPIncome[underlying] = totalAccruedInPLP;\n\n        uint256 delta;\n        if (market.sumOfMembersScore != 0) {\n            delta = ((distributionIncome * EXP_SCALE) / market.sumOfMembersScore);\n        }\n\n        market.rewardIndex += delta;\n    }\n\n    /**\n     * @notice Returns boosted interest accrued for a user\n     * @param vToken the market for which to fetch the accrued interest\n     * @param user the account for which to get the accrued interest\n     * @return interestAccrued the number of underlying tokens accrued by the user since the last accrual\n     */\n    function getInterestAccrued(address vToken, address user) public returns (uint256) {\n        accrueInterest(vToken);\n\n        return _interestAccrued(vToken, user);\n    }\n\n    /**\n     * @notice accrues interest and updates score of all markets for an user\n     * @param user the account address for which to accrue interest and update score\n     */\n    function _accrueInterestAndUpdateScore(address user) internal {\n        address[] storage allMarkets = _allMarkets;\n        uint256 marketsLength = allMarkets.length;\n\n        for (uint256 i; i < marketsLength; ) {\n            address market = allMarkets[i];\n            _executeBoost(user, market);\n            _updateScore(user, market);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Initializes all the markets for the user when a prime token is minted\n     * @param account the account address for which markets needs to be initialized\n     */\n    function _initializeMarkets(address account) internal {\n        address[] storage allMarkets = _allMarkets;\n        uint256 marketsLength = allMarkets.length;\n\n        for (uint256 i; i < marketsLength; ) {\n            address market = allMarkets[i];\n            accrueInterest(market);\n\n            interests[market][account].rewardIndex = markets[market].rewardIndex;\n\n            uint256 score = _calculateScore(market, account);\n            interests[market][account].score = score;\n            markets[market].sumOfMembersScore = markets[market].sumOfMembersScore + score;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice calculate the current score of user\n     * @param market the market for which to calculate the score\n     * @param user the account for which to calculate the score\n     * @return score the score of the user\n     */\n    function _calculateScore(address market, address user) internal returns (uint256) {\n        uint256 xvsBalanceForScore = _xvsBalanceForScore(_xvsBalanceOfUser(user));\n\n        IVToken vToken = IVToken(market);\n        uint256 borrow = vToken.borrowBalanceStored(user);\n        uint256 exchangeRate = vToken.exchangeRateStored();\n        uint256 balanceOfAccount = vToken.balanceOf(user);\n        uint256 supply = (exchangeRate * balanceOfAccount) / EXP_SCALE;\n\n        address xvsToken = IXVSVault(xvsVault).xvsAddress();\n        oracle.updateAssetPrice(xvsToken);\n        oracle.updatePrice(market);\n\n        Capital memory capital = _capitalForScore(xvsBalanceForScore, borrow, supply, market);\n\n        uint256 decimals = IERC20MetadataUpgradeable(_getUnderlying(market)).decimals();\n\n        capital.capital = capital.capital * (10 ** (18 - decimals));\n\n        return Scores._calculateScore(xvsBalanceForScore, capital.capital, alphaNumerator, alphaDenominator);\n    }\n\n    /**\n     * @notice To transfer the accrued interest to user\n     * @param vToken the market for which to claim\n     * @param user the account for which to get the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     * @custom:event Emits InterestClaimed event\n     */\n    function _claimInterest(address vToken, address user) internal returns (uint256) {\n        uint256 amount = getInterestAccrued(vToken, user);\n        amount += interests[vToken][user].accrued;\n\n        interests[vToken][user].rewardIndex = markets[vToken].rewardIndex;\n        delete interests[vToken][user].accrued;\n\n        address underlying = _getUnderlying(vToken);\n        IERC20Upgradeable asset = IERC20Upgradeable(underlying);\n\n        if (amount > asset.balanceOf(address(this))) {\n            delete unreleasedPLPIncome[underlying];\n            IPrimeLiquidityProvider(primeLiquidityProvider).releaseFunds(address(asset));\n        }\n\n        asset.safeTransfer(user, amount);\n\n        emit InterestClaimed(user, vToken, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Used to mint a new prime token\n     * @param isIrrevocable is the tokens being issued is irrevocable\n     * @param user token owner\n     * @custom:error Throw IneligibleToClaim if user is not eligible to claim prime token\n     * @custom:event Emits Mint event\n     */\n    function _mint(bool isIrrevocable, address user) internal {\n        Token storage token = tokens[user];\n        if (token.exists) revert IneligibleToClaim();\n\n        token.exists = true;\n        token.isIrrevocable = isIrrevocable;\n\n        if (isIrrevocable) {\n            ++totalIrrevocable;\n        } else {\n            ++totalRevocable;\n        }\n\n        if (totalIrrevocable > irrevocableLimit || totalRevocable > revocableLimit) revert InvalidLimit();\n        _updateRoundAfterTokenMinted(user);\n\n        emit Mint(user, isIrrevocable);\n    }\n\n    /**\n     * @notice Used to burn a new prime token\n     * @param user owner whose prime token to burn\n     * @custom:error Throw UserHasNoPrimeToken if user has no prime token\n     * @custom:event Emits Burn event\n     */\n    function _burn(address user) internal {\n        Token memory token = tokens[user];\n        if (!token.exists) revert UserHasNoPrimeToken();\n\n        address[] storage allMarkets = _allMarkets;\n        uint256 marketsLength = allMarkets.length;\n\n        for (uint256 i; i < marketsLength; ) {\n            address market = allMarkets[i];\n            _executeBoost(user, market);\n            markets[market].sumOfMembersScore = markets[market].sumOfMembersScore - interests[market][user].score;\n\n            delete interests[market][user].score;\n            delete interests[market][user].rewardIndex;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (token.isIrrevocable) {\n            --totalIrrevocable;\n        } else {\n            --totalRevocable;\n        }\n\n        delete tokens[user].exists;\n        delete tokens[user].isIrrevocable;\n\n        _updateRoundAfterTokenBurned(user);\n\n        emit Burn(user);\n    }\n\n    /**\n     * @notice Used to upgrade an token\n     * @param user owner whose prime token to upgrade\n     * @custom:error Throw InvalidLimit if total irrevocable tokens exceeds the limit\n     * @custom:event Emits TokenUpgraded event\n     */\n    function _upgrade(address user) internal {\n        Token storage userToken = tokens[user];\n\n        userToken.isIrrevocable = true;\n        ++totalIrrevocable;\n        --totalRevocable;\n\n        if (totalIrrevocable > irrevocableLimit) revert InvalidLimit();\n\n        emit TokenUpgraded(user);\n    }\n\n    /**\n     * @notice Accrue rewards for the user. Must be called before updating score\n     * @param user account for which we need to accrue rewards\n     * @param vToken the market for which we need to accrue rewards\n     */\n    function _executeBoost(address user, address vToken) internal {\n        if (!markets[vToken].exists || !tokens[user].exists) {\n            return;\n        }\n\n        accrueInterest(vToken);\n        interests[vToken][user].accrued += _interestAccrued(vToken, user);\n        interests[vToken][user].rewardIndex = markets[vToken].rewardIndex;\n    }\n\n    /**\n     * @notice Update total score of user and market. Must be called after changing account's borrow or supply balance.\n     * @param user account for which we need to update score\n     * @param market the market for which we need to score\n     */\n    function _updateScore(address user, address market) internal {\n        Market storage _market = markets[market];\n        if (!_market.exists || !tokens[user].exists) {\n            return;\n        }\n\n        uint256 score = _calculateScore(market, user);\n        _market.sumOfMembersScore = _market.sumOfMembersScore - interests[market][user].score + score;\n\n        interests[market][user].score = score;\n    }\n\n    /**\n     * @notice Verify new alpha arguments\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     * @custom:error Throw InvalidAlphaArguments if alpha is invalid\n     */\n    function _checkAlphaArguments(uint128 _alphaNumerator, uint128 _alphaDenominator) internal pure {\n        if (_alphaNumerator >= _alphaDenominator || _alphaNumerator == 0) {\n            revert InvalidAlphaArguments();\n        }\n    }\n\n    /**\n     * @notice starts round to update scores of a particular or all markets\n     */\n    function _startScoreUpdateRound() internal {\n        nextScoreUpdateRoundId++;\n        totalScoreUpdatesRequired = totalIrrevocable + totalRevocable;\n        pendingScoreUpdates = totalScoreUpdatesRequired;\n    }\n\n    /**\n     * @notice update the required score updates when token is burned before round is completed\n     */\n    function _updateRoundAfterTokenBurned(address user) internal {\n        if (totalScoreUpdatesRequired != 0) --totalScoreUpdatesRequired;\n\n        if (pendingScoreUpdates != 0 && !isScoreUpdated[nextScoreUpdateRoundId][user]) {\n            --pendingScoreUpdates;\n        }\n    }\n\n    /**\n     * @notice update the required score updates when token is minted before round is completed\n     */\n    function _updateRoundAfterTokenMinted(address user) internal {\n        if (totalScoreUpdatesRequired != 0) isScoreUpdated[nextScoreUpdateRoundId][user] = true;\n    }\n\n    /**\n     * @notice fetch the current XVS balance of user in the XVSVault\n     * @param user the account address\n     * @return xvsBalance the XVS balance of user\n     */\n    function _xvsBalanceOfUser(address user) internal view returns (uint256) {\n        (uint256 xvs, , uint256 pendingWithdrawals) = IXVSVault(xvsVault).getUserInfo(\n            xvsVaultRewardToken,\n            xvsVaultPoolId,\n            user\n        );\n        return (xvs - pendingWithdrawals);\n    }\n\n    /**\n     * @notice calculate the current XVS balance that will be used in calculation of score\n     * @param xvs the actual XVS balance of user\n     * @return xvsBalanceForScore the XVS balance to use in score\n     */\n    function _xvsBalanceForScore(uint256 xvs) internal view returns (uint256) {\n        if (xvs > MAXIMUM_XVS_CAP) {\n            return MAXIMUM_XVS_CAP;\n        }\n        return xvs;\n    }\n\n    /**\n     * @notice calculate the capital for calculation of score\n     * @param xvs the actual XVS balance of user\n     * @param borrow the borrow balance of user\n     * @param supply the supply balance of user\n     * @param market the market vToken address\n     * @return capital the capital to use in calculation of score\n     */\n    function _capitalForScore(\n        uint256 xvs,\n        uint256 borrow,\n        uint256 supply,\n        address market\n    ) internal view returns (Capital memory capital) {\n        address xvsToken = IXVSVault(xvsVault).xvsAddress();\n\n        uint256 xvsPrice = oracle.getPrice(xvsToken);\n        capital.borrowCapUSD = (xvsPrice * ((xvs * markets[market].borrowMultiplier) / EXP_SCALE)) / EXP_SCALE;\n        capital.supplyCapUSD = (xvsPrice * ((xvs * markets[market].supplyMultiplier) / EXP_SCALE)) / EXP_SCALE;\n\n        uint256 tokenPrice = oracle.getUnderlyingPrice(market);\n        uint256 supplyUSD = (tokenPrice * supply) / EXP_SCALE;\n        uint256 borrowUSD = (tokenPrice * borrow) / EXP_SCALE;\n\n        if (supplyUSD >= capital.supplyCapUSD) {\n            supply = supplyUSD != 0 ? (supply * capital.supplyCapUSD) / supplyUSD : 0;\n        }\n\n        if (borrowUSD >= capital.borrowCapUSD) {\n            borrow = borrowUSD != 0 ? (borrow * capital.borrowCapUSD) / borrowUSD : 0;\n        }\n\n        capital.capital = supply + borrow;\n        capital.cappedSupply = supply;\n        capital.cappedBorrow = borrow;\n    }\n\n    /**\n     * @notice Used to get if the XVS balance is eligible for prime token\n     * @param amount amount of XVS\n     * @return isEligible true if the staked XVS amount is enough to consider the associated user eligible for a Prime token, false otherwise\n     */\n    function _isEligible(uint256 amount) internal view returns (bool) {\n        if (amount >= MINIMUM_STAKED_XVS) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Calculate the interests accrued by the user in the market, since the last accrual\n     * @param vToken the market for which to calculate the accrued interest\n     * @param user the user for which to calculate the accrued interest\n     * @return interestAccrued the number of underlying tokens accrued by the user since the last accrual\n     */\n    function _interestAccrued(address vToken, address user) internal view returns (uint256) {\n        Interest memory interest = interests[vToken][user];\n        uint256 index = markets[vToken].rewardIndex - interest.rewardIndex;\n\n        uint256 score = interest.score;\n\n        return (index * score) / EXP_SCALE;\n    }\n\n    /**\n     * @notice Returns the underlying token associated with the VToken, or wrapped native token if the market is native market\n     * @param vToken the market whose underlying token will be returned\n     * @return underlying The address of the underlying token associated with the VToken, or the address of the WRAPPED_NATIVE_TOKEN token if the market is NATIVE_MARKET\n     */\n    function _getUnderlying(address vToken) internal view returns (address) {\n        if (vToken == NATIVE_MARKET) {\n            return WRAPPED_NATIVE_TOKEN;\n        }\n        return IVToken(vToken).underlying();\n    }\n\n    //////////////////////////////////////////////////\n    //////////////// APR Calculation ////////////////\n    ////////////////////////////////////////////////\n\n    /**\n     * @notice the total income that's going to be distributed in a year to prime token holders\n     * @param vToken the market for which to fetch the total income that's going to distributed in a year\n     * @return amount the total income\n     */\n    function incomeDistributionYearly(address vToken) public view returns (uint256 amount) {\n        uint256 totalIncomePerBlockOrSecondFromPLP = IPrimeLiquidityProvider(primeLiquidityProvider)\n            .getEffectiveDistributionSpeed(_getUnderlying(vToken));\n        amount = blocksOrSecondsPerYear * totalIncomePerBlockOrSecondFromPLP;\n    }\n\n    /**\n     * @notice used to calculate the supply and borrow APR of the user\n     * @param vToken the market for which to fetch the APR\n     * @param totalSupply the total token supply of the user\n     * @param totalBorrow the total tokens borrowed by the user\n     * @param totalCappedSupply the total token capped supply of the user\n     * @param totalCappedBorrow the total capped tokens borrowed by the user\n     * @param userScore the score of the user\n     * @param totalScore the total market score\n     * @return supplyAPR the supply APR of the user\n     * @return borrowAPR the borrow APR of the user\n     */\n    function _calculateUserAPR(\n        address vToken,\n        uint256 totalSupply,\n        uint256 totalBorrow,\n        uint256 totalCappedSupply,\n        uint256 totalCappedBorrow,\n        uint256 userScore,\n        uint256 totalScore\n    ) internal view returns (uint256 supplyAPR, uint256 borrowAPR) {\n        if (totalScore == 0) return (0, 0);\n\n        uint256 userYearlyIncome = (userScore * incomeDistributionYearly(vToken)) / totalScore;\n\n        uint256 totalCappedValue = totalCappedSupply + totalCappedBorrow;\n\n        if (totalCappedValue == 0) return (0, 0);\n\n        uint256 maximumBps = MAXIMUM_BPS;\n        uint256 userSupplyIncomeYearly;\n        uint256 userBorrowIncomeYearly;\n        userSupplyIncomeYearly = (userYearlyIncome * totalCappedSupply) / totalCappedValue;\n        userBorrowIncomeYearly = (userYearlyIncome * totalCappedBorrow) / totalCappedValue;\n        supplyAPR = totalSupply == 0 ? 0 : ((userSupplyIncomeYearly * maximumBps) / totalSupply);\n        borrowAPR = totalBorrow == 0 ? 0 : ((userBorrowIncomeYearly * maximumBps) / totalBorrow);\n    }\n}\n"
    },
    "contracts/Tokens/Prime/PrimeLiquidityProvider.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { PrimeLiquidityProviderStorageV1 } from \"./PrimeLiquidityProviderStorage.sol\";\nimport { SafeERC20Upgradeable, IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { IPrimeLiquidityProvider } from \"./Interfaces/IPrimeLiquidityProvider.sol\";\nimport { MaxLoopsLimitHelper } from \"@venusprotocol/solidity-utilities/contracts/MaxLoopsLimitHelper.sol\";\nimport { TimeManagerV8 } from \"@venusprotocol/solidity-utilities/contracts/TimeManagerV8.sol\";\n\n/**\n * @title PrimeLiquidityProvider\n * @author Venus\n * @notice PrimeLiquidityProvider is used to fund Prime\n */\ncontract PrimeLiquidityProvider is\n    IPrimeLiquidityProvider,\n    AccessControlledV8,\n    PausableUpgradeable,\n    MaxLoopsLimitHelper,\n    PrimeLiquidityProviderStorageV1,\n    TimeManagerV8\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The default max token distribution speed\n    uint256 public constant DEFAULT_MAX_DISTRIBUTION_SPEED = 1e18;\n\n    /// @notice Emitted when a token distribution is initialized\n    event TokenDistributionInitialized(address indexed token);\n\n    /// @notice Emitted when a new token distribution speed is set\n    event TokenDistributionSpeedUpdated(address indexed token, uint256 oldSpeed, uint256 newSpeed);\n\n    /// @notice Emitted when a new max distribution speed for token is set\n    event MaxTokenDistributionSpeedUpdated(address indexed token, uint256 oldSpeed, uint256 newSpeed);\n\n    /// @notice Emitted when prime token contract address is changed\n    event PrimeTokenUpdated(address indexed oldPrimeToken, address indexed newPrimeToken);\n\n    /// @notice Emitted when distribution state(Index and block or second) is updated\n    event TokensAccrued(address indexed token, uint256 amount);\n\n    /// @notice Emitted when token is transferred to the prime contract\n    event TokenTransferredToPrime(address indexed token, uint256 amount);\n\n    /// @notice Emitted on sweep token success\n    event SweepToken(address indexed token, address indexed to, uint256 sweepAmount);\n\n    /// @notice Thrown when arguments are passed are invalid\n    error InvalidArguments();\n\n    /// @notice Thrown when distribution speed is greater than maxTokenDistributionSpeeds[tokenAddress]\n    error InvalidDistributionSpeed(uint256 speed, uint256 maxSpeed);\n\n    /// @notice Thrown when caller is not the desired caller\n    error InvalidCaller();\n\n    /// @notice Thrown when token is initialized\n    error TokenAlreadyInitialized(address token);\n\n    ///@notice Error thrown when PrimeLiquidityProvider's balance is less than sweep amount\n    error InsufficientBalance(uint256 sweepAmount, uint256 balance);\n\n    /// @notice Error thrown when funds transfer is paused\n    error FundsTransferIsPaused();\n\n    /// @notice Error thrown when accrueTokens is called for an uninitialized token\n    error TokenNotInitialized(address token_);\n\n    /// @notice Error thrown when argument value in setter is same as previous value\n    error AddressesMustDiffer();\n\n    /**\n     * @notice Compares two addresses to ensure they are different\n     * @param oldAddress The original address to compare\n     * @param newAddress The new address to compare\n     */\n    modifier compareAddress(address oldAddress, address newAddress) {\n        if (newAddress == oldAddress) {\n            revert AddressesMustDiffer();\n        }\n        _;\n    }\n\n    /**\n     * @notice Prime Liquidity Provider constructor\n     * @param _timeBased A boolean indicating whether the contract is based on time or block.\n     * @param _blocksPerYear total blocks per year\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(bool _timeBased, uint256 _blocksPerYear) TimeManagerV8(_timeBased, _blocksPerYear) {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice PrimeLiquidityProvider initializer\n     * @dev Initializes the deployer to owner\n     * @param accessControlManager_ AccessControlManager contract address\n     * @param tokens_ Array of addresses of the tokens\n     * @param distributionSpeeds_ New distribution speeds for tokens\n     * @param loopsLimit_ Maximum number of loops allowed in a single transaction\n     * @custom:error Throw InvalidArguments on different length of tokens and speeds array\n     */\n    function initialize(\n        address accessControlManager_,\n        address[] calldata tokens_,\n        uint256[] calldata distributionSpeeds_,\n        uint256[] calldata maxDistributionSpeeds_,\n        uint256 loopsLimit_\n    ) external initializer {\n        _ensureZeroAddress(accessControlManager_);\n\n        __AccessControlled_init(accessControlManager_);\n        __Pausable_init();\n        _setMaxLoopsLimit(loopsLimit_);\n\n        uint256 numTokens = tokens_.length;\n        _ensureMaxLoops(numTokens);\n\n        if ((numTokens != distributionSpeeds_.length) || (numTokens != maxDistributionSpeeds_.length)) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < numTokens; ) {\n            _initializeToken(tokens_[i]);\n            _setMaxTokenDistributionSpeed(tokens_[i], maxDistributionSpeeds_[i]);\n            _setTokenDistributionSpeed(tokens_[i], distributionSpeeds_[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Initialize the distribution of the token\n     * @param tokens_ Array of addresses of the tokens to be intialized\n     * @custom:access Only Governance\n     */\n    function initializeTokens(address[] calldata tokens_) external onlyOwner {\n        uint256 tokensLength = tokens_.length;\n        _ensureMaxLoops(tokensLength);\n\n        for (uint256 i; i < tokensLength; ) {\n            _initializeToken(tokens_[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Pause fund transfer of tokens to Prime contract\n     * @custom:access Controlled by ACM\n     */\n    function pauseFundsTransfer() external {\n        _checkAccessAllowed(\"pauseFundsTransfer()\");\n        _pause();\n    }\n\n    /**\n     * @notice Resume fund transfer of tokens to Prime contract\n     * @custom:access Controlled by ACM\n     */\n    function resumeFundsTransfer() external {\n        _checkAccessAllowed(\"resumeFundsTransfer()\");\n        _unpause();\n    }\n\n    /**\n     * @notice Set distribution speed (amount of token distribute per block or second)\n     * @param tokens_ Array of addresses of the tokens\n     * @param distributionSpeeds_ New distribution speeds for tokens\n     * @custom:access Controlled by ACM\n     * @custom:error Throw InvalidArguments on different length of tokens and speeds array\n     */\n    function setTokensDistributionSpeed(address[] calldata tokens_, uint256[] calldata distributionSpeeds_) external {\n        _checkAccessAllowed(\"setTokensDistributionSpeed(address[],uint256[])\");\n        uint256 numTokens = tokens_.length;\n        _ensureMaxLoops(numTokens);\n\n        if (numTokens != distributionSpeeds_.length) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < numTokens; ) {\n            _ensureTokenInitialized(tokens_[i]);\n            _setTokenDistributionSpeed(tokens_[i], distributionSpeeds_[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Set max distribution speed for token (amount of maximum token distribute per block or second)\n     * @param tokens_ Array of addresses of the tokens\n     * @param maxDistributionSpeeds_ New distribution speeds for tokens\n     * @custom:access Controlled by ACM\n     * @custom:error Throw InvalidArguments on different length of tokens and speeds array\n     */\n    function setMaxTokensDistributionSpeed(\n        address[] calldata tokens_,\n        uint256[] calldata maxDistributionSpeeds_\n    ) external {\n        _checkAccessAllowed(\"setMaxTokensDistributionSpeed(address[],uint256[])\");\n        uint256 numTokens = tokens_.length;\n        _ensureMaxLoops(numTokens);\n\n        if (numTokens != maxDistributionSpeeds_.length) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < numTokens; ) {\n            _setMaxTokenDistributionSpeed(tokens_[i], maxDistributionSpeeds_[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Set the prime token contract address\n     * @param prime_ The new address of the prime token contract\n     * @custom:event Emits PrimeTokenUpdated event\n     * @custom:access Only owner\n     */\n    function setPrimeToken(address prime_) external onlyOwner compareAddress(prime, prime_) {\n        _ensureZeroAddress(prime_);\n\n        emit PrimeTokenUpdated(prime, prime_);\n        prime = prime_;\n    }\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param loopsLimit Limit for the max loops can execute at a time\n     * @custom:event Emits MaxLoopsLimitUpdated event on success\n     * @custom:access Controlled by ACM\n     */\n    function setMaxLoopsLimit(uint256 loopsLimit) external {\n        _checkAccessAllowed(\"setMaxLoopsLimit(uint256)\");\n        _setMaxLoopsLimit(loopsLimit);\n    }\n\n    /**\n     * @notice Claim all the token accrued till last block or second\n     * @param token_ The token to release to the Prime contract\n     * @custom:event Emits TokenTransferredToPrime event\n     * @custom:error Throw InvalidArguments on Zero address(token)\n     * @custom:error Throw FundsTransferIsPaused is paused\n     * @custom:error Throw InvalidCaller if the sender is not the Prime contract\n     */\n    function releaseFunds(address token_) external {\n        address _prime = prime;\n        if (msg.sender != _prime) revert InvalidCaller();\n        if (paused()) {\n            revert FundsTransferIsPaused();\n        }\n\n        accrueTokens(token_);\n        uint256 accruedAmount = _tokenAmountAccrued[token_];\n        delete _tokenAmountAccrued[token_];\n\n        emit TokenTransferredToPrime(token_, accruedAmount);\n\n        IERC20Upgradeable(token_).safeTransfer(_prime, accruedAmount);\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to user\n     * @param token_ The address of the ERC-20 token to sweep\n     * @param to_ The address of the recipient\n     * @param amount_ The amount of tokens needs to transfer\n     * @custom:event Emits SweepToken event\n     * @custom:error Throw InsufficientBalance if amount_ is greater than the available balance of the token in the contract\n     * @custom:access Only Governance\n     */\n    function sweepToken(IERC20Upgradeable token_, address to_, uint256 amount_) external onlyOwner {\n        uint256 balance = token_.balanceOf(address(this));\n        if (amount_ > balance) {\n            revert InsufficientBalance(amount_, balance);\n        }\n\n        emit SweepToken(address(token_), to_, amount_);\n\n        token_.safeTransfer(to_, amount_);\n    }\n\n    /**\n     * @notice Get rewards per block or second for token\n     * @param token_ Address of the token\n     * @return speed returns the per block or second reward\n     */\n    function getEffectiveDistributionSpeed(address token_) external view returns (uint256) {\n        uint256 distributionSpeed = tokenDistributionSpeeds[token_];\n        uint256 balance = IERC20Upgradeable(token_).balanceOf(address(this));\n        uint256 accrued = _tokenAmountAccrued[token_];\n\n        if (balance > accrued) {\n            return distributionSpeed;\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Accrue token by updating the distribution state\n     * @param token_ Address of the token\n     * @custom:event Emits TokensAccrued event\n     */\n    function accrueTokens(address token_) public {\n        _ensureZeroAddress(token_);\n\n        _ensureTokenInitialized(token_);\n\n        uint256 blockNumberOrSecond = getBlockNumberOrTimestamp();\n        uint256 deltaBlocksOrSeconds;\n        unchecked {\n            deltaBlocksOrSeconds = blockNumberOrSecond - lastAccruedBlockOrSecond[token_];\n        }\n\n        if (deltaBlocksOrSeconds != 0) {\n            uint256 distributionSpeed = tokenDistributionSpeeds[token_];\n            uint256 balance = IERC20Upgradeable(token_).balanceOf(address(this));\n\n            uint256 balanceDiff = balance - _tokenAmountAccrued[token_];\n            if (distributionSpeed != 0 && balanceDiff != 0) {\n                uint256 accruedSinceUpdate = deltaBlocksOrSeconds * distributionSpeed;\n                uint256 tokenAccrued = (balanceDiff <= accruedSinceUpdate ? balanceDiff : accruedSinceUpdate);\n\n                _tokenAmountAccrued[token_] += tokenAccrued;\n                emit TokensAccrued(token_, tokenAccrued);\n            }\n\n            lastAccruedBlockOrSecond[token_] = blockNumberOrSecond;\n        }\n    }\n\n    /**\n     * @notice Get the last accrued block or second for token\n     * @param token_ Address of the token\n     * @return blockNumberOrSecond returns the last accrued block or second\n     */\n    function lastAccruedBlock(address token_) external view returns (uint256) {\n        return lastAccruedBlockOrSecond[token_];\n    }\n\n    /**\n     * @notice Get the tokens accrued\n     * @param token_ Address of the token\n     * @return returns the amount of accrued tokens for the token provided\n     */\n    function tokenAmountAccrued(address token_) external view returns (uint256) {\n        return _tokenAmountAccrued[token_];\n    }\n\n    /**\n     * @notice Initialize the distribution of the token\n     * @param token_ Address of the token to be intialized\n     * @custom:event Emits TokenDistributionInitialized event\n     * @custom:error Throw TokenAlreadyInitialized if token is already initialized\n     */\n    function _initializeToken(address token_) internal {\n        _ensureZeroAddress(token_);\n        uint256 blockNumberOrSecond = getBlockNumberOrTimestamp();\n        uint256 initializedBlockOrSecond = lastAccruedBlockOrSecond[token_];\n\n        if (initializedBlockOrSecond != 0) {\n            revert TokenAlreadyInitialized(token_);\n        }\n\n        /*\n         * Update token state block number or second\n         */\n        lastAccruedBlockOrSecond[token_] = blockNumberOrSecond;\n\n        emit TokenDistributionInitialized(token_);\n    }\n\n    /**\n     * @notice Set distribution speed (amount of token distribute per block or second)\n     * @param token_ Address of the token\n     * @param distributionSpeed_ New distribution speed for token\n     * @custom:event Emits TokenDistributionSpeedUpdated event\n     * @custom:error Throw InvalidDistributionSpeed if speed is greater than max speed\n     */\n    function _setTokenDistributionSpeed(address token_, uint256 distributionSpeed_) internal {\n        uint256 maxDistributionSpeed = maxTokenDistributionSpeeds[token_];\n        if (maxDistributionSpeed == 0) {\n            maxTokenDistributionSpeeds[token_] = maxDistributionSpeed = DEFAULT_MAX_DISTRIBUTION_SPEED;\n        }\n\n        if (distributionSpeed_ > maxDistributionSpeed) {\n            revert InvalidDistributionSpeed(distributionSpeed_, maxDistributionSpeed);\n        }\n\n        uint256 oldDistributionSpeed = tokenDistributionSpeeds[token_];\n        if (oldDistributionSpeed != distributionSpeed_) {\n            // Distribution speed updated so let's update distribution state to ensure that\n            //  1. Token accrued properly for the old speed, and\n            //  2. Token accrued at the new speed starts after this block or second.\n            accrueTokens(token_);\n\n            // Update speed\n            tokenDistributionSpeeds[token_] = distributionSpeed_;\n\n            emit TokenDistributionSpeedUpdated(token_, oldDistributionSpeed, distributionSpeed_);\n        }\n    }\n\n    /**\n     * @notice Set max distribution speed (amount of maximum token distribute per block or second)\n     * @param token_ Address of the token\n     * @param maxDistributionSpeed_ New max distribution speed for token\n     * @custom:event Emits MaxTokenDistributionSpeedUpdated event\n     */\n    function _setMaxTokenDistributionSpeed(address token_, uint256 maxDistributionSpeed_) internal {\n        emit MaxTokenDistributionSpeedUpdated(token_, tokenDistributionSpeeds[token_], maxDistributionSpeed_);\n        maxTokenDistributionSpeeds[token_] = maxDistributionSpeed_;\n    }\n\n    /**\n     * @notice Revert on non initialized token\n     * @param token_ Token Address to be verified for\n     */\n    function _ensureTokenInitialized(address token_) internal view {\n        uint256 lastBlockOrSecondAccrued = lastAccruedBlockOrSecond[token_];\n\n        if (lastBlockOrSecondAccrued == 0) {\n            revert TokenNotInitialized(token_);\n        }\n    }\n\n    /**\n     * @notice Revert on zero address\n     * @param address_ Address to be verified\n     */\n    function _ensureZeroAddress(address address_) internal pure {\n        if (address_ == address(0)) {\n            revert InvalidArguments();\n        }\n    }\n}\n"
    },
    "contracts/Tokens/Prime/PrimeLiquidityProviderStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title PrimeLiquidityProviderStorageV1\n * @author Venus\n * @notice Storage for Prime Liquidity Provider\n */\ncontract PrimeLiquidityProviderStorageV1 {\n    /// @notice Address of the Prime contract\n    address public prime;\n\n    /// @notice The rate at which token is distributed (per block or second)\n    mapping(address => uint256) public tokenDistributionSpeeds;\n\n    /// @notice The max token distribution speed for token\n    mapping(address => uint256) public maxTokenDistributionSpeeds;\n\n    /// @notice The block or second till which rewards are distributed for an asset\n    mapping(address => uint256) public lastAccruedBlockOrSecond;\n\n    /// @notice The token accrued but not yet transferred to prime contract\n    mapping(address => uint256) internal _tokenAmountAccrued;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/Tokens/Prime/PrimeStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\n/**\n * @title PrimeStorageV1\n * @author Venus\n * @notice Storage for Prime Token\n */\ncontract PrimeStorageV1 {\n    struct Token {\n        bool exists;\n        bool isIrrevocable;\n    }\n\n    struct Market {\n        uint256 supplyMultiplier;\n        uint256 borrowMultiplier;\n        uint256 rewardIndex;\n        uint256 sumOfMembersScore;\n        bool exists;\n    }\n\n    struct Interest {\n        uint256 accrued;\n        uint256 score;\n        uint256 rewardIndex;\n    }\n\n    struct PendingReward {\n        address vToken;\n        address rewardToken;\n        uint256 amount;\n    }\n\n    /// @notice Base unit for computations, usually used in scaling (multiplications, divisions)\n    uint256 internal constant EXP_SCALE = 1e18;\n\n    /// @notice maximum BPS = 100%\n    uint256 internal constant MAXIMUM_BPS = 1e4;\n\n    /// @notice Mapping to get prime token's metadata\n    mapping(address => Token) public tokens;\n\n    /// @notice  Tracks total irrevocable tokens minted\n    uint256 public totalIrrevocable;\n\n    /// @notice  Tracks total revocable tokens minted\n    uint256 public totalRevocable;\n\n    /// @notice  Indicates maximum revocable tokens that can be minted\n    uint256 public revocableLimit;\n\n    /// @notice  Indicates maximum irrevocable tokens that can be minted\n    uint256 public irrevocableLimit;\n\n    /// @notice Tracks when prime token eligible users started staking for claiming prime token\n    mapping(address => uint256) public stakedAt;\n\n    /// @notice vToken to market configuration\n    mapping(address => Market) public markets;\n\n    /// @notice vToken to user to user index\n    mapping(address => mapping(address => Interest)) public interests;\n\n    /// @notice A list of boosted markets\n    address[] internal _allMarkets;\n\n    /// @notice numerator of alpha. Ex: if alpha is 0.5 then this will be 1\n    uint128 public alphaNumerator;\n\n    /// @notice denominator of alpha. Ex: if alpha is 0.5 then this will be 2\n    uint128 public alphaDenominator;\n\n    /// @notice address of XVS vault\n    address public xvsVault;\n\n    /// @notice address of XVS vault reward token\n    address public xvsVaultRewardToken;\n\n    /// @notice address of XVS vault pool id\n    uint256 public xvsVaultPoolId;\n\n    /// @notice mapping to check if a account's score was updated in the round\n    mapping(uint256 => mapping(address => bool)) public isScoreUpdated;\n\n    /// @notice unique id for next round\n    uint256 public nextScoreUpdateRoundId;\n\n    /// @notice total number of accounts whose score needs to be updated\n    uint256 public totalScoreUpdatesRequired;\n\n    /// @notice total number of accounts whose score is yet to be updated\n    uint256 public pendingScoreUpdates;\n\n    /// @notice mapping used to find if an asset is part of prime markets\n    mapping(address => address) public vTokenForAsset;\n\n    /// @notice Address of core pool comptroller contract\n    address internal corePoolComptroller;\n\n    /// @notice unreleased income from PLP that's already distributed to prime holders\n    /// @dev mapping of asset address => amount\n    mapping(address => uint256) public unreleasedPLPIncome;\n\n    /// @notice The address of PLP contract\n    address public primeLiquidityProvider;\n\n    /// @notice The address of ResilientOracle contract\n    ResilientOracleInterface public oracle;\n\n    /// @notice The address of PoolRegistry contract\n    address public poolRegistry;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    uint256[26] private __gap;\n}\n"
    },
    "contracts/Tokens/VAI/IVAI.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n\npragma solidity 0.8.25;\n\ninterface IVAI {\n    // --- Auth ---\n    function wards(address) external view returns (uint256);\n    function rely(address guy) external;\n    function deny(address guy) external;\n\n    // --- BEP20 Data ---\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function version() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n    function nonces(address) external view returns (uint256);\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    // --- EIP712 niceties ---\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    // --- Token ---\n    function transfer(address dst, uint256 wad) external returns (bool);\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n    function mint(address usr, uint256 wad) external;\n    function burn(address usr, uint256 wad) external;\n    function approve(address usr, uint256 wad) external returns (bool);\n\n    // --- Alias ---\n    function push(address usr, uint256 wad) external;\n    function pull(address usr, uint256 wad) external;\n    function move(address src, address dst, uint256 wad) external;\n\n    // --- Approve by signature ---\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/Tokens/VAI/VAIController.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport { VAIControllerErrorReporter } from \"../../Utils/ErrorReporter.sol\";\nimport { Exponential } from \"../../Utils/Exponential.sol\";\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { VToken } from \"../VTokens/VToken.sol\";\nimport { VAIUnitroller } from \"./VAIUnitroller.sol\";\nimport { VAIControllerInterface } from \"./VAIControllerInterface.sol\";\nimport { IVAI } from \"./IVAI.sol\";\nimport { IPrime } from \"../Prime/IPrime.sol\";\nimport { VTokenInterface } from \"../VTokens/VTokenInterfaces.sol\";\nimport { VAIControllerStorageG4 } from \"./VAIControllerStorage.sol\";\n\n/**\n * @title VAI Comptroller\n * @author Venus\n * @notice This is the implementation contract for the VAIUnitroller proxy\n */\ncontract VAIController is VAIControllerInterface, VAIControllerStorageG4, VAIControllerErrorReporter, Exponential {\n    /// @notice Initial index used in interest computations\n    uint256 public constant INITIAL_VAI_MINT_INDEX = 1e18;\n\n    /// @notice Emitted when Comptroller is changed\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /// @notice Emitted when mint for prime holder is changed\n    event MintOnlyForPrimeHolder(bool previousMintEnabledOnlyForPrimeHolder, bool newMintEnabledOnlyForPrimeHolder);\n\n    /// @notice Emitted when Prime is changed\n    event NewPrime(address oldPrime, address newPrime);\n\n    /// @notice Event emitted when VAI is minted\n    event MintVAI(address minter, uint256 mintVAIAmount);\n\n    /// @notice Event emitted when VAI is repaid\n    event RepayVAI(address payer, address borrower, uint256 repayVAIAmount);\n\n    /// @notice Event emitted when a borrow is liquidated\n    event LiquidateVAI(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address vTokenCollateral,\n        uint256 seizeTokens\n    );\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint256 oldTreasuryPercent, uint256 newTreasuryPercent);\n\n    /// @notice Event emitted when VAIs are minted and fee are transferred\n    event MintFee(address minter, uint256 feeAmount);\n\n    /// @notice Emiitted when VAI base rate is changed\n    event NewVAIBaseRate(uint256 oldBaseRateMantissa, uint256 newBaseRateMantissa);\n\n    /// @notice Emiitted when VAI float rate is changed\n    event NewVAIFloatRate(uint256 oldFloatRateMantissa, uint256 newFlatRateMantissa);\n\n    /// @notice Emiitted when VAI receiver address is changed\n    event NewVAIReceiver(address oldReceiver, address newReceiver);\n\n    /// @notice Emiitted when VAI mint cap is changed\n    event NewVAIMintCap(uint256 oldMintCap, uint256 newMintCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when VAI token address is changed by admin\n    event NewVaiToken(address oldVaiToken, address newVaiToken);\n\n    function initialize() external onlyAdmin {\n        require(vaiMintIndex == 0, \"already initialized\");\n\n        vaiMintIndex = INITIAL_VAI_MINT_INDEX;\n        accrualBlockNumber = getBlockNumber();\n        mintCap = type(uint256).max;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    function _become(VAIUnitroller unitroller) external {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n    }\n\n    /**\n     * @notice The mintVAI function mints and transfers VAI from the protocol to the user, and adds a borrow balance.\n     * The amount minted must be less than the user's Account Liquidity and the mint vai limit.\n     * @dev If the Comptroller address is not set, minting is a no-op and the function returns the success code.\n     * @param mintVAIAmount The amount of the VAI to be minted.\n     * @return 0 on success, otherwise an error code\n     */\n    // solhint-disable-next-line code-complexity\n    function mintVAI(uint256 mintVAIAmount) external nonReentrant returns (uint256) {\n        if (address(comptroller) == address(0)) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        _ensureNonzeroAmount(mintVAIAmount);\n        _ensureNotPaused();\n        accrueVAIInterest();\n\n        uint256 err;\n        address minter = msg.sender;\n        address _vai = vai;\n        uint256 vaiTotalSupply = IVAI(_vai).totalSupply();\n\n        uint256 vaiNewTotalSupply = add_(vaiTotalSupply, mintVAIAmount);\n        require(vaiNewTotalSupply <= mintCap, \"mint cap reached\");\n\n        uint256 accountMintableVAI;\n        (err, accountMintableVAI) = getMintableVAI(minter);\n        require(err == uint256(Error.NO_ERROR), \"could not compute mintable amount\");\n\n        // check that user have sufficient mintableVAI balance\n        require(mintVAIAmount <= accountMintableVAI, \"minting more than allowed\");\n\n        // Calculate the minted balance based on interest index\n        uint256 totalMintedVAI = comptroller.mintedVAIs(minter);\n\n        if (totalMintedVAI > 0) {\n            uint256 repayAmount = getVAIRepayAmount(minter);\n            uint256 remainedAmount = sub_(repayAmount, totalMintedVAI);\n            pastVAIInterest[minter] = add_(pastVAIInterest[minter], remainedAmount);\n            totalMintedVAI = repayAmount;\n        }\n\n        uint256 accountMintVAINew = add_(totalMintedVAI, mintVAIAmount);\n        err = comptroller.setMintedVAIOf(minter, accountMintVAINew);\n        require(err == uint256(Error.NO_ERROR), \"comptroller rejection\");\n\n        uint256 remainedAmount;\n        if (treasuryPercent != 0) {\n            uint256 feeAmount = div_(mul_(mintVAIAmount, treasuryPercent), 1e18);\n            remainedAmount = sub_(mintVAIAmount, feeAmount);\n            IVAI(_vai).mint(treasuryAddress, feeAmount);\n\n            emit MintFee(minter, feeAmount);\n        } else {\n            remainedAmount = mintVAIAmount;\n        }\n\n        IVAI(_vai).mint(minter, remainedAmount);\n        vaiMinterInterestIndex[minter] = vaiMintIndex;\n\n        emit MintVAI(minter, remainedAmount);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice The repay function transfers VAI interest into the protocol and burns the rest,\n     * reducing the borrower's borrow balance. Before repaying VAI, users must first approve\n     * VAIController to access their VAI balance.\n     * @dev If the Comptroller address is not set, repayment is a no-op and the function returns the success code.\n     * @param amount The amount of VAI to be repaid.\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function repayVAI(uint256 amount) external nonReentrant returns (uint256, uint256) {\n        return _repayVAI(msg.sender, amount);\n    }\n\n    /**\n     * @notice The repay on behalf function transfers VAI interest into the protocol and burns the rest,\n     * reducing the borrower's borrow balance. Borrowed VAIs are repaid by another user (possibly the borrower).\n     * Before repaying VAI, the payer must first approve VAIController to access their VAI balance.\n     * @dev If the Comptroller address is not set, repayment is a no-op and the function returns the success code.\n     * @param borrower The account to repay the debt for.\n     * @param amount The amount of VAI to be repaid.\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function repayVAIBehalf(address borrower, uint256 amount) external nonReentrant returns (uint256, uint256) {\n        _ensureNonzeroAddress(borrower);\n        return _repayVAI(borrower, amount);\n    }\n\n    /**\n     * @dev Checks the parameters and the protocol state, accrues interest, and invokes repayVAIFresh.\n     * @dev If the Comptroller address is not set, repayment is a no-op and the function returns the success code.\n     * @param borrower The account to repay the debt for.\n     * @param amount The amount of VAI to be repaid.\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function _repayVAI(address borrower, uint256 amount) internal returns (uint256, uint256) {\n        if (address(comptroller) == address(0)) {\n            return (0, 0);\n        }\n        _ensureNonzeroAmount(amount);\n        _ensureNotPaused();\n\n        accrueVAIInterest();\n        return repayVAIFresh(msg.sender, borrower, amount);\n    }\n\n    /**\n     * @dev Repay VAI, expecting interest to be accrued\n     * @dev Borrowed VAIs are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the VAI\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of VAI being repaid\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function repayVAIFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256, uint256) {\n        (uint256 burn, uint256 partOfCurrentInterest, uint256 partOfPastInterest) = getVAICalculateRepayAmount(\n            borrower,\n            repayAmount\n        );\n\n        IVAI _vai = IVAI(vai);\n        _vai.burn(payer, burn);\n        bool success = _vai.transferFrom(payer, receiver, partOfCurrentInterest);\n        require(success == true, \"failed to transfer VAI fee\");\n\n        uint256 vaiBalanceBorrower = comptroller.mintedVAIs(borrower);\n\n        uint256 accountVAINew = sub_(sub_(vaiBalanceBorrower, burn), partOfPastInterest);\n        pastVAIInterest[borrower] = sub_(pastVAIInterest[borrower], partOfPastInterest);\n\n        uint256 error = comptroller.setMintedVAIOf(borrower, accountVAINew);\n        // We have to revert upon error since side-effects already happened at this point\n        require(error == uint256(Error.NO_ERROR), \"comptroller rejection\");\n\n        uint256 repaidAmount = add_(burn, partOfCurrentInterest);\n        emit RepayVAI(payer, borrower, repaidAmount);\n\n        return (uint256(Error.NO_ERROR), repaidAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the vai minters collateral. The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of vai to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function liquidateVAI(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external nonReentrant returns (uint256, uint256) {\n        _ensureNotPaused();\n\n        uint256 error = vTokenCollateral.accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.VAI_LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateVAIFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateVAIFresh(msg.sender, borrower, repayAmount, vTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral by repay borrowers VAI.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev If the Comptroller address is not set, liquidation is a no-op and the function returns the success code.\n     * @param liquidator The address repaying the VAI and seizing collateral\n     * @param borrower The borrower of this VAI to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the VAI to repay\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function liquidateVAIFresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) internal returns (uint256, uint256) {\n        if (address(comptroller) != address(0)) {\n            accrueVAIInterest();\n\n            /* Fail if liquidate not allowed */\n            uint256 allowed = comptroller.liquidateBorrowAllowed(\n                address(this),\n                address(vTokenCollateral),\n                liquidator,\n                borrower,\n                repayAmount\n            );\n            if (allowed != 0) {\n                return (failOpaque(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n            }\n\n            /* Verify vTokenCollateral market's block number equals current block number */\n            //if (vTokenCollateral.accrualBlockNumber() != accrualBlockNumber) {\n            if (vTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n            }\n\n            /* Fail if borrower = liquidator */\n            if (borrower == liquidator) {\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n            }\n\n            /* Fail if repayAmount = 0 */\n            if (repayAmount == 0) {\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n            }\n\n            /* Fail if repayAmount = type(uint256).max */\n            if (repayAmount == type(uint256).max) {\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n            }\n\n            /* Fail if repayVAI fails */\n            (uint256 repayBorrowError, uint256 actualRepayAmount) = repayVAIFresh(liquidator, borrower, repayAmount);\n            if (repayBorrowError != uint256(Error.NO_ERROR)) {\n                return (fail(Error(repayBorrowError), FailureInfo.VAI_LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n            }\n\n            /////////////////////////\n            // EFFECTS & INTERACTIONS\n            // (No safe failures beyond this point)\n\n            /* We calculate the number of collateral tokens that will be seized */\n            (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateVAICalculateSeizeTokens(\n                address(vTokenCollateral),\n                actualRepayAmount\n            );\n            require(\n                amountSeizeError == uint256(Error.NO_ERROR),\n                \"VAI_LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\"\n            );\n\n            /* Revert if borrower collateral token balance < seizeTokens */\n            require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \"VAI_LIQUIDATE_SEIZE_TOO_MUCH\");\n\n            uint256 seizeError;\n            seizeError = vTokenCollateral.seize(liquidator, borrower, seizeTokens);\n\n            /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n            require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n            /* We emit a LiquidateBorrow event */\n            emit LiquidateVAI(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\n\n            /* We call the defense hook */\n            comptroller.liquidateBorrowVerify(\n                address(this),\n                address(vTokenCollateral),\n                liquidator,\n                borrower,\n                actualRepayAmount,\n                seizeTokens\n            );\n\n            return (uint256(Error.NO_ERROR), actualRepayAmount);\n        }\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Sets a new comptroller\n     * @dev Admin function to set a new comptroller\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface comptroller_) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n\n        ComptrollerInterface oldComptroller = comptroller;\n        comptroller = comptroller_;\n        emit NewComptroller(oldComptroller, comptroller_);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the prime token contract address\n     * @param prime_ The new address of the prime token contract\n     */\n    function setPrimeToken(address prime_) external onlyAdmin {\n        emit NewPrime(prime, prime_);\n        prime = prime_;\n    }\n\n    /**\n     * @notice Set the VAI token contract address\n     * @param vai_ The new address of the VAI token contract\n     */\n    function setVAIToken(address vai_) external onlyAdmin {\n        emit NewVaiToken(vai, vai_);\n        vai = vai_;\n    }\n\n    /**\n     * @notice Toggle mint only for prime holder\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function toggleOnlyPrimeHolderMint() external returns (uint256) {\n        _ensureAllowed(\"toggleOnlyPrimeHolderMint()\");\n\n        if (!mintEnabledOnlyForPrimeHolder && prime == address(0)) {\n            return uint256(Error.REJECTION);\n        }\n\n        emit MintOnlyForPrimeHolder(mintEnabledOnlyForPrimeHolder, !mintEnabledOnlyForPrimeHolder);\n        mintEnabledOnlyForPrimeHolder = !mintEnabledOnlyForPrimeHolder;\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account total supply balance.\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountAmountLocalVars {\n        uint256 oErr;\n        MathError mErr;\n        uint256 sumSupply;\n        uint256 marketSupply;\n        uint256 sumBorrowPlusEffects;\n        uint256 vTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Function that returns the amount of VAI a user can mint based on their account liquidy and the VAI mint rate\n     * If mintEnabledOnlyForPrimeHolder is true, only Prime holders are able to mint VAI\n     * @param minter The account to check mintable VAI\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol for details)\n     * @return Mintable amount (with 18 decimals)\n     */\n    // solhint-disable-next-line code-complexity\n    function getMintableVAI(address minter) public view returns (uint256, uint256) {\n        if (mintEnabledOnlyForPrimeHolder && !IPrime(prime).isUserPrimeHolder(minter)) {\n            return (uint256(Error.REJECTION), 0);\n        }\n\n        ResilientOracleInterface oracle = comptroller.oracle();\n        VToken[] memory enteredMarkets = comptroller.getAssetsIn(minter);\n\n        AccountAmountLocalVars memory vars; // Holds all our calculation results\n\n        uint256 accountMintableVAI;\n        uint256 i;\n\n        /**\n         * We use this formula to calculate mintable VAI amount.\n         * totalSupplyAmount * VAIMintRate - (totalBorrowAmount + mintedVAIOf)\n         */\n        uint256 marketsCount = enteredMarkets.length;\n        for (i = 0; i < marketsCount; i++) {\n            (vars.oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = enteredMarkets[i]\n                .getAccountSnapshot(minter);\n            if (vars.oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (uint256(Error.SNAPSHOT_ERROR), 0);\n            }\n            vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(address(enteredMarkets[i]));\n            if (vars.oraclePriceMantissa == 0) {\n                return (uint256(Error.PRICE_ERROR), 0);\n            }\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n            (vars.mErr, vars.tokensToDenom) = mulExp(vars.exchangeRate, vars.oraclePrice);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            // marketSupply = tokensToDenom * vTokenBalance\n            (vars.mErr, vars.marketSupply) = mulScalarTruncate(vars.tokensToDenom, vars.vTokenBalance);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            (, uint256 collateralFactorMantissa) = comptroller.markets(address(enteredMarkets[i]));\n            (vars.mErr, vars.marketSupply) = mulUInt(vars.marketSupply, collateralFactorMantissa);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            (vars.mErr, vars.marketSupply) = divUInt(vars.marketSupply, 1e18);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            (vars.mErr, vars.sumSupply) = addUInt(vars.sumSupply, vars.marketSupply);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            (vars.mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n        }\n\n        uint256 totalMintedVAI = comptroller.mintedVAIs(minter);\n        uint256 repayAmount = 0;\n\n        if (totalMintedVAI > 0) {\n            repayAmount = getVAIRepayAmount(minter);\n        }\n\n        (vars.mErr, vars.sumBorrowPlusEffects) = addUInt(vars.sumBorrowPlusEffects, repayAmount);\n        if (vars.mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0);\n        }\n\n        (vars.mErr, accountMintableVAI) = mulUInt(vars.sumSupply, comptroller.vaiMintRate());\n        require(vars.mErr == MathError.NO_ERROR, \"VAI_MINT_AMOUNT_CALCULATION_FAILED\");\n\n        (vars.mErr, accountMintableVAI) = divUInt(accountMintableVAI, 10000);\n        require(vars.mErr == MathError.NO_ERROR, \"VAI_MINT_AMOUNT_CALCULATION_FAILED\");\n\n        (vars.mErr, accountMintableVAI) = subUInt(accountMintableVAI, vars.sumBorrowPlusEffects);\n        if (vars.mErr != MathError.NO_ERROR) {\n            return (uint256(Error.REJECTION), 0);\n        }\n\n        return (uint256(Error.NO_ERROR), accountMintableVAI);\n    }\n\n    /**\n     * @notice Update treasury data\n     * @param newTreasuryGuardian New Treasury Guardian address\n     * @param newTreasuryAddress New Treasury Address\n     * @param newTreasuryPercent New fee percentage for minting VAI that is sent to the treasury\n     */\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256) {\n        // Check caller is admin\n        if (!(msg.sender == admin || msg.sender == treasuryGuardian)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TREASURY_OWNER_CHECK);\n        }\n\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint256 oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Gets yearly VAI interest rate based on the VAI price\n     * @return uint256 Yearly VAI interest rate\n     */\n    function getVAIRepayRate() public view returns (uint256) {\n        ResilientOracleInterface oracle = comptroller.oracle();\n        MathError mErr;\n\n        if (baseRateMantissa > 0) {\n            if (floatRateMantissa > 0) {\n                uint256 oraclePrice = oracle.getUnderlyingPrice(getVAIAddress());\n                if (1e18 > oraclePrice) {\n                    uint256 delta;\n                    uint256 rate;\n\n                    (mErr, delta) = subUInt(1e18, oraclePrice);\n                    require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n                    (mErr, delta) = mulUInt(delta, floatRateMantissa);\n                    require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n                    (mErr, delta) = divUInt(delta, 1e18);\n                    require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n                    (mErr, rate) = addUInt(delta, baseRateMantissa);\n                    require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n                    return rate;\n                } else {\n                    return baseRateMantissa;\n                }\n            } else {\n                return baseRateMantissa;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get interest rate per block\n     * @return uint256 Interest rate per bock\n     */\n    function getVAIRepayRatePerBlock() public view returns (uint256) {\n        uint256 yearlyRate = getVAIRepayRate();\n\n        MathError mErr;\n        uint256 rate;\n\n        (mErr, rate) = divUInt(yearlyRate, getBlocksPerYear());\n        require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n        return rate;\n    }\n\n    /**\n     * @notice Get the last updated interest index for a VAI Minter\n     * @param minter Address of VAI minter\n     * @return uint256 Returns the interest rate index for a minter\n     */\n    function getVAIMinterInterestIndex(address minter) public view returns (uint256) {\n        uint256 storedIndex = vaiMinterInterestIndex[minter];\n        // If the user minted VAI before the stability fee was introduced, accrue\n        // starting from stability fee launch\n        if (storedIndex == 0) {\n            return INITIAL_VAI_MINT_INDEX;\n        }\n        return storedIndex;\n    }\n\n    /**\n     * @notice Get the current total VAI a user needs to repay\n     * @param account The address of the VAI borrower\n     * @return (uint256) The total amount of VAI the user needs to repay\n     */\n    function getVAIRepayAmount(address account) public view returns (uint256) {\n        MathError mErr;\n        uint256 delta;\n\n        uint256 amount = comptroller.mintedVAIs(account);\n        uint256 interest = pastVAIInterest[account];\n        uint256 totalMintedVAI;\n        uint256 newInterest;\n\n        (mErr, totalMintedVAI) = subUInt(amount, interest);\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, delta) = subUInt(vaiMintIndex, getVAIMinterInterestIndex(account));\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, newInterest) = mulUInt(delta, totalMintedVAI);\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, newInterest) = divUInt(newInterest, 1e18);\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, amount) = addUInt(amount, newInterest);\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        return amount;\n    }\n\n    /**\n     * @notice Calculate how much VAI the user needs to repay\n     * @param borrower The address of the VAI borrower\n     * @param repayAmount The amount of VAI being returned\n     * @return Amount of VAI to be burned\n     * @return Amount of VAI the user needs to pay in current interest\n     * @return Amount of VAI the user needs to pay in past interest\n     */\n    function getVAICalculateRepayAmount(\n        address borrower,\n        uint256 repayAmount\n    ) public view returns (uint256, uint256, uint256) {\n        MathError mErr;\n        uint256 totalRepayAmount = getVAIRepayAmount(borrower);\n        uint256 currentInterest;\n\n        (mErr, currentInterest) = subUInt(totalRepayAmount, comptroller.mintedVAIs(borrower));\n        require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, currentInterest) = addUInt(pastVAIInterest[borrower], currentInterest);\n        require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n\n        uint256 burn;\n        uint256 partOfCurrentInterest = currentInterest;\n        uint256 partOfPastInterest = pastVAIInterest[borrower];\n\n        if (repayAmount >= totalRepayAmount) {\n            (mErr, burn) = subUInt(totalRepayAmount, currentInterest);\n            require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n        } else {\n            uint256 delta;\n\n            (mErr, delta) = mulUInt(repayAmount, 1e18);\n            require(mErr == MathError.NO_ERROR, \"VAI_PART_CALCULATION_FAILED\");\n\n            (mErr, delta) = divUInt(delta, totalRepayAmount);\n            require(mErr == MathError.NO_ERROR, \"VAI_PART_CALCULATION_FAILED\");\n\n            uint256 totalMintedAmount;\n            (mErr, totalMintedAmount) = subUInt(totalRepayAmount, currentInterest);\n            require(mErr == MathError.NO_ERROR, \"VAI_MINTED_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, burn) = mulUInt(totalMintedAmount, delta);\n            require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, burn) = divUInt(burn, 1e18);\n            require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, partOfCurrentInterest) = mulUInt(currentInterest, delta);\n            require(mErr == MathError.NO_ERROR, \"VAI_CURRENT_INTEREST_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, partOfCurrentInterest) = divUInt(partOfCurrentInterest, 1e18);\n            require(mErr == MathError.NO_ERROR, \"VAI_CURRENT_INTEREST_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, partOfPastInterest) = mulUInt(pastVAIInterest[borrower], delta);\n            require(mErr == MathError.NO_ERROR, \"VAI_PAST_INTEREST_CALCULATION_FAILED\");\n\n            (mErr, partOfPastInterest) = divUInt(partOfPastInterest, 1e18);\n            require(mErr == MathError.NO_ERROR, \"VAI_PAST_INTEREST_CALCULATION_FAILED\");\n        }\n\n        return (burn, partOfCurrentInterest, partOfPastInterest);\n    }\n\n    /**\n     * @notice Accrue interest on outstanding minted VAI\n     */\n    function accrueVAIInterest() public {\n        MathError mErr;\n        uint256 delta;\n\n        (mErr, delta) = mulUInt(getVAIRepayRatePerBlock(), getBlockNumber() - accrualBlockNumber);\n        require(mErr == MathError.NO_ERROR, \"VAI_INTEREST_ACCRUE_FAILED\");\n\n        (mErr, delta) = addUInt(delta, vaiMintIndex);\n        require(mErr == MathError.NO_ERROR, \"VAI_INTEREST_ACCRUE_FAILED\");\n\n        vaiMintIndex = delta;\n        accrualBlockNumber = getBlockNumber();\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlAddress New address for the access control\n     */\n    function setAccessControl(address newAccessControlAddress) external onlyAdmin {\n        _ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, accessControl);\n    }\n\n    /**\n     * @notice Set VAI borrow base rate\n     * @param newBaseRateMantissa the base rate multiplied by 10**18\n     */\n    function setBaseRate(uint256 newBaseRateMantissa) external {\n        _ensureAllowed(\"setBaseRate(uint256)\");\n\n        uint256 old = baseRateMantissa;\n        baseRateMantissa = newBaseRateMantissa;\n        emit NewVAIBaseRate(old, baseRateMantissa);\n    }\n\n    /**\n     * @notice Set VAI borrow float rate\n     * @param newFloatRateMantissa the VAI float rate multiplied by 10**18\n     */\n    function setFloatRate(uint256 newFloatRateMantissa) external {\n        _ensureAllowed(\"setFloatRate(uint256)\");\n\n        uint256 old = floatRateMantissa;\n        floatRateMantissa = newFloatRateMantissa;\n        emit NewVAIFloatRate(old, floatRateMantissa);\n    }\n\n    /**\n     * @notice Set VAI stability fee receiver address\n     * @param newReceiver the address of the VAI fee receiver\n     */\n    function setReceiver(address newReceiver) external onlyAdmin {\n        _ensureNonzeroAddress(newReceiver);\n\n        address old = receiver;\n        receiver = newReceiver;\n        emit NewVAIReceiver(old, newReceiver);\n    }\n\n    /**\n     * @notice Set VAI mint cap\n     * @param _mintCap the amount of VAI that can be minted\n     */\n    function setMintCap(uint256 _mintCap) external {\n        _ensureAllowed(\"setMintCap(uint256)\");\n\n        uint256 old = mintCap;\n        mintCap = _mintCap;\n        emit NewVAIMintCap(old, _mintCap);\n    }\n\n    function getBlockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    function getBlocksPerYear() public view virtual returns (uint256) {\n        return 42048000; //(24 * 60 * 60 * 365) / 0.75;\n    }\n\n    /**\n     * @notice Return the address of the VAI token\n     * @return The address of VAI\n     */\n    function getVAIAddress() public view virtual returns (address) {\n        return vai;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin can\");\n        _;\n    }\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    function _ensureAllowed(string memory functionSig) private view {\n        require(IAccessControlManagerV8(accessControl).isAllowedToCall(msg.sender, functionSig), \"access denied\");\n    }\n\n    /// @dev Reverts if the protocol is paused\n    function _ensureNotPaused() private view {\n        require(!comptroller.protocolPaused(), \"protocol is paused\");\n    }\n\n    /// @dev Reverts if the passed address is zero\n    function _ensureNonzeroAddress(address someone) private pure {\n        require(someone != address(0), \"can't be zero address\");\n    }\n\n    /// @dev Reverts if the passed amount is zero\n    function _ensureNonzeroAmount(uint256 amount) private pure {\n        require(amount > 0, \"amount can't be zero\");\n    }\n}\n"
    },
    "contracts/Tokens/VAI/VAIControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VTokenInterface } from \"../VTokens/VTokenInterfaces.sol\";\n\ninterface VAIControllerInterface {\n    function mintVAI(uint256 mintVAIAmount) external returns (uint256);\n\n    function repayVAI(uint256 amount) external returns (uint256, uint256);\n\n    function repayVAIBehalf(address borrower, uint256 amount) external returns (uint256, uint256);\n\n    function liquidateVAI(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint256, uint256);\n\n    function getMintableVAI(address minter) external view returns (uint256, uint256);\n\n    function getVAIAddress() external view returns (address);\n\n    function getVAIRepayAmount(address account) external view returns (uint256);\n}\n"
    },
    "contracts/Tokens/VAI/VAIControllerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\n\ncontract VAIUnitrollerAdminStorage {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public vaiControllerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingVAIControllerImplementation;\n}\n\ncontract VAIControllerStorageG1 is VAIUnitrollerAdminStorage {\n    ComptrollerInterface public comptroller;\n\n    struct VenusVAIState {\n        /// @notice The last updated venusVAIMintIndex\n        uint224 index;\n        /// @notice The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice The Venus VAI state\n    VenusVAIState public venusVAIState;\n\n    /// @notice The Venus VAI state initialized\n    bool public isVenusVAIInitialized;\n\n    /// @notice The Venus VAI minter index as of the last time they accrued XVS\n    mapping(address => uint256) public venusVAIMinterIndex;\n}\n\ncontract VAIControllerStorageG2 is VAIControllerStorageG1 {\n    /// @notice Treasury Guardian address\n    address public treasuryGuardian;\n\n    /// @notice Treasury address\n    address public treasuryAddress;\n\n    /// @notice Fee percent of accrued interest with decimal 18\n    uint256 public treasuryPercent;\n\n    /// @notice Guard variable for re-entrancy checks\n    bool internal _notEntered;\n\n    /// @notice The base rate for stability fee\n    uint256 public baseRateMantissa;\n\n    /// @notice The float rate for stability fee\n    uint256 public floatRateMantissa;\n\n    /// @notice The address for VAI interest receiver\n    address public receiver;\n\n    /// @notice Accumulator of the total earned interest rate since the opening of the market. For example: 0.6 (60%)\n    uint256 public vaiMintIndex;\n\n    /// @notice Block number that interest was last accrued at\n    uint256 internal accrualBlockNumber;\n\n    /// @notice Global vaiMintIndex as of the most recent balance-changing action for user\n    mapping(address => uint256) internal vaiMinterInterestIndex;\n\n    /// @notice Tracks the amount of mintedVAI of a user that represents the accrued interest\n    mapping(address => uint256) public pastVAIInterest;\n\n    /// @notice VAI mint cap\n    uint256 public mintCap;\n\n    /// @notice Access control manager address\n    address public accessControl;\n}\n\ncontract VAIControllerStorageG3 is VAIControllerStorageG2 {\n    /// @notice The address of the prime contract. It can be a ZERO address\n    address public prime;\n\n    /// @notice Tracks if minting is enabled only for prime token holders. Only used if prime is set\n    bool public mintEnabledOnlyForPrimeHolder;\n}\n\ncontract VAIControllerStorageG4 is VAIControllerStorageG3 {\n    /// @notice The address of the VAI token\n    address internal vai;\n}\n"
    },
    "contracts/Tokens/VAI/VAIUnitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { VAIControllerErrorReporter } from \"../../Utils/ErrorReporter.sol\";\nimport { VAIUnitrollerAdminStorage } from \"./VAIControllerStorage.sol\";\n\n/**\n * @title VAI Unitroller\n * @author Venus\n * @notice This is the proxy contract for the VAIComptroller\n */\ncontract VAIUnitroller is VAIUnitrollerAdminStorage, VAIControllerErrorReporter {\n    /**\n     * @notice Emitted when pendingVAIControllerImplementation is changed\n     */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n     * @notice Emitted when pendingVAIControllerImplementation is accepted, which means comptroller implementation is updated\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint256) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n        }\n\n        address oldPendingImplementation = pendingVAIControllerImplementation;\n\n        pendingVAIControllerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingVAIControllerImplementation);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptImplementation() public returns (uint256) {\n        // Check caller is pendingImplementation\n        if (msg.sender != pendingVAIControllerImplementation) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = vaiControllerImplementation;\n        address oldPendingImplementation = pendingVAIControllerImplementation;\n\n        vaiControllerImplementation = pendingVAIControllerImplementation;\n\n        pendingVAIControllerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, vaiControllerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingVAIControllerImplementation);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint256) {\n        // Check caller is pendingAdmin\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = vaiControllerImplementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VBep20Interface, VTokenInterface } from \"./VTokenInterfaces.sol\";\nimport { VToken } from \"./VToken.sol\";\n\n/**\n * @title Venus's VBep20 Contract\n * @notice vTokens which wrap an ERC-20 underlying\n * @author Venus\n */\ncontract VBep20 is VToken, VBep20Interface {\n    using SafeERC20 for IERC20;\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits Mint event\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err, ) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param receiver The account which is receiving the vTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits MintBehalf event\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\n        (uint err, ) = mintBehalfInternal(receiver, mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The user on behalf of whom to redeem\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemBehalf(address redeemer, uint redeemTokens) external returns (uint) {\n        require(comptroller.approvedDelegates(redeemer, msg.sender), \"not an approved delegate\");\n\n        return redeemInternal(redeemer, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender redeems underlying assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer, on behalf of whom to redeem\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlyingBehalf(address redeemer, uint redeemAmount) external returns (uint) {\n        require(comptroller.approvedDelegates(redeemer, msg.sender), \"not an approved delegate\");\n\n        return redeemUnderlyingInternal(redeemer, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the borrower using `comptroller.updateDelegate`\n     * @param borrower The borrower, on behalf of whom to borrow.\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrowBehalf(address borrower, uint borrowAmount) external returns (uint) {\n        require(comptroller.approvedDelegates(borrower, msg.sender), \"not an approved delegate\");\n        return borrowInternal(borrower, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrowing account\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emit LiquidateBorrow event on success\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint) {\n        (uint err, ) = liquidateBorrowInternal(borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount of underlying tokens to add as reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits ReservesAdded event\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        // VToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @dev Similar to ERC-20 transfer, but handles tokens that have transfer fees.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     * @param from Sender of the underlying tokens\n     * @param amount Amount of underlying to transfer\n     * @return Actual amount received\n     */\n    function doTransferIn(address from, uint256 amount) internal virtual override returns (uint256) {\n        IERC20 token = IERC20(underlying);\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        uint256 balanceAfter = token.balanceOf(address(this));\n        // Return the amount that was *actually* transferred\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Just a regular ERC-20 transfer, reverts on failure\n     * @param to Receiver of the underlying tokens\n     * @param amount Amount of underlying to transfer\n     */\n    function doTransferOut(address payable to, uint256 amount) internal virtual override {\n        IERC20 token = IERC20(underlying);\n        token.safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Delegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VBep20 } from \"./VBep20.sol\";\nimport { VDelegateInterface } from \"./VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20Delegate Contract\n * @notice VTokens which wrap an EIP-20 underlying and are delegated to\n * @author Venus\n */\ncontract VBep20Delegate is VBep20, VDelegateInterface {\n    /**\n     * @notice Construct an empty delegate\n     */\n    constructor() {}\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) public {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() public {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Delegator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VTokenInterface, VBep20Interface, VDelegatorInterface } from \"./VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20Delegator Contract\n * @notice vTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Venus\n */\ncontract VBep20Delegator is VTokenInterface, VBep20Interface, VDelegatorInterface {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address implementation_,\n        bytes memory becomeImplementationData\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"initialize(address,address,address,uint256,string,string,uint8)\",\n                underlying_,\n                comptroller_,\n                interestRateModel_,\n                initialExchangeRateMantissa_,\n                name_,\n                symbol_,\n                decimals_\n            )\n        );\n\n        // New implementations always get set via the settor (post-initialize)\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mint(uint256)\", mintAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"mintBehalf(address,uint256)\", receiver, mintAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying asset\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function borrow(uint borrowAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrower\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"liquidateBorrow(address,uint256,address)\", borrower, repayAmount, vTokenCollateral)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount));\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", src, dst, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (type(uint256).max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  It's absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function seize(address liquidator, address borrower, uint seizeTokens) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"seize(address,address,uint256)\", liquidator, borrower, seizeTokens)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setReserveFactor(uint newReserveFactorMantissa) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. `msg.sender` must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _acceptAdmin() external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and adds reserves by transferring from admin\n     * @param addAmount Amount of reserves to add\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _reduceReserves(uint reduceAmount) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getCash()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (type(uint256).max means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"allowance(address,address)\", owner, spender)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"balanceOf(address)\", owner));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint, uint, uint, uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"getAccountSnapshot(address)\", account)\n        );\n        return abi.decode(data, (uint, uint, uint, uint));\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this vToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    // @custom:access Only callable by admin\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) public {\n        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n\n        if (allowResign) {\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n        }\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves.\n     * @dev This calculates interest accrued from the last checkpointed block\n     *      up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Admin function to set a new comptroller\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and updates the interest rate model using `_setInterestRateModelFresh`\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel The new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel) public override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n        return delegateTo(implementation, data);\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(\n            abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data)\n        );\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"borrowBalanceStored(address)\", account)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Immutable.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VBep20 } from \"./VBep20.sol\";\n\n/**\n * @title Venus's VBep20Immutable Contract\n * @notice VTokens which wrap an EIP-20 underlying and are immutable\n * @author Venus\n */\ncontract VBep20Immutable is VBep20 {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        // Initialize the market\n        initialize(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_\n        );\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBNB.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VToken } from \"./VToken.sol\";\n\n/**\n * @title Venus's vBNB Contract\n * @notice vToken which wraps BNB\n * @author Venus\n */\ncontract VBNB is VToken {\n    /**\n     * @notice Construct a new vBNB money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n    constructor(\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Send BNB to VBNB to mint\n     */\n    receive() external payable {\n        (uint err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Reverts upon any failure\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits Mint event\n    function mint() external payable {\n        (uint err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @dev Reverts upon any failure\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrow() external payable {\n        (uint err, ) = repayBorrowInternal(msg.value);\n        requireNoError(err, \"repayBorrow failed\");\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @dev Reverts upon any failure\n     * @param borrower The account with the debt being payed off\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrowBehalf(address borrower) external payable {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, msg.value);\n        requireNoError(err, \"repayBorrowBehalf failed\");\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev Reverts upon any failure\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     */\n    // @custom:event Emit LiquidateBorrow event on success\n    function liquidateBorrow(address borrower, VToken vTokenCollateral) external payable {\n        (uint err, ) = liquidateBorrowInternal(borrower, msg.value, vTokenCollateral);\n        requireNoError(err, \"liquidateBorrow failed\");\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Perform the actual transfer in, which is a no-op\n     * @param from Address sending the BNB\n     * @param amount Amount of BNB being sent\n     * @return The actual amount of BNB transferred\n     */\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\n        // Sanity checks\n        require(msg.sender == from, \"sender mismatch\");\n        require(msg.value == amount, \"value mismatch\");\n        return amount;\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        /* Send the BNB, with minimal gas and revert on failure */\n        to.transfer(amount);\n    }\n\n    /**\n     * @notice Gets balance of this contract in terms of BNB, before this message\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of BNB owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n        require(err == MathError.NO_ERROR, \"cash prior math error\");\n        return startingBalance;\n    }\n\n    function requireNoError(uint errCode, string memory message) internal pure {\n        if (errCode == uint(Error.NO_ERROR)) {\n            return;\n        }\n\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\n        uint i;\n\n        for (i = 0; i < bytes(message).length; i++) {\n            fullMessage[i] = bytes(message)[i];\n        }\n\n        fullMessage[i + 0] = bytes1(uint8(32));\n        fullMessage[i + 1] = bytes1(uint8(40));\n        fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 10)));\n        fullMessage[i + 3] = bytes1(uint8(48 + (errCode % 10)));\n        fullMessage[i + 4] = bytes1(uint8(41));\n\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport { IProtocolShareReserve } from \"../../external/IProtocolShareReserve.sol\";\nimport { ComptrollerInterface, IComptroller } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { TokenErrorReporter } from \"../../Utils/ErrorReporter.sol\";\nimport { Exponential } from \"../../Utils/Exponential.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VTokenInterface } from \"./VTokenInterfaces.sol\";\n\n/**\n * @title Venus's vToken Contract\n * @notice Abstract base for vTokens\n * @author Venus\n */\nabstract contract VToken is VTokenInterface, Exponential, TokenErrorReporter {\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    // @custom:event Emits Transfer event\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    // @custom:event Emits Transfer event\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (type(uint256).max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    // @custom:event Emits Approval event on successful approve\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        transferAllowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        ensureNoMathError(mErr);\n        return balance;\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless:\n     *     - Called by another vToken during the liquidation process, OR\n     *     - Called directly by a whitelisted executor.\n     *  Its absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    function seize(\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external override nonReentrant returns (uint) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewPendingAdmin event with old and new admin addresses\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        // Check caller = admin\n        ensureAdmin(msg.sender);\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewAdmin event on successful acceptance\n    // @custom:event Emits NewPendingAdmin event with null new pending admin\n    function _acceptAdmin() external override returns (uint) {\n        // Check caller is pendingAdmin\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = payable(address(0));\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using `_setReserveFactorFresh`\n     * @dev Governor function to accrue interest and set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewReserveFactor event\n    function _setReserveFactor(uint newReserveFactorMantissa_) external override nonReentrant returns (uint) {\n        ensureAllowed(\"_setReserveFactor(uint256)\");\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa_);\n    }\n\n    /**\n     * @notice Sets the address of the access control manager of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlManagerAddress New address for the access control\n     * @return uint 0=success, otherwise will revert\n     */\n    function setAccessControlManager(address newAccessControlManagerAddress) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n\n        ensureNonZeroAddress(newAccessControlManagerAddress);\n\n        emit NewAccessControlManager(accessControlManager, newAccessControlManagerAddress);\n        accessControlManager = newAccessControlManagerAddress;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to protocol share reserve\n     * @param reduceAmount_ Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits ReservesReduced event\n    function _reduceReserves(uint reduceAmount_) external virtual override nonReentrant returns (uint) {\n        ensureAllowed(\"_reduceReserves(uint256)\");\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n\n        // If reserves were reduced in accrueInterest\n        if (reduceReservesBlockNumber == block.number) return (uint(Error.NO_ERROR));\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount_);\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (type(uint256).max means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint, uint, uint, uint) {\n        uint vTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), vTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this vToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Governance function to set new threshold of block difference after which funds will be sent to the protocol share reserve\n     * @param newReduceReservesBlockDelta_ block difference value\n     */\n    function setReduceReservesBlockDelta(uint256 newReduceReservesBlockDelta_) external {\n        require(newReduceReservesBlockDelta_ > 0, \"Invalid Input\");\n        ensureAllowed(\"setReduceReservesBlockDelta(uint256)\");\n        emit NewReduceReservesBlockDelta(reduceReservesBlockDelta, newReduceReservesBlockDelta_);\n        reduceReservesBlockDelta = newReduceReservesBlockDelta_;\n    }\n\n    /**\n     * @notice Sets protocol share reserve contract address\n     * @param protcolShareReserve_ The address of protocol share reserve contract\n     */\n    function setProtocolShareReserve(address payable protcolShareReserve_) external {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n        ensureNonZeroAddress(protcolShareReserve_);\n        emit NewProtocolShareReserve(protocolShareReserve, protcolShareReserve_);\n        protocolShareReserve = protcolShareReserve_;\n    }\n\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        ensureAdmin(msg.sender);\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = block.number;\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     * up to the current block and writes new checkpoint to storage and\n     * reduce spread reserves to protocol share reserve\n     * if currentBlock - reduceReservesBlockNumber >= blockDelta\n     */\n    // @custom:event Emits AccrueInterest event\n    function accrueInterest() public virtual override returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = block.number;\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        ensureNoMathError(mathErr);\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            reservesPrior\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        (mathErr, blockDelta) = subUInt(currentBlockNumber, reduceReservesBlockNumber);\n        ensureNoMathError(mathErr);\n        if (blockDelta >= reduceReservesBlockDelta) {\n            reduceReservesBlockNumber = currentBlockNumber;\n            if (cashPrior < totalReservesNew) {\n                _reduceReservesFresh(cashPrior);\n            } else {\n                _reduceReservesFresh(totalReservesNew);\n            }\n        }\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Admin function to set a new comptroller\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewComptroller event\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint) {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Governance function to accrue interest and update the interest rate model\n     * @param newInterestRateModel_ The new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel_) public override returns (uint) {\n        ensureAllowed(\"_setInterestRateModel(address)\");\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel_);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        ensureNoMathError(err);\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        ensureNoMathError(err);\n        return result;\n    }\n\n    /**\n     * @notice Transfers `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srvTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srvTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srvTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint256).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted mint failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives vTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        ensureNoMathError(vars.mathErr);\n\n        /*\n         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens, vars.accountTokensNew);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param receiver The address of the account which is receiving the vTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfInternal(address receiver, uint mintAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted mintBehalf failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintBelahfFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintBehalfFresh(msg.sender, receiver, mintAmount);\n    }\n\n    /**\n     * @notice Payer supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param payer The address of the account which is paying the underlying token\n     * @param receiver The address of the account which is receiving vToken\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfFresh(address payer, address receiver, uint mintAmount) internal returns (uint, uint) {\n        ensureNonZeroAddress(receiver);\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), receiver, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the payer and the mintAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(payer, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        ensureNoMathError(vars.mathErr);\n\n        /*\n         * We calculate the new total supply of vTokens and receiver token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[receiver] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[receiver], vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[receiver] = vars.accountTokensNew;\n\n        /* We emit a MintBehalf event, and a Transfer event */\n        emit MintBehalf(payer, receiver, vars.actualMintAmount, vars.mintTokens, vars.accountTokensNew);\n        emit Transfer(address(this), receiver, vars.mintTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.mintVerify(address(this), receiver, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Redeemer redeems vTokens in exchange for the underlying assets, transferred to the receiver. Redeemer and receiver can be the same\n     *   address, or different addresses if the receiver was previously approved by the redeemer as a valid delegate (see MarketFacet.updateDelegate)\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemInternal(\n        address redeemer,\n        address payable receiver,\n        uint redeemTokens\n    ) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(redeemer, receiver, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems underlying assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens, if called by a delegate\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemUnderlyingInternal(\n        address redeemer,\n        address payable receiver,\n        uint redeemAmount\n    ) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(redeemer, receiver, 0, redeemAmount);\n    }\n\n    /**\n     * @notice Redeemer redeems vTokens in exchange for the underlying assets, transferred to the receiver. Redeemer and receiver can be the same\n     *   address, or different addresses if the receiver was previously approved by the redeemer as a valid delegate (see MarketFacet.updateDelegate)\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens\n     * @param redeemTokensIn The number of vTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming vTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // solhint-disable-next-line code-complexity\n    function redeemFresh(\n        address redeemer,\n        address payable receiver,\n        uint redeemTokensIn,\n        uint redeemAmountIn\n    ) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        ensureNoMathError(vars.mathErr);\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n                Exp({ mantissa: vars.exchangeRateMantissa }),\n                redeemTokensIn\n            );\n            ensureNoMathError(vars.mathErr);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n                redeemAmountIn,\n                Exp({ mantissa: vars.exchangeRateMantissa })\n            );\n            ensureNoMathError(vars.mathErr);\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            revert(\"math error\");\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            revert(\"math error\");\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            revert(\"math error\");\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /*\n         * We invoke doTransferOut for the receiver and the redeemAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n\n        uint feeAmount;\n        uint remainedAmount;\n        if (IComptroller(address(comptroller)).treasuryPercent() != 0) {\n            (vars.mathErr, feeAmount) = mulUInt(\n                vars.redeemAmount,\n                IComptroller(address(comptroller)).treasuryPercent()\n            );\n            ensureNoMathError(vars.mathErr);\n\n            (vars.mathErr, feeAmount) = divUInt(feeAmount, 1e18);\n            ensureNoMathError(vars.mathErr);\n\n            (vars.mathErr, remainedAmount) = subUInt(vars.redeemAmount, feeAmount);\n            ensureNoMathError(vars.mathErr);\n\n            address payable treasuryAddress = payable(IComptroller(address(comptroller)).treasuryAddress());\n            doTransferOut(treasuryAddress, feeAmount);\n\n            emit RedeemFee(redeemer, feeAmount, vars.redeemTokens);\n        } else {\n            remainedAmount = vars.redeemAmount;\n        }\n\n        doTransferOut(receiver, remainedAmount);\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, remainedAmount, vars.redeemTokens, vars.accountTokensNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Receiver gets the borrow on behalf of the borrower address\n     * @param borrower The borrower, on behalf of whom to borrow\n     * @param receiver The account that would receive the funds (can be the same as the borrower)\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function borrowInternal(\n        address borrower,\n        address payable receiver,\n        uint borrowAmount\n    ) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(borrower, receiver, borrowAmount);\n    }\n\n    /**\n     * @notice Receiver gets the borrow on behalf of the borrower address\n     * @dev Before calling this function, ensure that the interest has been accrued\n     * @param borrower The borrower, on behalf of whom to borrow\n     * @param receiver The account that would receive the funds (can be the same as the borrower)\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise revert (see ErrorReporter.sol for details).\n     */\n    function borrowFresh(address borrower, address payable receiver, uint borrowAmount) internal returns (uint) {\n        /* Revert if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, receiver, borrowAmount);\n        if (allowed != 0) {\n            revert(\"math error\");\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            revert(\"math error\");\n        }\n\n        /* Revert if protocol has insufficient underlying cash */\n        if (getCashPrior() < borrowAmount) {\n            revert(\"math error\");\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        ensureNoMathError(vars.mathErr);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /*\n         * We invoke doTransferOut for the receiver and the borrowAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(receiver, borrowAmount);\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrowing account\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer The account paying off the borrow\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return (\n                failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        /* If repayAmount == type(uint256).max, repayAmount = accountBorrows */\n        if (repayAmount == type(uint256).max) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n\n        error = vTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, vTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    // solhint-disable-next-line code-complexity\n    function liquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) internal returns (uint, uint) {\n        /* Fail if liquidate not allowed */\n        uint allowed = comptroller.liquidateBorrowAllowed(\n            address(this),\n            address(vTokenCollateral),\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n\n        /* Verify vTokenCollateral market's block number equals current block number */\n        if (vTokenCollateral.accrualBlockNumber() != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n\n        /* Fail if repayAmount = type(uint256).max */\n        if (repayAmount == type(uint256).max) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n\n        /* Fail if repayBorrow fails */\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n            address(this),\n            address(vTokenCollateral),\n            actualRepayAmount\n        );\n        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        uint seizeError;\n        if (address(vTokenCollateral) == address(this)) {\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            seizeError = vTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.liquidateBorrowVerify(\n            address(this),\n            address(vTokenCollateral),\n            liquidator,\n            borrower,\n            actualRepayAmount,\n            seizeTokens\n        );\n\n        return (uint(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev May be called in the following cases:\n     *    - During an in-kind liquidation,\n     *    - By `liquidateBorrow` during the liquidation of another vToken,\n     *    - During a position swap, or\n     *    - By a whitelisted executor through a call to `seize()`.\n     *  Its absolutely critical to use msg.sender as the seizer vToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed vToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function seizeInternal(\n        address seizerToken,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) internal returns (uint) {\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n     * @dev Governance function to set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and adds reserves by transferring from `msg.sender`\n     * @param addAmount Amount of addition to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n        (error, ) = _addReservesFresh(addAmount);\n        return error;\n    }\n\n    /**\n     * @notice Add reserves by transferring from caller\n     * @dev Requires fresh interest accrual\n     * @param addAmount Amount of addition to reserves\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n     */\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n        // totalReserves + actualAddAmount\n        uint totalReservesNew;\n        uint actualAddAmount;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n        /* Return (NO_ERROR, actualAddAmount) */\n        return (uint(Error.NO_ERROR), actualAddAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to protocol share reserve contract\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _reduceReservesFresh(uint reduceAmount) internal virtual returns (uint) {\n        if (reduceAmount == 0) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // totalReserves - reduceAmount\n        uint totalReservesNew = totalReserves - reduceAmount;\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(protocolShareReserve, reduceAmount);\n\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\n            address(comptroller),\n            underlying,\n            IProtocolShareReserve.IncomeType.SPREAD\n        );\n\n        emit ReservesReduced(protocolShareReserve, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Governance function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) internal returns (uint) {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModelV8 oldInterestRateModel;\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market's current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint amount) internal virtual returns (uint);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint amount) internal virtual;\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return Tuple of error code and the calculated balance or 0 if error code is non-zero\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the vToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Tuple of error code and calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStoredInternal() internal view virtual returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    function ensureAllowed(string memory functionSig) private view {\n        require(\n            IAccessControlManagerV8(accessControlManager).isAllowedToCall(msg.sender, functionSig),\n            \"access denied\"\n        );\n    }\n\n    function ensureAdmin(address caller_) private view {\n        require(caller_ == admin, \"Unauthorized\");\n    }\n\n    function ensureNoMathError(MathError mErr) private pure {\n        require(mErr == MathError.NO_ERROR, \"math error\");\n    }\n\n    function ensureNonZeroAddress(address address_) private pure {\n        require(address_ != address(0), \"zero address\");\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal view virtual returns (uint);\n}\n"
    },
    "contracts/Tokens/VTokens/VTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\n\ncontract VTokenStorageBase {\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    bool internal _notEntered;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public decimals;\n\n    /**\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     */\n\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n    /**\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     */\n    uint internal constant reserveFactorMaxMantissa = 1e18;\n\n    /**\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address payable public pendingAdmin;\n\n    /**\n     * @notice Contract which oversees inter-vToken operations\n     */\n    ComptrollerInterface public comptroller;\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModelV8 public interestRateModel;\n\n    /**\n     * @notice Initial exchange rate used when minting the first VTokens (used when totalSupply = 0)\n     */\n    uint internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint public reserveFactorMantissa;\n\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint public borrowIndex;\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint public totalBorrows;\n\n    /**\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint public totalSupply;\n\n    /**\n     * @notice Official record of token balances for each account\n     */\n    mapping(address => uint) internal accountTokens;\n\n    /**\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping(address => mapping(address => uint)) internal transferAllowances;\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     * @notice Underlying asset for this VToken\n     */\n    address public underlying;\n\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n\n    /**\n     * @notice delta block after which reserves will be reduced\n     */\n    uint public reduceReservesBlockDelta;\n\n    /**\n     * @notice last block number at which reserves were reduced\n     */\n    uint public reduceReservesBlockNumber;\n\n    /**\n     * @notice address of protocol share reserve contract\n     */\n    address payable public protocolShareReserve;\n\n    /**\n     * @notice address of accessControlManager\n     */\n\n    address public accessControlManager;\n}\n\ncontract VTokenStorage is VTokenStorageBase {\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n\nabstract contract VTokenInterface is VTokenStorage {\n    /**\n     * @notice Indicator that this is a vToken contract (for inspection)\n     */\n    bool public constant isVToken = true;\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint mintAmount, uint mintTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are minted behalf by payer to receiver\n     */\n    event MintBehalf(address payer, address receiver, uint mintAmount, uint mintTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are redeemed and fee is transferred\n     */\n    event RedeemFee(address redeemer, uint feeAmount, uint redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        address vTokenCollateral,\n        uint seizeTokens\n    );\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Event emitted when pendingAdmin is accepted, which means admin has been updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(\n        InterestRateModelV8 oldInterestRateModel,\n        InterestRateModelV8 newInterestRateModel\n    );\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address protocolShareReserve, uint reduceAmount, uint newTotalReserves);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    /**\n     * @notice Event emitted when block delta for reduce reserves get updated\n     */\n    event NewReduceReservesBlockDelta(uint256 oldReduceReservesBlockDelta, uint256 newReduceReservesBlockDelta);\n\n    /**\n     * @notice Event emitted when address of ProtocolShareReserve contract get updated\n     */\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserve);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControlManager(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint amount) external virtual returns (bool);\n\n    function transferFrom(address src, address dst, uint amount) external virtual returns (bool);\n\n    function approve(address spender, uint amount) external virtual returns (bool);\n\n    function balanceOfUnderlying(address owner) external virtual returns (uint);\n\n    function totalBorrowsCurrent() external virtual returns (uint);\n\n    function borrowBalanceCurrent(address account) external virtual returns (uint);\n\n    function seize(address liquidator, address borrower, uint seizeTokens) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _acceptAdmin() external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setReserveFactor(uint newReserveFactorMantissa) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _reduceReserves(uint reduceAmount) external virtual returns (uint);\n\n    function balanceOf(address owner) external view virtual returns (uint);\n\n    function allowance(address owner, address spender) external view virtual returns (uint);\n\n    function getAccountSnapshot(address account) external view virtual returns (uint, uint, uint, uint);\n\n    function borrowRatePerBlock() external view virtual returns (uint);\n\n    function supplyRatePerBlock() external view virtual returns (uint);\n\n    function getCash() external view virtual returns (uint);\n\n    function exchangeRateCurrent() public virtual returns (uint);\n\n    function accrueInterest() public virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setComptroller(ComptrollerInterface newComptroller) public virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel) public virtual returns (uint);\n\n    function borrowBalanceStored(address account) public view virtual returns (uint);\n\n    function exchangeRateStored() public view virtual returns (uint);\n}\n\ninterface VBep20Interface {\n    /*** User Interface ***/\n\n    function mint(uint mintAmount) external returns (uint);\n\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint);\n\n    function redeem(uint redeemTokens) external returns (uint);\n\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n\n    function borrow(uint borrowAmount) external returns (uint);\n\n    function repayBorrow(uint repayAmount) external returns (uint);\n\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\n\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint);\n\n    /*** Admin Functions ***/\n\n    function _addReserves(uint addAmount) external returns (uint);\n}\n\ninterface VDelegatorInterface {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) external;\n}\n\ninterface VDelegateInterface {\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) external;\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() external;\n}\n"
    },
    "contracts/Tokens/XVS/IXVS.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IXVS {\n    /// @notice BEP-20 token name for this token\n    function name() external pure returns (string memory);\n\n    /// @notice BEP-20 token symbol for this token\n    function symbol() external pure returns (string memory);\n\n    /// @notice BEP-20 token decimals for this token\n    function decimals() external pure returns (uint8);\n\n    /// @notice Total number of tokens in circulation\n    function totalSupply() external pure returns (uint256);\n\n    /// @notice A record of each accounts delegate\n    function delegates(address) external view returns (address);\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    function checkpoints(address, uint32) external view returns (Checkpoint memory);\n\n    /// @notice The number of checkpoints for each account\n    function numCheckpoints(address) external view returns (uint32);\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    function DOMAIN_TYPEHASH() external pure returns (bytes32);\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    function DELEGATION_TYPEHASH() external pure returns (bytes32);\n\n    /// @notice A record of states for signing / validating signatures\n    function nonces(address) external view returns (uint256);\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard BEP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard BEP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint);\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool);\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint);\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external returns (bool);\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96);\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/Utils/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Careful Math\n * @author Venus\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c;\n        unchecked {\n            c = a * b;\n        }\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            unchecked {\n                return (MathError.NO_ERROR, a - b);\n            }\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c;\n        unchecked {\n            c = a + b;\n        }\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
    },
    "contracts/Utils/CheckpointView.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Venus CheckpointView Contract\n * @notice A contract that calls a view function from two different contracts\n *   based on whether a checkpoint in time has passed. Using this contract, we\n *   can change dependencies at a certain timestamp, which is useful for\n *   scheduled changes in, e.g., interest rate models.\n * @author Venus\n */\ncontract CheckpointView {\n    using Address for address;\n\n    address public immutable DATA_SOURCE_1;\n    address public immutable DATA_SOURCE_2;\n    uint256 public immutable CHECKPOINT_TIMESTAMP;\n\n    /**\n     * @notice Constructor\n     * @param dataSource1 Data source to use before the checkpoint\n     * @param dataSource2 Data source to use after the checkpoint\n     * @param checkpointTimestamp Checkpoint timestamp\n     */\n    constructor(address dataSource1, address dataSource2, uint256 checkpointTimestamp) {\n        ensureNonzeroAddress(address(dataSource1));\n        ensureNonzeroAddress(address(dataSource2));\n        DATA_SOURCE_1 = dataSource1;\n        DATA_SOURCE_2 = dataSource2;\n        CHECKPOINT_TIMESTAMP = checkpointTimestamp;\n    }\n\n    /**\n     * @notice Fallback function that proxies the view calls to the current data source\n     * @param input Input data (with a function selector) for the call\n     * @return The data returned by the called function on the current data source\n     */\n    fallback(bytes calldata input) external returns (bytes memory) {\n        return _getCurrentDataSource().functionStaticCall(input);\n    }\n\n    /**\n     * @notice Returns the current data source contract (either the old one or the new one)\n     * @return Data source contract in use\n     */\n    function currentDataSource() external view returns (address) {\n        return _getCurrentDataSource();\n    }\n\n    /**\n     * @dev Returns the current data source contract (either the old one or the new one)\n     * @return Data source contract in use\n     */\n    function _getCurrentDataSource() internal view returns (address) {\n        return (block.timestamp < CHECKPOINT_TIMESTAMP) ? DATA_SOURCE_1 : DATA_SOURCE_2;\n    }\n}\n"
    },
    "contracts/Utils/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\ncontract ComptrollerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY,\n        INSUFFICIENT_BALANCE_FOR_VAI,\n        MARKET_NOT_COLLATERAL\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        SET_VAI_MINT_RATE_CHECK,\n        SET_VAICONTROLLER_OWNER_CHECK,\n        SET_MINTED_VAI_REJECTION,\n        SET_TREASURY_OWNER_CHECK,\n        UNLIST_MARKET_NOT_LISTED\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        COMPTROLLER_REJECTION,\n        COMPTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED,\n        TOKEN_PRICE_ERROR\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_COMPTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_COMPTROLLER_REJECTION,\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_COMPTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_COMPTROLLER_REJECTION,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_COMPTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COMPTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_COMPTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n        TOKEN_GET_UNDERLYING_PRICE_ERROR,\n        REPAY_VAI_COMPTROLLER_REJECTION,\n        REPAY_VAI_FRESHNESS_CHECK,\n        VAI_MINT_EXCHANGE_CALCULATION_FAILED,\n        SFT_MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract VAIControllerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED, // The sender is not authorized to perform this action.\n        REJECTION, // The action would violate the comptroller, vaicontroller policy.\n        SNAPSHOT_ERROR, // The comptroller could not get the account borrows and exchange rate from the market.\n        PRICE_ERROR, // The comptroller could not obtain a required price of an asset.\n        MATH_ERROR, // A math calculation error occurred.\n        INSUFFICIENT_BALANCE_FOR_VAI // Caller does not have sufficient balance to mint VAI.\n    }\n\n    enum FailureInfo {\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_COMPTROLLER_OWNER_CHECK,\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        VAI_MINT_REJECTION,\n        VAI_BURN_REJECTION,\n        VAI_LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        VAI_LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        VAI_LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        VAI_LIQUIDATE_COMPTROLLER_REJECTION,\n        VAI_LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        VAI_LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        VAI_LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        VAI_LIQUIDATE_FRESHNESS_CHECK,\n        VAI_LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        VAI_LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        VAI_LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        VAI_LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        VAI_LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        VAI_LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        VAI_LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_FEE_CALCULATION_FAILED,\n        SET_TREASURY_OWNER_CHECK\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n"
    },
    "contracts/Utils/Exponential.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { CarefulMath } from \"./CarefulMath.sol\";\nimport { ExponentialNoError } from \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Venus\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: rational }));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({ mantissa: result }));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({ mantissa: result }));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({ mantissa: 0 }));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({ mantissa: product }));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n        return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"
    },
    "contracts/Utils/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint internal constant expScale = 1e18;\n    uint internal constant doubleScale = 1e36;\n    uint internal constant halfExpScale = expScale / 2;\n    uint internal constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) internal pure returns (uint224) {\n        require(n < 2 ** 224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\n    }\n\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: add_(a.mantissa, b.mantissa) });\n    }\n\n    function add_(uint a, uint b) internal pure returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\n    }\n\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\n    }\n\n    function sub_(uint a, uint b) internal pure returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\n    }\n\n    function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: mul_(a.mantissa, b) });\n    }\n\n    function mul_(uint a, Exp memory b) internal pure returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\n    }\n\n    function mul_(Double memory a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: mul_(a.mantissa, b) });\n    }\n\n    function mul_(uint a, Double memory b) internal pure returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) internal pure returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\n    }\n\n    function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: div_(a.mantissa, b) });\n    }\n\n    function div_(uint a, Exp memory b) internal pure returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\n    }\n\n    function div_(Double memory a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(a.mantissa, b) });\n    }\n\n    function div_(uint a, Double memory b) internal pure returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) internal pure returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(mul_(a, doubleScale), b) });\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view virtual returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(Address.isContract(IBeacon(newBeacon).implementation()), \"ERC1967: beacon implementation is not a contract\");\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n\n    constructor (address initialOwner) Ownable(initialOwner) {}\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/OptimizedTransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../openzeppelin/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract OptimizedTransparentUpgradeableProxy is ERC1967Proxy {\n    address internal immutable _ADMIN;\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _ADMIN = admin_;\n\n        // still store it to work with EIP-1967\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, admin_)\n        }\n        emit AdminChanged(address(0), admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n\n    function _getAdmin() internal view virtual override returns (address) {\n        return _ADMIN;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
