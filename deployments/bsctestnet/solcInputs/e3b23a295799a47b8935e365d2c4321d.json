{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IAccessControlManagerV8\n * @author Venus\n * @notice Interface implemented by the `AccessControlManagerV8` contract.\n */\ninterface IAccessControlManagerV8 is IAccessControl {\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\n\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) external;\n\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\n\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) external view returns (bool);\n}\n"
    },
    "@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\ninterface OracleInterface {\n    function getPrice(address asset) external view returns (uint256);\n}\n\ninterface ResilientOracleInterface is OracleInterface {\n    function updatePrice(address vToken) external;\n\n    function updateAssetPrice(address asset) external;\n\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\n}\n\ninterface TwapInterface is OracleInterface {\n    function updateTwap(address asset) external returns (uint256);\n}\n\ninterface BoundValidatorInterface {\n    function validatePriceWithAnchorPrice(\n        address asset,\n        uint256 reporterPrice,\n        uint256 anchorPrice\n    ) external view returns (bool);\n}\n"
    },
    "contracts/Comptroller/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { VAIControllerInterface } from \"../Tokens/VAI/VAIControllerInterface.sol\";\nimport { WeightFunction } from \"./Diamond/interfaces/IFacetBase.sol\";\n\nenum Action {\n    MINT,\n    REDEEM,\n    BORROW,\n    REPAY,\n    SEIZE,\n    LIQUIDATE,\n    TRANSFER,\n    ENTER_MARKET,\n    EXIT_MARKET\n}\n\ninterface ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() external pure returns (bool);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory);\n\n    function exitMarket(address vToken) external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address vToken, address minter, uint mintAmount) external returns (uint);\n\n    function mintVerify(address vToken, address minter, uint mintAmount, uint mintTokens) external;\n\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external returns (uint);\n\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external returns (uint);\n\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external;\n\n    function executeFlashLoan(\n        address payable onBehalf,\n        address payable receiver,\n        VToken[] calldata vTokens,\n        uint256[] calldata amounts,\n        bytes calldata param\n    ) external;\n\n    function repayBorrowAllowed(\n        address vToken,\n        address payer,\n        address borrower,\n        uint repayAmount\n    ) external returns (uint);\n\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint repayAmount,\n        uint borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount\n    ) external returns (uint);\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        uint seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external returns (uint);\n\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external;\n\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external returns (uint);\n\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function setMintedVAIOf(address owner, uint amount) external returns (uint);\n\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function getXVSAddress() external view returns (address);\n\n    function markets(address) external view returns (bool, uint, bool, uint, uint, uint96, bool);\n\n    function oracle() external view returns (ResilientOracleInterface);\n\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\n\n    function getAssetsIn(address) external view returns (VToken[] memory);\n\n    function claimVenus(address) external;\n\n    function venusAccrued(address) external view returns (uint);\n\n    function venusSupplySpeeds(address) external view returns (uint);\n\n    function venusBorrowSpeeds(address) external view returns (uint);\n\n    function getAllMarkets() external view returns (VToken[] memory);\n\n    function venusSupplierIndex(address, address) external view returns (uint);\n\n    function venusInitialIndex() external view returns (uint224);\n\n    function venusBorrowerIndex(address, address) external view returns (uint);\n\n    function venusBorrowState(address) external view returns (uint224, uint32);\n\n    function venusSupplyState(address) external view returns (uint224, uint32);\n\n    function approvedDelegates(address borrower, address delegate) external view returns (bool);\n\n    function vaiController() external view returns (VAIControllerInterface);\n\n    function protocolPaused() external view returns (bool);\n\n    function actionPaused(address market, Action action) external view returns (bool);\n\n    function mintedVAIs(address user) external view returns (uint);\n\n    function vaiMintRate() external view returns (uint);\n\n    function authorizedFlashLoan(address account) external view returns (bool);\n\n    function userPoolId(address account) external view returns (uint96);\n\n    function getLiquidationIncentive(address vToken) external view returns (uint256);\n\n    function getEffectiveLiquidationIncentive(address account, address vToken) external view returns (uint256);\n\n    function getEffectiveLtvFactor(\n        address account,\n        address vToken,\n        WeightFunction weightingStrategy\n    ) external view returns (uint256);\n\n    function lastPoolId() external view returns (uint96);\n\n    function corePoolId() external pure returns (uint96);\n\n    function pools(\n        uint96 poolId\n    ) external view returns (string memory label, bool isActive, bool allowCorePoolFallback);\n\n    function getPoolVTokens(uint96 poolId) external view returns (address[] memory);\n\n    function poolMarkets(\n        uint96 poolId,\n        address vToken\n    )\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 liquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        );\n}\n\ninterface IVAIVault {\n    function updatePendingRewards() external;\n}\n\ninterface IComptroller {\n    /*** Treasury Data ***/\n    function treasuryAddress() external view returns (address);\n\n    function treasuryPercent() external view returns (uint);\n}\n"
    },
    "contracts/Comptroller/ComptrollerLensInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { WeightFunction } from \"./Diamond/interfaces/IFacetBase.sol\";\n\ninterface ComptrollerLensInterface {\n    function liquidateCalculateSeizeTokens(\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function liquidateVAICalculateSeizeTokens(\n        address comptroller,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function getHypotheticalAccountLiquidity(\n        address comptroller,\n        address account,\n        VToken vTokenModify,\n        uint redeemTokens,\n        uint borrowAmount,\n        WeightFunction weightingStrategy\n    ) external view returns (uint, uint, uint);\n}\n"
    },
    "contracts/Comptroller/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { PoolMarketId } from \"./Types/PoolMarketId.sol\";\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { VAIControllerInterface } from \"../Tokens/VAI/VAIControllerInterface.sol\";\nimport { ComptrollerLensInterface } from \"./ComptrollerLensInterface.sol\";\nimport { IPrime } from \"../Tokens/Prime/IPrime.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public comptrollerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    ResilientOracleInterface public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives (deprecated)\n     */\n    uint256 private _oldLiquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint256 public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => VToken[]) public accountAssets;\n\n    struct Market {\n        /// @notice Whether or not this market is listed\n        bool isListed;\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /// @notice Per-market mapping of \"accounts in this asset\" (used for Core Pool only)\n        mapping(address => bool) accountMembership;\n        /// @notice Whether or not this market receives XVS\n        bool isVenus;\n        /**\n         * @notice Multiplier representing the collateralization after which the borrow is eligible\n         * for liquidation. For instance, 0.8 liquidate when the borrow is 80% of collateral\n         * value. Must be between 0 and collateral factor, stored as a mantissa.\n         */\n        uint256 liquidationThresholdMantissa;\n        /// @notice discount on collateral that a liquidator receives when liquidating a borrow in this market\n        uint256 liquidationIncentiveMantissa;\n        /// @notice The pool ID this market is associated with, Used to support pools/emodes\n        uint96 poolId;\n        /// @notice Flag  to restrict borrowing in certain pools/emodes.\n        bool isBorrowAllowed;\n    }\n\n    /**\n     * @notice Mapping of PoolMarketId -> Market metadata\n     * Underlying key layout: First 12 bytes (96 bits) represent the poolId, last 20 bytes the vToken address\n     */\n    mapping(PoolMarketId => Market) internal _poolMarkets;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    address public pauseGuardian;\n\n    /// @notice Whether minting is paused (deprecated, superseded by actionPaused)\n    bool private _mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool private _borrowGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal transferGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal seizeGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal borrowGuardianPaused;\n\n    struct VenusMarketState {\n        /// @notice The market's last updated venusBorrowIndex or venusSupplyIndex\n        uint224 index;\n        /// @notice The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice A list of all markets\n    VToken[] public allMarkets;\n\n    /// @notice The rate at which the flywheel distributes XVS, per block\n    uint256 internal venusRate;\n\n    /// @notice The portion of venusRate that each market currently receives\n    mapping(address => uint256) internal venusSpeeds;\n\n    /// @notice The Venus market supply state for each market\n    mapping(address => VenusMarketState) public venusSupplyState;\n\n    /// @notice The Venus market borrow state for each market\n    mapping(address => VenusMarketState) public venusBorrowState;\n\n    /// @notice The Venus supply index for each market for each supplier as of the last time they accrued XVS\n    mapping(address => mapping(address => uint256)) public venusSupplierIndex;\n\n    /// @notice The Venus borrow index for each market for each borrower as of the last time they accrued XVS\n    mapping(address => mapping(address => uint256)) public venusBorrowerIndex;\n\n    /// @notice The XVS accrued but not yet transferred to each user\n    mapping(address => uint256) public venusAccrued;\n\n    /// @notice The Address of VAIController\n    VAIControllerInterface public vaiController;\n\n    /// @notice The minted VAI amount to each user\n    mapping(address => uint256) public mintedVAIs;\n\n    /// @notice VAI Mint Rate as a percentage\n    uint256 public vaiMintRate;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    bool public mintVAIGuardianPaused;\n    bool public repayVAIGuardianPaused;\n\n    /**\n     * @notice Pause/Unpause whole protocol actions\n     */\n    bool public protocolPaused;\n\n    /// @notice The rate at which the flywheel distributes XVS to VAI Minters, per block (deprecated)\n    uint256 private venusVAIRate;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    /// @notice The rate at which the flywheel distributes XVS to VAI Vault, per block\n    uint256 public venusVAIVaultRate;\n\n    // address of VAI Vault\n    address public vaiVaultAddress;\n\n    // start block of release to VAI Vault\n    uint256 public releaseStartBlock;\n\n    // minimum release amount to VAI Vault\n    uint256 public minReleaseAmount;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address.\n    mapping(address => uint256) public borrowCaps;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n    /// @notice Treasury Guardian address\n    address public treasuryGuardian;\n\n    /// @notice Treasury address\n    address public treasuryAddress;\n\n    /// @notice Fee percent of accrued interest with decimal 18\n    uint256 public treasuryPercent;\n}\n\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\n    /// @notice The portion of XVS that each contributor receives per block (deprecated)\n    mapping(address => uint256) private venusContributorSpeeds;\n\n    /// @notice Last block at which a contributor's XVS rewards have been allocated (deprecated)\n    mapping(address => uint256) private lastContributorBlock;\n}\n\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\n    address public liquidatorContract;\n}\n\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\n    ComptrollerLensInterface public comptrollerLens;\n}\n\ncontract ComptrollerV8Storage is ComptrollerV7Storage {\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\n    mapping(address => uint256) public supplyCaps;\n}\n\ncontract ComptrollerV9Storage is ComptrollerV8Storage {\n    /// @notice AccessControlManager address\n    address internal accessControl;\n\n    /// @notice True if a certain action is paused on a certain market\n    mapping(address => mapping(uint256 => bool)) internal _actionPaused;\n}\n\ncontract ComptrollerV10Storage is ComptrollerV9Storage {\n    /// @notice The rate at which venus is distributed to the corresponding borrow market (per block)\n    mapping(address => uint256) public venusBorrowSpeeds;\n\n    /// @notice The rate at which venus is distributed to the corresponding supply market (per block)\n    mapping(address => uint256) public venusSupplySpeeds;\n}\n\ncontract ComptrollerV11Storage is ComptrollerV10Storage {\n    /// @notice Whether the delegate is allowed to borrow or redeem on behalf of the user\n    //mapping(address user => mapping (address delegate => bool approved)) public approvedDelegates;\n    mapping(address => mapping(address => bool)) public approvedDelegates;\n}\n\ncontract ComptrollerV12Storage is ComptrollerV11Storage {\n    /// @notice Whether forced liquidation is enabled for all users borrowing in a certain market\n    mapping(address => bool) public isForcedLiquidationEnabled;\n}\n\ncontract ComptrollerV13Storage is ComptrollerV12Storage {\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in _facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in _facetAddresses array\n    }\n\n    mapping(bytes4 => FacetAddressAndPosition) internal _selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) internal _facetFunctionSelectors;\n    // facet addresses\n    address[] internal _facetAddresses;\n}\n\ncontract ComptrollerV14Storage is ComptrollerV13Storage {\n    /// @notice Prime token address\n    IPrime public prime;\n}\n\ncontract ComptrollerV15Storage is ComptrollerV14Storage {\n    /// @notice Whether forced liquidation is enabled for the borrows of a user in a market\n    mapping(address user => mapping(address market => bool)) public isForcedLiquidationEnabledForUser;\n}\n\ncontract ComptrollerV16Storage is ComptrollerV15Storage {\n    /// @notice The XVS token contract address\n    address internal xvs;\n\n    /// @notice The XVS vToken contract address\n    address internal xvsVToken;\n}\n\ncontract ComptrollerV17Storage is ComptrollerV16Storage {\n    struct PoolData {\n        /// @notice label for the pool\n        string label;\n        /// @notice List of vToken addresses associated with this pool\n        address[] vTokens;\n        /**\n         * @notice Whether the pool is active and can be entered. If set to false,\n         * new entries are disabled and existing accounts fall back to core pool values\n         */\n        bool isActive;\n        /**\n         * @notice Whether core pool risk factors can be used as fallback when the market\n         * is not configured in the specific pool, falls back when set to true\n         */\n        bool allowCorePoolFallback;\n    }\n\n    /**\n     * @notice Tracks the selected pool for each user\n     * @dev\n     * - The mapping stores the pool ID (`uint96`) that each user (`address`) is currently in\n     * - A value of `0` represents the default core pool (legacy behavior)\n     */\n    mapping(address => uint96) public userPoolId;\n\n    /**\n     * @notice Mapping of pool ID to its corresponding metadata and configuration\n     * @dev Pool IDs are unique and incremented via `lastPoolId` when a new pool is created\n     *      Not updated for the Core Pool (`poolId = 0`)\n     */\n    mapping(uint96 => PoolData) public pools;\n\n    /**\n     * @notice Counter used to generate unique pool IDs\n     * @dev Increments each time a pool is created; `poolId = 0` is reserved for the core pool\n     */\n    uint96 public lastPoolId;\n}\n\ncontract ComptrollerV18Storage is ComptrollerV17Storage {\n    struct FlashLoanData {\n        uint256[] totalFees;\n        uint256[] protocolFees;\n        uint256[] actualRepayments;\n        uint256[] remainingDebts;\n    }\n\n    /// @notice Mapping of accounts authorized to execute flash loans\n    mapping(address => bool) public authorizedFlashLoan;\n}\n"
    },
    "contracts/Comptroller/Diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport { Unitroller } from \"../Unitroller.sol\";\nimport { ComptrollerV18Storage } from \"../ComptrollerStorage.sol\";\n\n/**\n * @title Diamond\n * @author Venus\n * @notice This contract contains functions related to facets\n */\ncontract Diamond is IDiamondCut, ComptrollerV18Storage {\n    /// @notice Emitted when functions are added, replaced or removed to facets\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut);\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /**\n     * @notice Call _acceptImplementation to accept the diamond proxy as new implementaion\n     * @param unitroller Address of the unitroller\n     */\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    /**\n     * @notice To add function selectors to the facet's mapping\n     * @dev Allows the contract admin to add function selectors\n     * @param diamondCut_ IDiamondCut contains facets address, action and function selectors\n     */\n    function diamondCut(IDiamondCut.FacetCut[] memory diamondCut_) public {\n        require(msg.sender == admin, \"only unitroller admin can\");\n        libDiamondCut(diamondCut_);\n    }\n\n    /**\n     * @notice Get all function selectors mapped to the facet address\n     * @param facet Address of the facet\n     * @return selectors Array of function selectors\n     */\n    function facetFunctionSelectors(address facet) external view returns (bytes4[] memory) {\n        return _facetFunctionSelectors[facet].functionSelectors;\n    }\n\n    /**\n     * @notice Get facet position in the _facetFunctionSelectors through facet address\n     * @param facet Address of the facet\n     * @return Position of the facet\n     */\n    function facetPosition(address facet) external view returns (uint256) {\n        return _facetFunctionSelectors[facet].facetAddressPosition;\n    }\n\n    /**\n     * @notice Get all facet addresses\n     * @return facetAddresses Array of facet addresses\n     */\n    function facetAddresses() external view returns (address[] memory) {\n        return _facetAddresses;\n    }\n\n    /**\n     * @notice Get facet address and position through function selector\n     * @param functionSelector function selector\n     * @return FacetAddressAndPosition facet address and position\n     */\n    function facetAddress(\n        bytes4 functionSelector\n    ) external view returns (ComptrollerV18Storage.FacetAddressAndPosition memory) {\n        return _selectorToFacetAndPosition[functionSelector];\n    }\n\n    /**\n     * @notice Get all facets address and their function selector\n     * @return facets_ Array of Facet\n     */\n    function facets() external view returns (Facet[] memory) {\n        uint256 facetsLength = _facetAddresses.length;\n        Facet[] memory facets_ = new Facet[](facetsLength);\n        for (uint256 i; i < facetsLength; ++i) {\n            address facet = _facetAddresses[i];\n            facets_[i].facetAddress = facet;\n            facets_[i].functionSelectors = _facetFunctionSelectors[facet].functionSelectors;\n        }\n        return facets_;\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping\n     * @param diamondCut_ IDiamondCut contains facets address, action and function selectors\n     */\n    function libDiamondCut(IDiamondCut.FacetCut[] memory diamondCut_) internal {\n        uint256 diamondCutLength = diamondCut_.length;\n        for (uint256 facetIndex; facetIndex < diamondCutLength; ++facetIndex) {\n            IDiamondCut.FacetCutAction action = diamondCut_[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(diamondCut_);\n    }\n\n    /**\n     * @notice Add function selectors to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to add in the mapping\n     */\n    function addFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        require(functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(_facetFunctionSelectors[facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(facetAddress);\n        }\n        uint256 functionSelectorsLength = functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(selector, selectorPosition, facetAddress);\n            ++selectorPosition;\n        }\n    }\n\n    /**\n     * @notice Replace facet's address mapping for function selectors i.e selectors already associate to any other existing facet\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to replace in the mapping\n     */\n    function replaceFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        require(functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(_facetFunctionSelectors[facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(facetAddress);\n        }\n        uint256 functionSelectorsLength = functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            addFunction(selector, selectorPosition, facetAddress);\n            ++selectorPosition;\n        }\n    }\n\n    /**\n     * @notice Remove function selectors to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to remove in the mapping\n     */\n    function removeFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        uint256 functionSelectorsLength = functionSelectors.length;\n        require(functionSelectorsLength != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and revert\n        require(facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    /**\n     * @notice Add new facet to the proxy\n     * @param facetAddress Address of the facet\n     */\n    function addFacet(address facetAddress) internal {\n        enforceHasContractCode(facetAddress, \"Diamond: New facet has no code\");\n        _facetFunctionSelectors[facetAddress].facetAddressPosition = _facetAddresses.length;\n        _facetAddresses.push(facetAddress);\n    }\n\n    /**\n     * @notice Add function selector to the facet's address mapping\n     * @param selector funciton selector need to be added\n     * @param selectorPosition funciton selector position\n     * @param facetAddress Address of the facet\n     */\n    function addFunction(bytes4 selector, uint96 selectorPosition, address facetAddress) internal {\n        _selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n        _facetFunctionSelectors[facetAddress].functionSelectors.push(selector);\n        _selectorToFacetAndPosition[selector].facetAddress = facetAddress;\n    }\n\n    /**\n     * @notice Remove function selector to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param selector function selectors need to remove in the mapping\n     */\n    function removeFunction(address facetAddress, bytes4 selector) internal {\n        require(facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = _selectorToFacetAndPosition[selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = _facetFunctionSelectors[facetAddress].functionSelectors.length - 1;\n        // if not the same then replace selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = _facetFunctionSelectors[facetAddress].functionSelectors[lastSelectorPosition];\n            _facetFunctionSelectors[facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            _selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        _facetFunctionSelectors[facetAddress].functionSelectors.pop();\n        delete _selectorToFacetAndPosition[selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = _facetAddresses.length - 1;\n            uint256 facetAddressPosition = _facetFunctionSelectors[facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = _facetAddresses[lastFacetAddressPosition];\n                _facetAddresses[facetAddressPosition] = lastFacetAddress;\n                _facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            _facetAddresses.pop();\n            delete _facetFunctionSelectors[facetAddress];\n        }\n    }\n\n    /**\n     * @dev Ensure that the given address has contract code deployed\n     * @param _contract The address to check for contract code\n     * @param _errorMessage The error message to display if the contract code is not deployed\n     */\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize != 0, _errorMessage);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external {\n        address facet = _selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute public function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/DiamondConsolidated.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { MarketFacet } from \"./facets/MarketFacet.sol\";\nimport { PolicyFacet } from \"./facets/PolicyFacet.sol\";\nimport { RewardFacet } from \"./facets/RewardFacet.sol\";\nimport { SetterFacet } from \"./facets/SetterFacet.sol\";\nimport { Diamond } from \"./Diamond.sol\";\n\n/**\n * @title DiamondConsolidated\n * @author Venus\n * @notice This contract contains the functions defined in the different facets of the Diamond, plus the getters to the public variables.\n * This contract cannot be deployed, due to its size. Its main purpose is to allow the easy generation of an ABI and the typechain to interact with the\n * Unitroller contract in a simple way\n */\ncontract DiamondConsolidated is Diamond, MarketFacet, PolicyFacet, RewardFacet, SetterFacet {}\n"
    },
    "contracts/Comptroller/Diamond/facets/FacetBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { ComptrollerErrorReporter } from \"../../../Utils/ErrorReporter.sol\";\nimport { ExponentialNoError } from \"../../../Utils/ExponentialNoError.sol\";\nimport { IVAIVault, Action } from \"../../../Comptroller/ComptrollerInterface.sol\";\nimport { ComptrollerV18Storage } from \"../../../Comptroller/ComptrollerStorage.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\nimport { IFacetBase, WeightFunction } from \"../interfaces/IFacetBase.sol\";\n\n/**\n * @title FacetBase\n * @author Venus\n * @notice This facet contract contains functions related to access and checks\n */\ncontract FacetBase is IFacetBase, ComptrollerV18Storage, ExponentialNoError, ComptrollerErrorReporter {\n    using SafeERC20 for IERC20;\n\n    /// @notice The initial Venus index for a market\n    uint224 public constant venusInitialIndex = 1e36;\n    // poolId for core Pool\n    uint96 public constant corePoolId = 0;\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(VToken indexed vToken, address indexed account);\n\n    /// @notice Emitted when XVS is distributed to VAI Vault\n    event DistributedVAIVaultVenus(uint256 amount);\n\n    /// @notice Reverts if the protocol is paused\n    function checkProtocolPauseState() internal view {\n        require(!protocolPaused, \"protocol is paused\");\n    }\n\n    /// @notice Reverts if a certain action is paused on a market\n    function checkActionPauseState(address market, Action action) internal view {\n        require(!actionPaused(market, action), \"action is paused\");\n    }\n\n    /// @notice Reverts if the caller is not admin\n    function ensureAdmin() internal view {\n        require(msg.sender == admin, \"only admin can\");\n    }\n\n    /// @notice Checks the passed address is nonzero\n    function ensureNonzeroAddress(address someone) internal pure {\n        require(someone != address(0), \"can't be zero address\");\n    }\n\n    /// @notice Reverts if the market is not listed\n    function ensureListed(Market storage market) internal view {\n        require(market.isListed, \"market not listed\");\n    }\n\n    /// @notice Reverts if the caller is neither admin nor the passed address\n    function ensureAdminOr(address privilegedAddress) internal view {\n        require(msg.sender == admin || msg.sender == privilegedAddress, \"access denied\");\n    }\n\n    /// @notice Checks the caller is allowed to call the specified fuction\n    function ensureAllowed(string memory functionSig) internal view {\n        require(IAccessControlManagerV8(accessControl).isAllowedToCall(msg.sender, functionSig), \"access denied\");\n    }\n\n    /**\n     * @notice Checks if a certain action is paused on a market\n     * @param action Action id\n     * @param market vToken address\n     */\n    function actionPaused(address market, Action action) public view returns (bool) {\n        return _actionPaused[market][uint256(action)];\n    }\n\n    /**\n     * @notice Get the latest block number\n     */\n    function getBlockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Get the latest block number with the safe32 check\n     */\n    function getBlockNumberAsUint32() internal view returns (uint32) {\n        return safe32(getBlockNumber(), \"block # > 32 bits\");\n    }\n\n    /**\n     * @notice Transfer XVS to VAI Vault\n     */\n    function releaseToVault() internal {\n        if (releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\n            return;\n        }\n\n        IERC20 xvs_ = IERC20(xvs);\n\n        uint256 xvsBalance = xvs_.balanceOf(address(this));\n        if (xvsBalance == 0) {\n            return;\n        }\n\n        uint256 actualAmount;\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\n        uint256 releaseAmount_ = mul_(venusVAIVaultRate, deltaBlocks);\n\n        if (xvsBalance >= releaseAmount_) {\n            actualAmount = releaseAmount_;\n        } else {\n            actualAmount = xvsBalance;\n        }\n\n        if (actualAmount < minReleaseAmount) {\n            return;\n        }\n\n        releaseStartBlock = getBlockNumber();\n\n        xvs_.safeTransfer(vaiVaultAddress, actualAmount);\n        emit DistributedVAIVaultVenus(actualAmount);\n\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @param weightingStrategy The weighting strategy to use:\n     *                          - `WeightFunction.USE_COLLATERAL_FACTOR` to use collateral factor\n     *                          - `WeightFunction.USE_LIQUIDATION_THRESHOLD` to use liquidation threshold\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        VToken vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount,\n        WeightFunction weightingStrategy\n    ) internal view returns (Error, uint256, uint256) {\n        (uint256 err, uint256 liquidity, uint256 shortfall) = comptrollerLens.getHypotheticalAccountLiquidity(\n            address(this),\n            account,\n            vTokenModify,\n            redeemTokens,\n            borrowAmount,\n            weightingStrategy\n        );\n        return (Error(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param vToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\n        checkActionPauseState(address(vToken), Action.ENTER_MARKET);\n        Market storage marketToJoin = getCorePoolMarket(address(vToken));\n        ensureListed(marketToJoin);\n        if (marketToJoin.accountMembership[borrower]) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(vToken);\n\n        emit MarketEntered(vToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Checks for the user is allowed to redeem tokens\n     * @param vToken Address of the market\n     * @param redeemer Address of the user\n     * @param redeemTokens Amount of tokens to redeem\n     * @return Success indicator for redeem is allowed or not\n     */\n    function redeemAllowedInternal(\n        address vToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        ensureListed(getCorePoolMarket(vToken));\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!getCorePoolMarket(vToken).accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            VToken(vToken),\n            redeemTokens,\n            0,\n            WeightFunction.USE_COLLATERAL_FACTOR\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall != 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Returns the XVS address\n     * @return The address of XVS token\n     */\n    function getXVSAddress() external view returns (address) {\n        return xvs;\n    }\n\n    /**\n     * @notice Returns the unique market index for the given poolId and vToken pair\n     * @dev Computes a unique key for a (poolId, market) pair used in the `_poolMarkets` mapping\n     * - For the core pool (`poolId == 0`), this results in the address being left-padded to 32 bytes,\n     *   maintaining backward compatibility with legacy mappings\n     * - For other pools, packs the `poolId` and `market` address into a single `bytes32` key,\n     *   The first 96 bits are used for the `poolId`, and the remaining 160 bits for the `market` address\n     * @param poolId The ID of the pool\n     * @param vToken The address of the market (vToken)\n     * @return PoolMarketId The `bytes32` key that uniquely represents the (poolId, vToken) pair\n     */\n    function getPoolMarketIndex(uint96 poolId, address vToken) public pure returns (PoolMarketId) {\n        return PoolMarketId.wrap(bytes32((uint256(poolId) << 160) | uint160(vToken)));\n    }\n\n    /**\n     * @dev Returns the Market struct for the given vToken in the Core Pool (`poolId = 0`)\n     * @param vToken The vToken address for which the market details are requested\n     * @return market The Market struct corresponding to the (corePoolId, vToken) pair\n     */\n    function getCorePoolMarket(address vToken) internal view returns (Market storage) {\n        return _poolMarkets[getPoolMarketIndex(corePoolId, address(vToken))];\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @param account The account to get liquidity for\n     * @param weightingStrategy The weighting strategy to use:\n     *                          - `WeightFunction.USE_COLLATERAL_FACTOR` to use collateral factor\n     *                          - `WeightFunction.USE_LIQUIDATION_THRESHOLD` to use liquidation threshold\n     * @return (possible error code (semi-opaque),\n     * account liquidity in excess of collateral requirements,\n     * account shortfall below collateral requirements)\n     */\n    function _getAccountLiquidity(\n        address account,\n        WeightFunction weightingStrategy\n    ) internal view returns (uint256, uint256, uint256) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(address(0)),\n            0,\n            0,\n            weightingStrategy\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/FlashLoanFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IFlashLoanFacet } from \"../interfaces/IFlashLoanFacet.sol\";\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\nimport { IFlashLoanReceiver } from \"../../../FlashLoan/interfaces/IFlashLoanReceiver.sol\";\nimport { IProtocolShareReserve } from \"../../../external/IProtocolShareReserve.sol\";\n\ncontract FlashLoanFacet is IFlashLoanFacet, FacetBase {\n    /// @notice Emitted when the flash loan is successfully executed\n    event FlashLoanExecuted(address indexed receiver, VToken[] assets, uint256[] amounts);\n\n    /**\n     * @notice Executes a flashLoan operation with the requested assets.\n     * @dev Transfers the specified assets to the receiver contract and handles repayment.\n     * @param onBehalf The address of the user whose debt position will be used for the flashLoan.\n     * @param receiver The address of the contract that will receive the flashLoan amount and execute the operation.\n     * @param vTokens The addresses of the vToken assets to be loaned.\n     * @param underlyingAmounts The amounts of each underlying assets to be loaned.\n     * @param param The bytes passed in the executeOperation call.\n     * @custom:error FlashLoanNotEnabled is thrown if the flash loan is not enabled for the asset.\n     * @custom:error InvalidAmount is thrown if the requested amount is zero.\n     * @custom:error NoAssetsRequested is thrown if no assets are requested for the flash loan.\n     * @custom:error InvalidFlashLoanParams is thrown if the flash loan params are invalid.\n     * @custom:error SenderNotAuthorizedForFlashLoan is thrown if the sender is not authorized to use flashloan.\n     * @custom:event Emits FlashLoanExecuted on success\n     */\n    function executeFlashLoan(\n        address payable onBehalf,\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        bytes memory param\n    ) external {\n        for (uint256 i; i < vTokens.length; ++i) {\n            if (!(vTokens[i]).isFlashLoanEnabled()) revert FlashLoanNotEnabled();\n            if (underlyingAmounts[i] == 0) revert InvalidAmount();\n        }\n        // vTokens array must not be empty\n        if (vTokens.length == 0) {\n            revert NoAssetsRequested();\n        }\n        // All arrays must have the same length and not be zero\n        if (vTokens.length != underlyingAmounts.length) {\n            revert InvalidFlashLoanParams();\n        }\n\n        ensureNonzeroAddress(receiver);\n\n        if (!authorizedFlashLoan[msg.sender]) {\n            revert SenderNotAuthorizedForFlashLoan(msg.sender);\n        }\n\n        if (!approvedDelegates[onBehalf][msg.sender]) {\n            revert NotAnApprovedDelegate();\n        }\n\n        // Execute flash loan phases\n        _executeFlashLoanPhases(onBehalf, receiver, vTokens, underlyingAmounts, param);\n\n        emit FlashLoanExecuted(receiver, vTokens, underlyingAmounts);\n    }\n\n    /**\n     * @notice Executes all flash loan phases\n     */\n    function _executeFlashLoanPhases(\n        address payable onBehalf,\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        bytes memory param\n    ) internal {\n        FlashLoanData memory flashLoanData;\n        // Initialize arrays\n        flashLoanData.totalFees = new uint256[](vTokens.length);\n        flashLoanData.protocolFees = new uint256[](vTokens.length);\n        flashLoanData.actualRepayments = new uint256[](vTokens.length);\n        flashLoanData.remainingDebts = new uint256[](vTokens.length);\n\n        // Phase 1: Calculate fees and transfer assets\n        _executePhase1(receiver, vTokens, underlyingAmounts, flashLoanData);\n        // Phase 2: Execute operations on receiver contract\n        uint256[] memory tokensApproved = _executePhase2(\n            onBehalf,\n            receiver,\n            vTokens,\n            underlyingAmounts,\n            flashLoanData.totalFees,\n            param\n        );\n        // Phase 3: Handles repayment\n        _executePhase3(onBehalf, receiver, vTokens, tokensApproved, flashLoanData);\n    }\n\n    /**\n     * @notice Phase 1: Calculate fees and transfer assets to receiver\n     */\n    function _executePhase1(\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        FlashLoanData memory flashLoanData\n    ) internal {\n        for (uint256 i; i < vTokens.length; ++i) {\n            (flashLoanData.totalFees[i], flashLoanData.protocolFees[i]) = vTokens[i].calculateFlashLoanFee(\n                underlyingAmounts[i]\n            );\n\n            // Transfer the asset to receiver\n            vTokens[i].transferOutUnderlyingFlashLoan(receiver, underlyingAmounts[i]);\n        }\n    }\n\n    /**\n     * @notice Phase 2: Execute operations on receiver contract\n     */\n    function _executePhase2(\n        address payable onBehalf,\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        uint256[] memory totalFees,\n        bytes memory param\n    ) internal returns (uint256[] memory) {\n        (bool success, uint256[] memory tokensApproved) = IFlashLoanReceiver(receiver).executeOperation(\n            vTokens,\n            underlyingAmounts,\n            totalFees,\n            onBehalf,\n            param\n        );\n\n        if (!success) {\n            revert ExecuteFlashLoanFailed();\n        }\n        return tokensApproved;\n    }\n\n    /**\n     * @notice Phase 3: Handles repayment based on full or partial repayment\n     * @dev If full repayment is made, transfer protocol fee to protocol share reserve and update state.\n     *      If partial repayment is made, create an ongoing debt position for the unpaid balance.\n     */\n    function _executePhase3(\n        address payable onBehalf,\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmountsToRepay,\n        FlashLoanData memory flashLoanData\n    ) internal {\n        for (uint256 i; i < vTokens.length; ++i) {\n            _handleFlashLoan(\n                vTokens[i],\n                onBehalf,\n                receiver,\n                underlyingAmountsToRepay[i],\n                flashLoanData.totalFees[i],\n                flashLoanData.protocolFees[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Handles the repayment and fee logic for a flash loan.\n     * @dev Transfers the repaid amount from the receiver, checks if the full amount plus fee is repaid,\n     *      and either settles the protocol fee or creates an ongoing debt position for any unpaid balance.\n     *      Updates the protocol share reserve state if the protocol fee is transferred.\n     * @param vToken The vToken contract for the asset being flash loaned.\n     * @param onBehalf The address of the EOA who initiated the flash loan.\n     * @param receiver The address that received the flash loan and is repaying.\n     * @param amountRepaid The amount repaid by the receiver (principal + fee).\n     * @param totalFee The total fee charged for the flash loan.\n     * @param protocolFee The portion of the total fee allocated to the protocol.\n     */\n    function _handleFlashLoan(\n        VToken vToken,\n        address payable onBehalf,\n        address payable receiver,\n        uint256 amountRepaid,\n        uint256 totalFee,\n        uint256 protocolFee\n    ) internal {\n        uint256 borrowedFlashLoanAmount = vToken.flashLoanAmount();\n        uint256 maxExpectedRepayment = borrowedFlashLoanAmount + totalFee;\n        uint256 actualRepayment = amountRepaid > maxExpectedRepayment ? maxExpectedRepayment : amountRepaid;\n\n        if (actualRepayment < totalFee) {\n            revert NotEnoughRepayment(actualRepayment, totalFee);\n        }\n\n        // Transfer repayment (this will handle the protocol fee as well)\n        uint256 actualAmountTransferred = vToken.transferInUnderlyingFlashLoan(receiver, actualRepayment, protocolFee);\n\n        if (maxExpectedRepayment > actualAmountTransferred) {\n            // If there is any unpaid balance, it becomes an ongoing debt\n            uint256 leftUnpaidBalance = maxExpectedRepayment - actualAmountTransferred;\n\n            uint256 debtError = vToken.borrowDebtPosition(onBehalf, leftUnpaidBalance);\n            if (debtError != 0) {\n                revert FailedToCreateDebtPosition();\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/MarketFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IMarketFacet } from \"../interfaces/IMarketFacet.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\nimport { WeightFunction } from \"../interfaces/IFacetBase.sol\";\n\n/**\n * @title MarketFacet\n * @author Venus\n * @dev This facet contains all the methods related to the market's management in the pool\n * @notice This facet contract contains functions regarding markets\n */\ncontract MarketFacet is IMarketFacet, FacetBase {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(VToken indexed vToken);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(VToken indexed vToken, address indexed account);\n\n    /// @notice Emitted when the borrowing or redeeming delegate rights are updated for an account\n    event DelegateUpdated(address indexed approver, address indexed delegate, bool approved);\n\n    /// @notice Emitted when an admin unlists a market\n    event MarketUnlisted(address indexed vToken);\n\n    /// @notice Emitted when a market is initialized in a pool\n    event PoolMarketInitialized(uint96 indexed poolId, address indexed market);\n\n    /// @notice Emitted when a user enters or exits a pool (poolId = 0 means exit)\n    event PoolSelected(address indexed account, uint96 previousPoolId, uint96 indexed newPoolId);\n\n    /// @notice Emitted when a vToken market is removed from a pool\n    event PoolMarketRemoved(uint96 indexed poolId, address indexed vToken);\n\n    /// @notice Emitted when a new pool is created\n    event PoolCreated(uint96 indexed poolId, string label);\n\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() public pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Returns the vToken markets an account has entered in the Core Pool\n     * @dev Reads membership from the Core Pool (`poolId = 0`). Although the account may have entered other pools,\n     *      all entered market state is recorded in the Core Pool indexes, making this function applicable to all poolIds\n     * @param account The address of the account to query\n     * @return assets A dynamic array of vToken markets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\n        uint256 len;\n        VToken[] memory _accountAssets = accountAssets[account];\n        uint256 _accountAssetsLength = _accountAssets.length;\n\n        VToken[] memory assetsIn = new VToken[](_accountAssetsLength);\n\n        for (uint256 i; i < _accountAssetsLength; ++i) {\n            Market storage market = getCorePoolMarket(address(_accountAssets[i]));\n            if (market.isListed) {\n                assetsIn[len] = _accountAssets[i];\n                ++len;\n            }\n        }\n\n        assembly {\n            mstore(assetsIn, len)\n        }\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market\n     * @return The list of market addresses\n     */\n    function getAllMarkets() external view returns (VToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenBorrowed The address of the borrowed vToken\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateCalculateSeizeTokens(\n            address(this),\n            vTokenBorrowed,\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param borrower Address of borrower whose collateral is being seized\n     * @param vTokenBorrowed The address of the borrowed vToken\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateCalculateSeizeTokens(\n            borrower,\n            address(this),\n            vTokenBorrowed,\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateVAICalculateSeizeTokens(\n            address(this),\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Returns whether the given account has entered the specified vToken market in the Core Pool\n     * @dev Reads membership from the Core Pool (`poolId = 0`). Although the account may have entered other pools,\n     *      all entered market state is recorded in the Core Pool indexes, making this function applicable to all poolIds\n     * @param account The address of the account to check\n     * @param vToken The vToken to check\n     * @return True if the account is in the asset, otherwise false\n     */\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\n        return getCorePoolMarket(address(vToken)).accountMembership[account];\n    }\n\n    /**\n     * @notice Checks whether the given vToken market is listed in the Core Pool (`poolId = 0`)\n     * @param vToken The vToken Address of the market to check\n     * @return listed True if the (Core Pool, vToken) market is listed, otherwise false\n     */\n    function isMarketListed(VToken vToken) external view returns (bool) {\n        return getCorePoolMarket(address(vToken)).isListed;\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param vTokens The list of addresses of the vToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory) {\n        uint256 len = vTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i; i < len; ++i) {\n            results[i] = uint256(addToMarketInternal(VToken(vTokens[i]), msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Unlists the given vToken market from the Core Pool (`poolId = 0`) by setting `isListed` to false\n     * @dev Checks if market actions are paused and borrowCap/supplyCap/CF are set to 0\n     * @param market The address of the market (vToken) to unlist\n     * @return uint256 0=success, otherwise a failure (See enum Error for details)\n     */\n    function unlistMarket(address market) external returns (uint256) {\n        ensureAllowed(\"unlistMarket(address)\");\n\n        Market storage _market = getCorePoolMarket(market);\n\n        if (!_market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNLIST_MARKET_NOT_LISTED);\n        }\n\n        require(actionPaused(market, Action.BORROW), \"borrow action is not paused\");\n        require(actionPaused(market, Action.MINT), \"mint action is not paused\");\n        require(actionPaused(market, Action.REDEEM), \"redeem action is not paused\");\n        require(actionPaused(market, Action.REPAY), \"repay action is not paused\");\n        require(actionPaused(market, Action.ENTER_MARKET), \"enter market action is not paused\");\n        require(actionPaused(market, Action.LIQUIDATE), \"liquidate action is not paused\");\n        require(actionPaused(market, Action.SEIZE), \"seize action is not paused\");\n        require(actionPaused(market, Action.TRANSFER), \"transfer action is not paused\");\n        require(actionPaused(market, Action.EXIT_MARKET), \"exit market action is not paused\");\n\n        require(borrowCaps[market] == 0, \"borrow cap is not 0\");\n        require(supplyCaps[market] == 0, \"supply cap is not 0\");\n\n        require(_market.collateralFactorMantissa == 0, \"collateral factor is not 0\");\n\n        _market.isListed = false;\n        emit MarketUnlisted(market);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow\n     * @param vTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address vTokenAddress) external returns (uint256) {\n        checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\n\n        VToken vToken = VToken(vTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = getCorePoolMarket(address(vToken));\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set vToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete vToken from the account’s list of assets */\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\n        VToken[] storage userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 i;\n        for (; i < len; ++i) {\n            if (userAssetList[i] == vToken) {\n                userAssetList[i] = userAssetList[len - 1];\n                userAssetList.pop();\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(i < len);\n\n        emit MarketExited(vToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _supportMarket to support the Isolated Lending Comptroller Interface\n     * @param vToken The address of the market (token) to list\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function supportMarket(VToken vToken) external returns (uint256) {\n        return __supportMarket(vToken);\n    }\n\n    /**\n     * @notice Adds the given vToken market to the Core Pool (`poolId = 0`) and marks it as listed\n     * @dev Allows a privileged role to add and list markets to the Comptroller\n     * @param vToken The address of the vToken market to list in the Core Pool\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(VToken vToken) external returns (uint256) {\n        return __supportMarket(vToken);\n    }\n\n    /**\n     * @notice Grants or revokes the borrowing or redeeming delegate rights to / from an account\n     *  If allowed, the delegate will be able to borrow funds on behalf of the sender\n     *  Upon a delegated borrow, the delegate will receive the funds, and the borrower\n     *  will see the debt on their account\n     *  Upon a delegated redeem, the delegate will receive the redeemed amount and the approver\n     *  will see a deduction in his vToken balance\n     * @param delegate The address to update the rights for\n     * @param approved Whether to grant (true) or revoke (false) the borrowing or redeeming rights\n     */\n    function updateDelegate(address delegate, bool approved) external {\n        ensureNonzeroAddress(delegate);\n        require(approvedDelegates[msg.sender][delegate] != approved, \"Delegation status unchanged\");\n\n        _updateDelegate(msg.sender, delegate, approved);\n    }\n\n    /**\n     * @notice Allows a user to switch to a new pool (e.g., e-mode ).\n     * @param poolId The ID of the pool the user wants to enter.\n     * @custom:error PoolDoesNotExist The specified pool ID does not exist.\n     * @custom:error AlreadyInSelectedPool The user is already in the target pool.\n     * @custom:error IncompatibleBorrowedAssets The user's current borrows are incompatible with the new pool.\n     * @custom:error LiquidityCheckFailed The user's liquidity is insufficient after switching pools.\n     * @custom:error InactivePool The user is trying to enter inactive pool.\n     * @custom:event PoolSelected Emitted after a successful pool switch.\n     */\n    function enterPool(uint96 poolId) external {\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        if (poolId == userPoolId[msg.sender]) {\n            revert AlreadyInSelectedPool();\n        }\n\n        if (poolId != corePoolId && !pools[poolId].isActive) {\n            revert InactivePool(poolId);\n        }\n\n        if (!hasValidPoolBorrows(msg.sender, poolId)) {\n            revert IncompatibleBorrowedAssets();\n        }\n\n        emit PoolSelected(msg.sender, userPoolId[msg.sender], poolId);\n\n        userPoolId[msg.sender] = poolId;\n\n        (uint256 error, , uint256 shortfall) = _getAccountLiquidity(msg.sender, WeightFunction.USE_COLLATERAL_FACTOR);\n\n        if (error != 0 || shortfall > 0) {\n            revert LiquidityCheckFailed(error, shortfall);\n        }\n    }\n\n    /**\n     * @notice Creates a new pool with the given label.\n     * @param label name for the pool (must be non-empty).\n     * @return poolId The incremental unique identifier of the newly created pool.\n     * @custom:error EmptyPoolLabel Reverts if the provided label is an empty string.\n     * @custom:event PoolCreated Emitted after successfully creating a new pool.\n     */\n    function createPool(string memory label) external returns (uint96) {\n        ensureAllowed(\"createPool(string)\");\n\n        if (bytes(label).length == 0) {\n            revert EmptyPoolLabel();\n        }\n\n        uint96 poolId = ++lastPoolId;\n        PoolData storage newPool = pools[poolId];\n        newPool.label = label;\n        newPool.isActive = true;\n\n        emit PoolCreated(poolId, label);\n        return poolId;\n    }\n\n    /**\n     * @notice Batch initializes market entries with basic config.\n     * @param poolIds Array of pool IDs.\n     * @param vTokens Array of market (vToken) addresses.\n     * @custom:error ArrayLengthMismatch Reverts if `poolIds` and `vTokens` arrays have different lengths or if the length is zero.\n     * @custom:error InvalidOperationForCorePool Reverts when attempting to call pool-specific methods on the Core Pool.\n     * @custom:error PoolDoesNotExist Reverts if the target pool ID does not exist.\n     * @custom:error MarketNotListedInCorePool Reverts if the market is not listed in the core pool.\n     * @custom:error MarketAlreadyListed Reverts if the given market is already listed in the specified pool.\n     * @custom:error InactivePool Reverts if attempted to add markets to an inactive pool.\n     * @custom:event PoolMarketInitialized Emitted after successfully initializing a market in a pool.\n     */\n    function addPoolMarkets(uint96[] calldata poolIds, address[] calldata vTokens) external {\n        ensureAllowed(\"addPoolMarkets(uint96[],address[])\");\n\n        uint256 len = poolIds.length;\n        if (len == 0 || len != vTokens.length) {\n            revert ArrayLengthMismatch();\n        }\n\n        for (uint256 i; i < len; ++i) {\n            _addPoolMarket(poolIds[i], vTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Removes a market (vToken) from the specified pool.\n     * @param poolId The ID of the pool from which the market should be removed.\n     * @param vToken The address of the market token to remove.\n     * @custom:error InvalidOperationForCorePool Reverts if called on the Core Pool.\n     * @custom:error PoolMarketNotFound Reverts if the market is not listed in the pool.\n     * @custom:event PoolMarketRemoved Emitted after a market is successfully removed from a pool.\n     */\n    function removePoolMarket(uint96 poolId, address vToken) external {\n        ensureAllowed(\"removePoolMarket(uint96,address)\");\n\n        if (poolId == corePoolId) revert InvalidOperationForCorePool();\n        PoolMarketId index = getPoolMarketIndex(poolId, vToken);\n        if (!_poolMarkets[index].isListed) {\n            revert PoolMarketNotFound(poolId, vToken);\n        }\n\n        address[] storage assets = pools[poolId].vTokens;\n\n        uint256 length = assets.length;\n        for (uint256 i; i < length; ++i) {\n            if (assets[i] == vToken) {\n                assets[i] = assets[length - 1];\n                assets.pop();\n                break;\n            }\n        }\n\n        delete _poolMarkets[index];\n\n        emit PoolMarketRemoved(poolId, vToken);\n    }\n\n    /**\n     * @notice Get the core pool collateral factor for a vToken\n     * @param vToken The address of the vToken to get the collateral factor for\n     * @return The collateral factor for the vToken, scaled by 1e18\n     */\n    function getCollateralFactor(address vToken) external view returns (uint256) {\n        (uint256 cf, , ) = getLiquidationParams(corePoolId, vToken);\n        return cf;\n    }\n\n    /**\n     * @notice Get the core pool liquidation threshold for a vToken\n     * @param vToken The address of the vToken to get the liquidation threshold for\n     * @return The liquidation threshold for the vToken, scaled by 1e18\n     */\n    function getLiquidationThreshold(address vToken) external view returns (uint256) {\n        (, uint256 lt, ) = getLiquidationParams(corePoolId, vToken);\n        return lt;\n    }\n\n    /**\n     * @notice Get the core pool liquidation Incentive for a vToken\n     * @param vToken The address of the vToken to get the liquidation Incentive for\n     * @return liquidationIncentive The liquidation incentive for the vToken, scaled by 1e18\n     */\n    function getLiquidationIncentive(address vToken) external view returns (uint256) {\n        (, , uint256 li) = getLiquidationParams(corePoolId, vToken);\n        return li;\n    }\n\n    /**\n     * @notice Get the effective loan-to-value factor (collateral factor or liquidation threshold) for a given account and market.\n     * @dev The value is determined by the pool entered by the account and the specified vToken via\n     *      `getLiquidationParams()`. If the pool is inactive, or if the vToken is not configured in the\n     *      account's pool and `allowCorePoolFallback` is enabled, the core pool (poolId = 0) values are used.\n     *      This value is used for account liquidity calculations and liquidation checks.\n     * @param account The account whose pool is used to determine the market's risk parameters.\n     * @param vToken The address of the vToken market.\n     * @param weightingStrategy The weighting strategy to use:\n     *                          - `WeightFunction.USE_COLLATERAL_FACTOR` to use collateral factor\n     *                          - `WeightFunction.USE_LIQUIDATION_THRESHOLD` to use liquidation threshold\n     * @return factor The effective loan-to-value factor, scaled by 1e18.\n     */\n    function getEffectiveLtvFactor(\n        address account,\n        address vToken,\n        WeightFunction weightingStrategy\n    ) external view returns (uint256) {\n        (uint256 cf, uint256 lt, ) = getLiquidationParams(userPoolId[account], vToken);\n        if (weightingStrategy == WeightFunction.USE_COLLATERAL_FACTOR) return cf;\n        else if (weightingStrategy == WeightFunction.USE_LIQUIDATION_THRESHOLD) return lt;\n        else revert InvalidWeightingStrategy(weightingStrategy);\n    }\n\n    /**\n     * @notice Get the Effective Liquidation Incentive for a given account and market\n     * @dev The incentive is determined by the pool entered by the account and the specified vToken via\n     *      `getLiquidationParams()`. If the pool is inactive, or if the vToken is not configured in the\n     *      account's pool and `allowCorePoolFallback` is enabled, the core pool (poolId = 0) values are used\n     * @param account The account whose pool is used to determine the market's risk parameters\n     * @param vToken The address of the vToken market\n     * @return The liquidation Incentive for the vToken, scaled by 1e18\n     */\n    function getEffectiveLiquidationIncentive(address account, address vToken) external view returns (uint256) {\n        (, , uint256 li) = getLiquidationParams(userPoolId[account], vToken);\n        return li;\n    }\n\n    /**\n     * @notice Returns the full list of vTokens for a given pool ID.\n     * @param poolId The ID of the pool whose vTokens are being queried.\n     * @return An array of vToken addresses associated with the pool.\n     * @custom:error PoolDoesNotExist Reverts if the given pool ID do not exist.\n     * @custom:error InvalidOperationForCorePool Reverts if called on the Core Pool.\n     */\n    function getPoolVTokens(uint96 poolId) external view returns (address[] memory) {\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n        if (poolId == corePoolId) revert InvalidOperationForCorePool();\n        return pools[poolId].vTokens;\n    }\n\n    /**\n     * @notice Returns the market configuration for a vToken in the core pool (poolId = 0).\n     * @dev Fetches the Market struct associated with the core pool and returns all relevant parameters.\n     * @param vToken The address of the vToken whose market configuration is to be fetched.\n     * @return isListed Whether the market is listed and enabled.\n     * @return collateralFactorMantissa The maximum borrowable percentage of collateral, in mantissa.\n     * @return isVenus Whether this market is eligible for VENUS rewards.\n     * @return liquidationThresholdMantissa The threshold at which liquidation is triggered, in mantissa.\n     * @return liquidationIncentiveMantissa The max liquidation incentive allowed for this market, in mantissa.\n     * @return marketPoolId The pool ID this market belongs to.\n     * @return isBorrowAllowed Whether borrowing is allowed in this market.\n     */\n    function markets(\n        address vToken\n    )\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 liquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        )\n    {\n        return poolMarkets(corePoolId, vToken);\n    }\n\n    /**\n     * @notice Returns the market configuration for a vToken from _poolMarkets.\n     * @dev Fetches the Market struct associated with the poolId and returns all relevant parameters.\n     * @param poolId The ID of the pool whose market configuration is being queried.\n     * @param vToken The address of the vToken whose market configuration is to be fetched.\n     * @return isListed Whether the market is listed and enabled.\n     * @return collateralFactorMantissa The maximum borrowable percentage of collateral, in mantissa.\n     * @return isVenus Whether this market is eligible for XVS rewards.\n     * @return liquidationThresholdMantissa The threshold at which liquidation is triggered, in mantissa.\n     * @return liquidationIncentiveMantissa The liquidation incentive allowed for this market, in mantissa.\n     * @return marketPoolId The pool ID this market belongs to.\n     * @return isBorrowAllowed Whether borrowing is allowed in this market.\n     * @custom:error PoolDoesNotExist Reverts if the given pool ID do not exist.\n     */\n    function poolMarkets(\n        uint96 poolId,\n        address vToken\n    )\n        public\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 liquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        )\n    {\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n        PoolMarketId key = getPoolMarketIndex(poolId, vToken);\n        Market storage m = _poolMarkets[key];\n\n        return (\n            m.isListed,\n            m.collateralFactorMantissa,\n            m.isVenus,\n            m.liquidationThresholdMantissa,\n            m.liquidationIncentiveMantissa,\n            m.poolId,\n            m.isBorrowAllowed\n        );\n    }\n\n    /**\n     * @notice Returns true if the user can switch to the given target pool, i.e.,\n     * all markets they have borrowed from are also borrowable in the target pool.\n     * @param account The address of the user attempting to switch pools.\n     * @param targetPoolId The pool ID the user wants to switch into.\n     * @return bool True if the switch is allowed, otherwise False.\n     */\n    function hasValidPoolBorrows(address account, uint96 targetPoolId) public view returns (bool) {\n        VToken[] memory assets = accountAssets[account];\n        if (targetPoolId != corePoolId && mintedVAIs[account] > 0) {\n            return false;\n        }\n\n        for (uint256 i; i < assets.length; ++i) {\n            VToken vToken = assets[i];\n            PoolMarketId index = getPoolMarketIndex(targetPoolId, address(vToken));\n\n            if (!_poolMarkets[index].isBorrowAllowed) {\n                if (vToken.borrowBalanceStored(account) > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    function _updateDelegate(address approver, address delegate, bool approved) internal {\n        approvedDelegates[approver][delegate] = approved;\n        emit DelegateUpdated(approver, delegate, approved);\n    }\n\n    function _addMarketInternal(VToken vToken) internal {\n        uint256 allMarketsLength = allMarkets.length;\n        for (uint256 i; i < allMarketsLength; ++i) {\n            require(allMarkets[i] != vToken, \"already added\");\n        }\n        allMarkets.push(vToken);\n    }\n\n    function _initializeMarket(address vToken) internal {\n        uint32 blockNumber = getBlockNumberAsUint32();\n\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n\n        /*\n         * Update market state indices\n         */\n        if (supplyState.index == 0) {\n            // Initialize supply state index with default value\n            supplyState.index = venusInitialIndex;\n        }\n\n        if (borrowState.index == 0) {\n            // Initialize borrow state index with default value\n            borrowState.index = venusInitialIndex;\n        }\n\n        /*\n         * Update market state block numbers\n         */\n        supplyState.block = borrowState.block = blockNumber;\n    }\n\n    function __supportMarket(VToken vToken) internal returns (uint256) {\n        ensureAllowed(\"_supportMarket(address)\");\n\n        if (getCorePoolMarket(address(vToken)).isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n        // Note that isVenus is not in active use anymore\n        Market storage newMarket = getCorePoolMarket(address(vToken));\n        newMarket.isListed = true;\n        newMarket.isVenus = false;\n        newMarket.collateralFactorMantissa = 0;\n\n        _addMarketInternal(vToken);\n        _initializeMarket(address(vToken));\n\n        emit MarketListed(vToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _addPoolMarket(uint96 poolId, address vToken) internal {\n        if (poolId == corePoolId) revert InvalidOperationForCorePool();\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n        if (!pools[poolId].isActive) revert InactivePool(poolId);\n\n        // Core Pool Index\n        PoolMarketId index = getPoolMarketIndex(corePoolId, vToken);\n        if (!_poolMarkets[index].isListed) revert MarketNotListedInCorePool();\n\n        // Pool Index\n        index = getPoolMarketIndex(poolId, vToken);\n        if (_poolMarkets[index].isListed) revert MarketAlreadyListed(poolId, vToken);\n\n        Market storage m = _poolMarkets[index];\n        m.poolId = poolId;\n        m.isListed = true;\n\n        pools[poolId].vTokens.push(vToken);\n\n        emit PoolMarketInitialized(poolId, vToken);\n    }\n\n    /**\n     * @notice Returns only the core risk parameters (CF, LI, LT) for a vToken in a specific pool.\n     * @dev If the pool is inactive, or if the vToken is not configured in the given pool and\n     *      `allowCorePoolFallback` is enabled, falls back to the core pool (poolId = 0) values.\n     * @return collateralFactorMantissa The max borrowable percentage of collateral, in mantissa.\n     * @return liquidationThresholdMantissa The threshold at which liquidation is triggered, in mantissa.\n     * @return liquidationIncentiveMantissa The liquidation incentive allowed for this market, in mantissa.\n     */\n    function getLiquidationParams(\n        uint96 poolId,\n        address vToken\n    )\n        internal\n        view\n        returns (\n            uint256 collateralFactorMantissa,\n            uint256 liquidationThresholdMantissa,\n            uint256 liquidationIncentiveMantissa\n        )\n    {\n        PoolData storage pool = pools[poolId];\n        Market storage market;\n\n        if (poolId == corePoolId || !pool.isActive) {\n            market = getCorePoolMarket(vToken);\n        } else {\n            PoolMarketId poolKey = getPoolMarketIndex(poolId, vToken);\n            Market storage poolMarket = _poolMarkets[poolKey];\n            market = (!poolMarket.isListed && pool.allowCorePoolFallback) ? getCorePoolMarket(vToken) : poolMarket;\n        }\n\n        return (\n            market.collateralFactorMantissa,\n            market.liquidationThresholdMantissa,\n            market.liquidationIncentiveMantissa\n        );\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/PolicyFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IPolicyFacet } from \"../interfaces/IPolicyFacet.sol\";\nimport { XVSRewardsHelper } from \"./XVSRewardsHelper.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\nimport { WeightFunction } from \"../interfaces/IFacetBase.sol\";\n\n/**\n * @title PolicyFacet\n * @author Venus\n * @dev This facet contains all the hooks used while transferring the assets\n * @notice This facet contract contains all the external pre-hook functions related to vToken\n */\ncontract PolicyFacet is IPolicyFacet, XVSRewardsHelper {\n    /// @notice Emitted when a new borrow-side XVS speed is calculated for a market\n    event VenusBorrowSpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /// @notice Emitted when a new supply-side XVS speed is calculated for a market\n    event VenusSupplySpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param vToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.MINT);\n        ensureListed(getCorePoolMarket(vToken));\n\n        uint256 supplyCap = supplyCaps[vToken];\n        require(supplyCap != 0, \"market supply cap is 0\");\n\n        uint256 vTokenSupply = VToken(vToken).totalSupply();\n        Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\n        uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\n\n        require(nextTotalSupply <= supplyCap, \"market supply cap reached\");\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, minter);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    // solhint-disable-next-line no-unused-vars\n    function mintVerify(address vToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(minter, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param vToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address vToken, address redeemer, uint256 redeemTokens) external returns (uint256) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REDEEM);\n\n        uint256 allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, redeemer);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address vToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external {\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(redeemer, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param vToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address vToken, address borrower, uint256 borrowAmount) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.BORROW);\n        ensureListed(getCorePoolMarket(vToken));\n        poolBorrowAllowed(borrower, vToken);\n\n        uint256 borrowCap = borrowCaps[vToken];\n        require(borrowCap != 0, \"market borrow cap is 0\");\n\n        if (!getCorePoolMarket(vToken).accountMembership[borrower]) {\n            // only vTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == vToken, \"sender must be vToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(VToken(vToken), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n        }\n\n        if (oracle.getUnderlyingPrice(vToken) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        uint256 nextTotalBorrows = add_(VToken(vToken).totalBorrows(), borrowAmount);\n        require(nextTotalBorrows <= borrowCap, \"market borrow cap reached\");\n\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            VToken(vToken),\n            0,\n            borrowAmount,\n            WeightFunction.USE_COLLATERAL_FACTOR\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n\n        if (shortfall != 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    // solhint-disable-next-line no-unused-vars\n    function borrowVerify(address vToken, address borrower, uint256 borrowAmount) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param vToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address vToken,\n        address payer, // solhint-disable-line no-unused-vars\n        address borrower,\n        uint256 repayAmount // solhint-disable-line no-unused-vars\n    ) external returns (uint256) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REPAY);\n        ensureListed(getCorePoolMarket(vToken));\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address vToken,\n        address payer, // solhint-disable-line no-unused-vars\n        address borrower,\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\n        uint256 borrowerIndex // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external view returns (uint256) {\n        checkProtocolPauseState();\n\n        // if we want to pause liquidating to vTokenCollateral, we should pause seizing\n        checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\n\n        if (liquidatorContract != address(0) && liquidator != liquidatorContract) {\n            return uint256(Error.UNAUTHORIZED);\n        }\n\n        ensureListed(getCorePoolMarket(vTokenCollateral));\n        uint256 borrowBalance;\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(getCorePoolMarket(vTokenBorrowed));\n            borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\n        } else {\n            borrowBalance = vaiController.getVAIRepayAmount(borrower);\n        }\n\n        if (isForcedLiquidationEnabled[vTokenBorrowed] || isForcedLiquidationEnabledForUser[borrower][vTokenBorrowed]) {\n            if (repayAmount > borrowBalance) {\n                return uint(Error.TOO_MUCH_REPAY);\n            }\n            return uint(Error.NO_ERROR);\n        }\n\n        /* The borrower must have shortfall in order to be liquidatable */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            VToken(address(0)),\n            0,\n            0,\n            WeightFunction.USE_LIQUIDATION_THRESHOLD\n        );\n\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall == 0) {\n            return uint256(Error.INSUFFICIENT_SHORTFALL);\n        }\n\n        // The liquidator may not repay more than what is allowed by the closeFactor\n        //-- maxClose = multipy of closeFactorMantissa and borrowBalance\n        if (repayAmount > mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance)) {\n            return uint256(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     * @param seizeTokens The amount of collateral token that will be seized\n     */\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral, // solhint-disable-line no-unused-vars\n        address liquidator,\n        address borrower,\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vTokenBorrowed);\n            prime.accrueInterestAndUpdateScore(liquidator, vTokenBorrowed);\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vTokenCollateral, Action.SEIZE);\n\n        Market storage market = getCorePoolMarket(vTokenCollateral);\n\n        // We've added VAIController as a borrowed token list check for seize\n        ensureListed(market);\n\n        if (!market.accountMembership[borrower]) {\n            return uint256(Error.MARKET_NOT_COLLATERAL);\n        }\n\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(getCorePoolMarket(vTokenBorrowed));\n        }\n\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vTokenCollateral);\n        distributeSupplierVenus(vTokenCollateral, borrower);\n        distributeSupplierVenus(vTokenCollateral, liquidator);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed, // solhint-disable-line no-unused-vars\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vTokenCollateral);\n            prime.accrueInterestAndUpdateScore(liquidator, vTokenCollateral);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param vToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.TRANSFER);\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(vToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, src);\n        distributeSupplierVenus(vToken, dst);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     */\n    // solhint-disable-next-line no-unused-vars\n    function transferVerify(address vToken, address src, address dst, uint256 transferTokens) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(src, vToken);\n            prime.accrueInterestAndUpdateScore(dst, vToken);\n        }\n    }\n\n    /**\n     * @notice Alias to getAccountLiquidity to support the Isolated Lending Comptroller Interface\n     * @param account The account get liquidity for\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getBorrowingPower(address account) external view returns (uint256, uint256, uint256) {\n        return _getAccountLiquidity(account, WeightFunction.USE_COLLATERAL_FACTOR);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt liquidation threshold requirements\n     * @param account The account get liquidity for\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of liquidation threshold requirements,\n     *          account shortfall below liquidation threshold requirements)\n     */\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256) {\n        return _getAccountLiquidity(account, WeightFunction.USE_LIQUIDATION_THRESHOLD);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external view returns (uint256, uint256, uint256) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(vTokenModify),\n            redeemTokens,\n            borrowAmount,\n            WeightFunction.USE_COLLATERAL_FACTOR\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    // setter functionality\n    /**\n     * @notice Set XVS speed for a single market\n     * @dev Allows the contract admin to set XVS speed for a market\n     * @param vTokens The market whose XVS speed to update\n     * @param supplySpeeds New XVS speed for supply\n     * @param borrowSpeeds New XVS speed for borrow\n     */\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint256[] calldata supplySpeeds,\n        uint256[] calldata borrowSpeeds\n    ) external {\n        ensureAdmin();\n\n        uint256 numTokens = vTokens.length;\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"invalid input\");\n\n        for (uint256 i; i < numTokens; ++i) {\n            ensureNonzeroAddress(address(vTokens[i]));\n            setVenusSpeedInternal(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n        }\n    }\n\n    /**\n     * @dev Internal function to set XVS speed for a single market\n     * @param vToken The market whose XVS speed to update\n     * @param supplySpeed New XVS speed for supply\n     * @param borrowSpeed New XVS speed for borrow\n     * @custom:event VenusSupplySpeedUpdated Emitted after the venus supply speed for a market is updated\n     * @custom:event VenusBorrowSpeedUpdated Emitted after the venus borrow speed for a market is updated\n     */\n    function setVenusSpeedInternal(VToken vToken, uint256 supplySpeed, uint256 borrowSpeed) internal {\n        ensureListed(getCorePoolMarket(address(vToken)));\n\n        if (venusSupplySpeeds[address(vToken)] != supplySpeed) {\n            // Supply speed updated so let's update supply state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n\n            updateVenusSupplyIndex(address(vToken));\n            // Update speed and emit event\n            venusSupplySpeeds[address(vToken)] = supplySpeed;\n            emit VenusSupplySpeedUpdated(vToken, supplySpeed);\n        }\n\n        if (venusBorrowSpeeds[address(vToken)] != borrowSpeed) {\n            // Borrow speed updated so let's update borrow state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n            // Update speed and emit event\n            venusBorrowSpeeds[address(vToken)] = borrowSpeed;\n            emit VenusBorrowSpeedUpdated(vToken, borrowSpeed);\n        }\n    }\n\n    /**\n     * @dev Checks if vToken borrowing is allowed in the account's entered pool\n     *      Reverts if borrowing is not permitted\n     * @param account The address of the account whose borrow permission is being checked\n     * @param vToken The vToken market to check borrowing status for\n     * @custom:error BorrowNotAllowedInPool Reverts if borrowing is not allowed in the account's entered pool\n     * @custom:error InactivePool Reverts if borrowing in an inactive pool.\n     */\n    function poolBorrowAllowed(address account, address vToken) internal view {\n        uint96 userPool = userPoolId[account];\n        PoolMarketId index = getPoolMarketIndex(userPool, vToken);\n        if (!_poolMarkets[index].isBorrowAllowed) {\n            revert BorrowNotAllowedInPool();\n        }\n        if (userPool != corePoolId && !pools[userPool].isActive) {\n            revert InactivePool(userPool);\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/RewardFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { IRewardFacet } from \"../interfaces/IRewardFacet.sol\";\nimport { XVSRewardsHelper } from \"./XVSRewardsHelper.sol\";\nimport { VBep20Interface } from \"../../../Tokens/VTokens/VTokenInterfaces.sol\";\nimport { WeightFunction } from \"../interfaces/IFacetBase.sol\";\n\n/**\n * @title RewardFacet\n * @author Venus\n * @dev This facet contains all the methods related to the reward functionality\n * @notice This facet contract provides the external functions related to all claims and rewards of the protocol\n */\ncontract RewardFacet is IRewardFacet, XVSRewardsHelper {\n    /// @notice Emitted when Venus is granted by admin\n    event VenusGranted(address indexed recipient, uint256 amount);\n\n    /// @notice Emitted when XVS are seized for the holder\n    event VenusSeized(address indexed holder, uint256 amount);\n\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\n     * @param holder The address to claim XVS for\n     */\n    function claimVenus(address holder) public {\n        return claimVenus(holder, allMarkets);\n    }\n\n    /**\n     * @notice Claim all the xvs accrued by holder in the specified markets\n     * @param holder The address to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     */\n    function claimVenus(address holder, VToken[] memory vTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimVenus(holders, vTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all xvs accrued by the holders\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     */\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\n        claimVenus(holders, vTokens, borrowers, suppliers, false);\n    }\n\n    /**\n     * @notice Claim all the xvs accrued by holder in all markets, a shorthand for `claimVenus` with collateral set to `true`\n     * @param holder The address to claim XVS for\n     */\n    function claimVenusAsCollateral(address holder) external {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimVenus(holders, allMarkets, true, true, true);\n    }\n\n    /**\n     * @notice Transfer XVS to the user with user's shortfall considered\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all\n     * @param user The address of the user to transfer XVS to\n     * @param amount The amount of XVS to (possibly) transfer\n     * @param shortfall The shortfall of the user\n     * @param collateral Whether or not we will use user's venus reward as collateral to pay off the debt\n     * @return The amount of XVS which was NOT transferred to the user\n     */\n    function grantXVSInternal(\n        address user,\n        uint256 amount,\n        uint256 shortfall,\n        bool collateral\n    ) internal returns (uint256) {\n        // If the user is blacklisted, they can't get XVS rewards\n        require(\n            user != 0xEF044206Db68E40520BfA82D45419d498b4bc7Bf &&\n                user != 0x7589dD3355DAE848FDbF75044A3495351655cB1A &&\n                user != 0x33df7a7F6D44307E1e5F3B15975b47515e5524c0 &&\n                user != 0x24e77E5b74B30b026E9996e4bc3329c881e24968,\n            \"Blacklisted\"\n        );\n\n        IERC20 xvs_ = IERC20(xvs);\n\n        if (amount == 0 || amount > xvs_.balanceOf(address(this))) {\n            return amount;\n        }\n\n        if (shortfall == 0) {\n            xvs_.safeTransfer(user, amount);\n            return 0;\n        }\n        // If user's bankrupt and doesn't use pending xvs as collateral, don't grant\n        // anything, otherwise, we will transfer the pending xvs as collateral to\n        // vXVS token and mint vXVS for the user\n        //\n        // If mintBehalf failed, don't grant any xvs\n        require(collateral, \"bankrupt\");\n\n        address xvsVToken_ = xvsVToken;\n\n        xvs_.safeApprove(xvsVToken_, 0);\n        xvs_.safeApprove(xvsVToken_, amount);\n        require(VBep20Interface(xvsVToken_).mintBehalf(user, amount) == uint256(Error.NO_ERROR), \"mint behalf error\");\n\n        // set venusAccrued[user] to 0\n        return 0;\n    }\n\n    /*** Venus Distribution Admin ***/\n\n    /**\n     * @notice Transfer XVS to the recipient\n     * @dev Allows the contract admin to transfer XVS to any recipient based on the recipient's shortfall\n     *      Note: If there is not enough XVS, we do not perform the transfer all\n     * @param recipient The address of the recipient to transfer XVS to\n     * @param amount The amount of XVS to (possibly) transfer\n     */\n    function _grantXVS(address recipient, uint256 amount) external {\n        ensureAdmin();\n        uint256 amountLeft = grantXVSInternal(recipient, amount, 0, false);\n        require(amountLeft == 0, \"no xvs\");\n        emit VenusGranted(recipient, amount);\n    }\n\n    /**\n     * @dev Seize XVS tokens from the specified holders and transfer to recipient\n     * @notice Seize XVS rewards allocated to holders\n     * @param holders Addresses of the XVS holders\n     * @param recipient Address of the XVS token recipient\n     * @return The total amount of XVS tokens seized and transferred to recipient\n     */\n    function seizeVenus(address[] calldata holders, address recipient) external returns (uint256) {\n        ensureAllowed(\"seizeVenus(address[],address)\");\n\n        uint256 holdersLength = holders.length;\n        uint256 totalHoldings;\n\n        updateAndDistributeRewardsInternal(holders, allMarkets, true, true);\n        for (uint256 i; i < holdersLength; ++i) {\n            address holder = holders[i];\n            uint256 userHolding = venusAccrued[holder];\n\n            if (userHolding != 0) {\n                totalHoldings += userHolding;\n                delete venusAccrued[holder];\n            }\n\n            emit VenusSeized(holder, userHolding);\n        }\n\n        if (totalHoldings != 0) {\n            IERC20(xvs).safeTransfer(recipient, totalHoldings);\n            emit VenusGranted(recipient, totalHoldings);\n        }\n\n        return totalHoldings;\n    }\n\n    /**\n     * @notice Claim all xvs accrued by the holders\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     * @param collateral Whether or not to use XVS earned as collateral, only takes effect when the holder has a shortfall\n     */\n    function claimVenus(\n        address[] memory holders,\n        VToken[] memory vTokens,\n        bool borrowers,\n        bool suppliers,\n        bool collateral\n    ) public {\n        uint256 holdersLength = holders.length;\n\n        updateAndDistributeRewardsInternal(holders, vTokens, borrowers, suppliers);\n        for (uint256 j; j < holdersLength; ++j) {\n            address holder = holders[j];\n\n            // If there is a positive shortfall, the XVS reward is accrued,\n            // but won't be granted to this holder\n            (, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n                holder,\n                VToken(address(0)),\n                0,\n                0,\n                WeightFunction.USE_COLLATERAL_FACTOR\n            );\n\n            uint256 value = venusAccrued[holder];\n            delete venusAccrued[holder];\n\n            uint256 returnAmount = grantXVSInternal(holder, value, shortfall, collateral);\n\n            // returnAmount can only be positive if balance of xvsAddress is less than grant amount(venusAccrued[holder])\n            if (returnAmount != 0) {\n                venusAccrued[holder] = returnAmount;\n            }\n        }\n    }\n\n    /**\n     * @notice Update and distribute tokens\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     */\n    function updateAndDistributeRewardsInternal(\n        address[] memory holders,\n        VToken[] memory vTokens,\n        bool borrowers,\n        bool suppliers\n    ) internal {\n        uint256 j;\n        uint256 holdersLength = holders.length;\n        uint256 vTokensLength = vTokens.length;\n\n        for (uint256 i; i < vTokensLength; ++i) {\n            VToken vToken = vTokens[i];\n            ensureListed(getCorePoolMarket(address(vToken)));\n            if (borrowers) {\n                Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\n                for (j = 0; j < holdersLength; ++j) {\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\n                }\n            }\n\n            if (suppliers) {\n                updateVenusSupplyIndex(address(vToken));\n                for (j = 0; j < holdersLength; ++j) {\n                    distributeSupplierVenus(address(vToken), holders[j]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the XVS vToken address\n     * @return The address of XVS vToken\n     */\n    function getXVSVTokenAddress() external view returns (address) {\n        return xvsVToken;\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/SetterFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { ComptrollerLensInterface } from \"../../ComptrollerLensInterface.sol\";\nimport { VAIControllerInterface } from \"../../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { IPrime } from \"../../../Tokens/Prime/IPrime.sol\";\nimport { ISetterFacet } from \"../interfaces/ISetterFacet.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\n\n/**\n * @title SetterFacet\n * @author Venus\n * @dev This facet contains all the setters for the states\n * @notice This facet contract contains all the configurational setter functions\n */\ncontract SetterFacet is ISetterFacet, FacetBase {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor for a market in a pool is changed by admin\n    event NewCollateralFactor(\n        uint96 indexed poolId,\n        VToken indexed vToken,\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n\n    /// @notice Emitted when liquidation incentive for a market in a pool is changed by admin\n    event NewLiquidationIncentive(\n        uint96 indexed poolId,\n        address indexed vToken,\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(ResilientOracleInterface oldPriceOracle, ResilientOracleInterface newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint256 oldVAIMintRate, uint256 newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint256 oldTreasuryPercent, uint256 newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address indexed vault_, uint256 releaseStartBlock_, uint256 releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint256 oldVenusVAIVaultRate, uint256 newVenusVAIVaultRate);\n\n    /// @notice Emitted when prime token contract address is changed\n    event NewPrimeToken(IPrime oldPrimeToken, IPrime newPrimeToken);\n\n    /// @notice Emitted when forced liquidation is enabled or disabled for all users in a market\n    event IsForcedLiquidationEnabledUpdated(address indexed vToken, bool enable);\n\n    /// @notice Emitted when forced liquidation is enabled or disabled for a user borrowing in a market\n    event IsForcedLiquidationEnabledForUserUpdated(address indexed borrower, address indexed vToken, bool enable);\n\n    /// @notice Emitted when XVS token address is changed\n    event NewXVSToken(address indexed oldXVS, address indexed newXVS);\n\n    /// @notice Emitted when XVS vToken address is changed\n    event NewXVSVToken(address indexed oldXVSVToken, address indexed newXVSVToken);\n\n    /// @notice Emitted when an account's flash loan whitelist status is updated\n    event IsAccountFlashLoanWhitelisted(address indexed account, bool indexed isWhitelisted);\n\n    /// @notice Emitted when liquidation threshold for a market in a pool is changed by admin\n    event NewLiquidationThreshold(\n        uint96 indexed poolId,\n        VToken indexed vToken,\n        uint256 oldLiquidationThresholdMantissa,\n        uint256 newLiquidationThresholdMantissa\n    );\n\n    /// @notice Emitted when the borrowAllowed flag is updated for a market\n    event BorrowAllowedUpdated(uint96 indexed poolId, address indexed market, bool oldStatus, bool newStatus);\n\n    /// @notice Emitted when pool active status updated\n    event PoolActiveStatusUpdated(uint96 indexed poolId, bool oldStatus, bool newStatus);\n\n    /// @notice Emitted when pool label is updated\n    event PoolLabelUpdated(uint96 indexed poolId, string oldLabel, string newLabel);\n\n    /// @notice Emitted when pool Fallback status is updated\n    event PoolFallbackStatusUpdated(uint96 indexed poolId, bool oldStatus, bool newStatus);\n\n    /**\n     * @notice Compare two addresses to ensure they are different\n     * @param oldAddress The original address to compare\n     * @param newAddress The new address to compare\n     */\n    modifier compareAddress(address oldAddress, address newAddress) {\n        require(oldAddress != newAddress, \"old address is same as new address\");\n        _;\n    }\n\n    /**\n     * @notice Compare two values to ensure they are different\n     * @param oldValue The original value to compare\n     * @param newValue The new value to compare\n     */\n    modifier compareValue(uint256 oldValue, uint256 newValue) {\n        require(oldValue != newValue, \"old value is same as new value\");\n        _;\n    }\n\n    /**\n     * @notice Alias to _setPriceOracle to support the Isolated Lending Comptroller Interface\n     * @param newOracle The new price oracle to set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256) {\n        return __setPriceOracle(newOracle);\n    }\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Allows the contract admin to set a new price oracle used by the Comptroller\n     * @param newOracle The new price oracle to set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256) {\n        return __setPriceOracle(newOracle);\n    }\n\n    /**\n     * @notice Alias to _setCloseFactor to support the Isolated Lending Comptroller Interface\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint256 0=success, otherwise will revert\n     */\n    function setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        return __setCloseFactor(newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Allows the contract admin to set the closeFactor used to liquidate borrows\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint256 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        return __setCloseFactor(newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Allows the contract admin to set the address of access control of this contract\n     * @param newAccessControlAddress New address for the access control\n     * @return uint256 0=success, otherwise will revert\n     */\n    function _setAccessControl(\n        address newAccessControlAddress\n    ) external compareAddress(accessControl, newAccessControlAddress) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateral factor and liquidation threshold for a market in the Core Pool only.\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256) {\n        ensureAllowed(\"setCollateralFactor(address,uint256,uint256)\");\n        return __setCollateralFactor(corePoolId, vToken, newCollateralFactorMantissa, newLiquidationThresholdMantissa);\n    }\n\n    /**\n     * @notice Sets the liquidation incentive for a market in the Core Pool only.\n     * @param vToken The market to set the liquidationIncentive for\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setLiquidationIncentive(\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    ) external returns (uint256) {\n        ensureAllowed(\"setLiquidationIncentive(address,uint256)\");\n        return __setLiquidationIncentive(corePoolId, vToken, newLiquidationIncentiveMantissa);\n    }\n\n    /**\n     * @notice Sets the collateral factor and liquidation threshold for a market in the specified pool.\n     * @param poolId The ID of the pool.\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setCollateralFactor(\n        uint96 poolId,\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256) {\n        ensureAllowed(\"setCollateralFactor(uint96,address,uint256,uint256)\");\n        return __setCollateralFactor(poolId, vToken, newCollateralFactorMantissa, newLiquidationThresholdMantissa);\n    }\n\n    /**\n     * @notice Sets the liquidation incentive for a market in the specified pool.\n     * @param poolId The ID of the pool.\n     * @param vToken The market to set the liquidationIncentive for\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setLiquidationIncentive(\n        uint96 poolId,\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    ) external returns (uint256) {\n        ensureAllowed(\"setLiquidationIncentive(uint96,address,uint256)\");\n        return __setLiquidationIncentive(poolId, vToken, newLiquidationIncentiveMantissa);\n    }\n\n    /**\n     * @notice Update the address of the liquidator contract\n     * @dev Allows the contract admin to update the address of liquidator contract\n     * @param newLiquidatorContract_ The new address of the liquidator contract\n     */\n    function _setLiquidatorContract(\n        address newLiquidatorContract_\n    ) external compareAddress(liquidatorContract, newLiquidatorContract_) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newLiquidatorContract_);\n        address oldLiquidatorContract = liquidatorContract;\n        liquidatorContract = newLiquidatorContract_;\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @dev Allows the contract admin to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(\n        address newPauseGuardian\n    ) external compareAddress(pauseGuardian, newPauseGuardian) returns (uint256) {\n        ensureAdmin();\n        ensureNonzeroAddress(newPauseGuardian);\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _setMarketBorrowCaps to support the Isolated Lending Comptroller Interface\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to Borrow not allowed\n     */\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\n        __setMarketBorrowCaps(vTokens, newBorrowCaps);\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given vToken market Borrowing that brings total borrows to or above borrow cap will revert\n     * @dev Allows a privileged role to set the borrowing cap for a vToken market. A borrow cap of 0 corresponds to Borrow not allowed\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to Borrow not allowed\n     */\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\n        __setMarketBorrowCaps(vTokens, newBorrowCaps);\n    }\n\n    /**\n     * @notice Alias to _setMarketSupplyCaps to support the Isolated Lending Comptroller Interface\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed\n     */\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        __setMarketSupplyCaps(vTokens, newSupplyCaps);\n    }\n\n    /**\n     * @notice Set the given supply caps for the given vToken market Supply that brings total Supply to or above supply cap will revert\n     * @dev Allows a privileged role to set the supply cap for a vToken. A supply cap of 0 corresponds to Minting NotAllowed\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed\n     */\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        __setMarketSupplyCaps(vTokens, newSupplyCaps);\n    }\n\n    /**\n     * @notice Set whole protocol pause/unpause state\n     * @dev Allows a privileged role to pause/unpause protocol\n     * @param state The new state (true=paused, false=unpaused)\n     * @return bool The updated state of the protocol\n     */\n    function _setProtocolPaused(bool state) external returns (bool) {\n        ensureAllowed(\"_setProtocolPaused(bool)\");\n\n        protocolPaused = state;\n        emit ActionProtocolPaused(state);\n        return state;\n    }\n\n    /**\n     * @notice Alias to _setActionsPaused to support the Isolated Lending Comptroller Interface\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        __setActionsPaused(markets_, actions_, paused_);\n    }\n\n    /**\n     * @notice Pause/unpause certain actions\n     * @dev Allows a privileged role to pause/unpause the protocol action state\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        __setActionsPaused(markets_, actions_, paused_);\n    }\n\n    /**\n     * @dev Pause/unpause an action on a market\n     * @param market Market to pause/unpause the action on\n     * @param action Action id to pause/unpause\n     * @param paused The new paused state (true=paused, false=unpaused)\n     */\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\n        ensureListed(getCorePoolMarket(market));\n        _actionPaused[market][uint256(action)] = paused;\n        emit ActionPausedMarket(VToken(market), action, paused);\n    }\n\n    /**\n     * @notice Sets a new VAI controller\n     * @dev Admin function to set a new VAI controller\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIController(\n        VAIControllerInterface vaiController_\n    ) external compareAddress(address(vaiController), address(vaiController_)) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(vaiController_));\n\n        VAIControllerInterface oldVaiController = vaiController;\n        vaiController = vaiController_;\n        emit NewVAIController(oldVaiController, vaiController_);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the VAI mint rate\n     * @param newVAIMintRate The new VAI mint rate to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIMintRate(\n        uint256 newVAIMintRate\n    ) external compareValue(vaiMintRate, newVAIMintRate) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        uint256 oldVAIMintRate = vaiMintRate;\n        vaiMintRate = newVAIMintRate;\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the minted VAI amount of the `owner`\n     * @param owner The address of the account to set\n     * @param amount The amount of VAI to set to the account\n     * @return The number of minted VAI by `owner`\n     */\n    function setMintedVAIOf(address owner, uint256 amount) external returns (uint256) {\n        checkProtocolPauseState();\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n        // Check caller is vaiController\n        if (msg.sender != address(vaiController)) {\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\n        }\n        mintedVAIs[owner] = amount;\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the treasury data.\n     * @param newTreasuryGuardian The new address of the treasury guardian to be set\n     * @param newTreasuryAddress The new address of the treasury to be set\n     * @param newTreasuryPercent The new treasury percent to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256) {\n        // Check caller is admin\n        ensureAdminOr(treasuryGuardian);\n\n        require(newTreasuryPercent < 1e18, \"percent >= 100%\");\n        ensureNonzeroAddress(newTreasuryGuardian);\n        ensureNonzeroAddress(newTreasuryAddress);\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint256 oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Venus Distribution ***/\n\n    /**\n     * @dev Set ComptrollerLens contract address\n     * @param comptrollerLens_ The new ComptrollerLens contract address to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptrollerLens(\n        ComptrollerLensInterface comptrollerLens_\n    ) external virtual compareAddress(address(comptrollerLens), address(comptrollerLens_)) returns (uint256) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block to VAI Vault\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\n     */\n    function _setVenusVAIVaultRate(\n        uint256 venusVAIVaultRate_\n    ) external compareValue(venusVAIVaultRate, venusVAIVaultRate_) {\n        ensureAdmin();\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n        uint256 oldVenusVAIVaultRate = venusVAIVaultRate;\n        venusVAIVaultRate = venusVAIVaultRate_;\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n    }\n\n    /**\n     * @notice Set the VAI Vault infos\n     * @param vault_ The address of the VAI Vault\n     * @param releaseStartBlock_ The start block of release to VAI Vault\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\n     */\n    function _setVAIVaultInfo(\n        address vault_,\n        uint256 releaseStartBlock_,\n        uint256 minReleaseAmount_\n    ) external compareAddress(vaiVaultAddress, vault_) {\n        ensureAdmin();\n        ensureNonzeroAddress(vault_);\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n\n        vaiVaultAddress = vault_;\n        releaseStartBlock = releaseStartBlock_;\n        minReleaseAmount = minReleaseAmount_;\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n    }\n\n    /**\n     * @notice Alias to _setPrimeToken to support the Isolated Lending Comptroller Interface\n     * @param _prime The new prime token contract to be set\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function setPrimeToken(IPrime _prime) external returns (uint256) {\n        return __setPrimeToken(_prime);\n    }\n\n    /**\n     * @notice Sets the prime token contract for the comptroller\n     * @param _prime The new prime token contract to be set\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPrimeToken(IPrime _prime) external returns (uint256) {\n        return __setPrimeToken(_prime);\n    }\n\n    /**\n     * @notice Alias to _setForcedLiquidation to support the Isolated Lending Comptroller Interface\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external {\n        __setForcedLiquidation(vTokenBorrowed, enable);\n    }\n\n    /** @notice Enables forced liquidations for a market. If forced liquidation is enabled,\n     * borrows in the market may be liquidated regardless of the account liquidity\n     * @dev Allows a privileged role to set enable/disable forced liquidations\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function _setForcedLiquidation(address vTokenBorrowed, bool enable) external {\n        __setForcedLiquidation(vTokenBorrowed, enable);\n    }\n\n    /**\n     * @notice Enables forced liquidations for user's borrows in a certain market. If forced\n     * liquidation is enabled, user's borrows in the market may be liquidated regardless of\n     * the account liquidity. Forced liquidation may be enabled for a user even if it is not\n     * enabled for the entire market.\n     * @param borrower The address of the borrower\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function _setForcedLiquidationForUser(address borrower, address vTokenBorrowed, bool enable) external {\n        ensureAllowed(\"_setForcedLiquidationForUser(address,address,bool)\");\n        if (vTokenBorrowed != address(vaiController)) {\n            ensureListed(getCorePoolMarket(vTokenBorrowed));\n        }\n        isForcedLiquidationEnabledForUser[borrower][vTokenBorrowed] = enable;\n        emit IsForcedLiquidationEnabledForUserUpdated(borrower, vTokenBorrowed, enable);\n    }\n\n    /**\n     * @notice Set the address of the XVS token\n     * @param xvs_ The address of the XVS token\n     */\n    function _setXVSToken(address xvs_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(xvs_);\n\n        emit NewXVSToken(xvs, xvs_);\n        xvs = xvs_;\n    }\n\n    /**\n     * @notice Set the address of the XVS vToken\n     * @param xvsVToken_ The address of the XVS vToken\n     */\n    function _setXVSVToken(address xvsVToken_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(xvsVToken_);\n\n        address underlying = VToken(xvsVToken_).underlying();\n        require(underlying == xvs, \"invalid xvs vtoken address\");\n\n        emit NewXVSVToken(xvsVToken, xvsVToken_);\n        xvsVToken = xvsVToken_;\n    }\n\n    /**\n     * @notice Adds/Removes an account to the flash loan whitelist\n     * @param account The account to authorize for flash loans\n     * @param _isWhiteListed True to whitelist the account for flash loans, false to remove from whitelist\n     */\n    function setWhiteListFlashLoanAccount(address account, bool _isWhiteListed) external {\n        ensureAllowed(\"setWhiteListFlashLoanAccount(address,bool)\");\n        ensureNonzeroAddress(account);\n\n        authorizedFlashLoan[account] = _isWhiteListed;\n        emit IsAccountFlashLoanWhitelisted(account, _isWhiteListed);\n    }\n\n    /**\n     * @notice Updates the label for a specific pool (excluding the Core Pool)\n     * @param poolId ID of the pool to update\n     * @param newLabel The new label for the pool\n     * @custom:error InvalidOperationForCorePool Reverts when attempting to call pool-specific methods on the Core Pool\n     * @custom:error PoolDoesNotExist Reverts if the target pool ID does not exist\n     * @custom:error EmptyPoolLabel Reverts if the provided label is an empty string\n     * @custom:event PoolLabelUpdated Emitted after the pool label is updated\n     */\n    function setPoolLabel(uint96 poolId, string calldata newLabel) external {\n        ensureAllowed(\"setPoolLabel(uint96,string)\");\n\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n        if (poolId == corePoolId) revert InvalidOperationForCorePool();\n        if (bytes(newLabel).length == 0) revert EmptyPoolLabel();\n\n        PoolData storage pool = pools[poolId];\n\n        if (keccak256(bytes(pool.label)) == keccak256(bytes(newLabel))) {\n            return;\n        }\n\n        emit PoolLabelUpdated(poolId, pool.label, newLabel);\n        pool.label = newLabel;\n    }\n\n    /**\n     * @notice updates active status for a specific pool (excluding the Core Pool)\n     * @param poolId id of the pool to update\n     * @param active true to enable, false to disable\n     * @custom:error InvalidOperationForCorePool Reverts when attempting to call pool-specific methods on the Core Pool.\n     * @custom:error PoolDoesNotExist Reverts if the target pool ID does not exist.\n     * @custom:event PoolActiveStatusUpdated Emitted after the pool active status is updated.\n     */\n    function setPoolActive(uint96 poolId, bool active) external {\n        ensureAllowed(\"setPoolActive(uint96,bool)\");\n\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n        if (poolId == corePoolId) revert InvalidOperationForCorePool();\n\n        PoolData storage pool = pools[poolId];\n\n        if (pool.isActive == active) {\n            return;\n        }\n\n        emit PoolActiveStatusUpdated(poolId, pool.isActive, active);\n        pool.isActive = active;\n    }\n\n    /**\n     * @notice Updates the `allowCorePoolFallback` flag for a specific pool (excluding the Core Pool).\n     * @param poolId ID of the pool to update.\n     * @param allowFallback True to allow fallback to Core Pool, false to disable.\n     * @custom:error InvalidOperationForCorePool Reverts when attempting to call pool-specific methods on the Core Pool.\n     * @custom:error PoolDoesNotExist Reverts if the target pool ID does not exist.\n     * @custom:event PoolFallbackStatusUpdated Emitted after the pool fallback flag is updated.\n     */\n    function setAllowCorePoolFallback(uint96 poolId, bool allowFallback) external {\n        ensureAllowed(\"setAllowCorePoolFallback(uint96,bool)\");\n\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n        if (poolId == corePoolId) revert InvalidOperationForCorePool();\n\n        PoolData storage pool = pools[poolId];\n\n        if (pool.allowCorePoolFallback == allowFallback) {\n            return;\n        }\n\n        emit PoolFallbackStatusUpdated(poolId, pool.allowCorePoolFallback, allowFallback);\n        pool.allowCorePoolFallback = allowFallback;\n    }\n\n    /**\n     * @notice Updates the `isBorrowAllowed` flag for a market in a pool.\n     * @param poolId The ID of the pool.\n     * @param vToken The address of the market (vToken).\n     * @param borrowAllowed The new borrow allowed status.\n     * @custom:error PoolDoesNotExist Reverts if the pool ID is invalid.\n     * @custom:error MarketConfigNotFound Reverts if the market is not listed in the pool.\n     * @custom:event BorrowAllowedUpdated Emitted after the borrow permission for a market is updated.\n     */\n    function setIsBorrowAllowed(uint96 poolId, address vToken, bool borrowAllowed) external {\n        ensureAllowed(\"setIsBorrowAllowed(uint96,address,bool)\");\n\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        PoolMarketId index = getPoolMarketIndex(poolId, vToken);\n        Market storage m = _poolMarkets[index];\n\n        if (!m.isListed) {\n            revert MarketConfigNotFound();\n        }\n\n        if (m.isBorrowAllowed == borrowAllowed) {\n            return;\n        }\n\n        emit BorrowAllowedUpdated(poolId, vToken, m.isBorrowAllowed, borrowAllowed);\n        m.isBorrowAllowed = borrowAllowed;\n    }\n\n    /**\n     * @dev Updates the valid price oracle. Used by _setPriceOracle and setPriceOracle\n     * @param newOracle The new price oracle to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setPriceOracle(\n        ResilientOracleInterface newOracle\n    ) internal compareAddress(address(oracle), address(newOracle)) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        ResilientOracleInterface oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the close factor. Used by _setCloseFactor and setCloseFactor\n     * @param newCloseFactorMantissa The new close factor to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setCloseFactor(\n        uint256 newCloseFactorMantissa\n    ) internal compareValue(closeFactorMantissa, newCloseFactorMantissa) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n\n        Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n\n        //-- Check close factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n        //-- Check close factor >= 0.05\n        Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n\n        if (lessThanExp(highLimit, newCloseFactorExp) || greaterThanExp(lowLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the collateral factor and the liquidation threshold. Used by setCollateralFactor\n     * @param poolId The ID of the pool.\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor to be set\n     * @param newLiquidationThresholdMantissa The new liquidation threshold to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setCollateralFactor(\n        uint96 poolId,\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) internal returns (uint256) {\n        ensureNonzeroAddress(address(vToken));\n\n        // Check if pool exists\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        // Verify market is listed in the pool\n        Market storage market = _poolMarkets[getPoolMarketIndex(poolId, address(vToken))];\n        ensureListed(market);\n\n        //-- Check collateral factor <= 1\n        if (newCollateralFactorMantissa > mantissaOne) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(vToken)) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Ensure that liquidation threshold <= 1\n        if (newLiquidationThresholdMantissa > mantissaOne) {\n            return fail(Error.INVALID_LIQUIDATION_THRESHOLD, FailureInfo.SET_LIQUIDATION_THRESHOLD_VALIDATION);\n        }\n\n        // Ensure that liquidation threshold >= CF\n        if (newLiquidationThresholdMantissa < newCollateralFactorMantissa) {\n            return\n                fail(\n                    Error.INVALID_LIQUIDATION_THRESHOLD,\n                    FailureInfo.COLLATERAL_FACTOR_GREATER_THAN_LIQUIDATION_THRESHOLD\n                );\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        if (newCollateralFactorMantissa != oldCollateralFactorMantissa) {\n            market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n            // Emit event with poolId, asset, old collateral factor, and new collateral factor\n            emit NewCollateralFactor(poolId, vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n        }\n\n        uint256 oldLiquidationThresholdMantissa = market.liquidationThresholdMantissa;\n        if (newLiquidationThresholdMantissa != oldLiquidationThresholdMantissa) {\n            market.liquidationThresholdMantissa = newLiquidationThresholdMantissa;\n\n            emit NewLiquidationThreshold(\n                poolId,\n                vToken,\n                oldLiquidationThresholdMantissa,\n                newLiquidationThresholdMantissa\n            );\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the liquidation incentive. Used by setLiquidationIncentive\n     * @param poolId The ID of the pool.\n     * @param vToken The market to set the Incentive for\n     * @param newLiquidationIncentiveMantissa The new liquidation incentive to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setLiquidationIncentive(\n        uint96 poolId,\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    )\n        internal\n        compareValue(\n            _poolMarkets[getPoolMarketIndex(poolId, vToken)].liquidationIncentiveMantissa,\n            newLiquidationIncentiveMantissa\n        )\n        returns (uint256)\n    {\n        // Check if pool exists\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        // Verify market is listed in the pool\n        Market storage market = _poolMarkets[getPoolMarketIndex(poolId, vToken)];\n        ensureListed(market);\n\n        require(newLiquidationIncentiveMantissa >= mantissaOne, \"incentive < 1e18\");\n\n        emit NewLiquidationIncentive(\n            poolId,\n            vToken,\n            market.liquidationIncentiveMantissa,\n            newLiquidationIncentiveMantissa\n        );\n\n        // Set liquidation incentive to new incentive\n        market.liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the borrow caps. Used by _setMarketBorrowCaps and setMarketBorrowCaps\n     * @param vTokens The markets to set the borrow caps on\n     * @param newBorrowCaps The new borrow caps to be set\n     */\n    function __setMarketBorrowCaps(VToken[] memory vTokens, uint256[] memory newBorrowCaps) internal {\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\n\n        uint256 numMarkets = vTokens.length;\n        uint256 numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint256 i; i < numMarkets; ++i) {\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Updates the supply caps. Used by _setMarketSupplyCaps and setMarketSupplyCaps\n     * @param vTokens The markets to set the supply caps on\n     * @param newSupplyCaps The new supply caps to be set\n     */\n    function __setMarketSupplyCaps(VToken[] memory vTokens, uint256[] memory newSupplyCaps) internal {\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\n\n        uint256 numMarkets = vTokens.length;\n        uint256 numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint256 i; i < numMarkets; ++i) {\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Updates the prime token. Used by _setPrimeToken and setPrimeToken\n     * @param _prime The new prime token to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setPrimeToken(IPrime _prime) internal returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(_prime));\n\n        IPrime oldPrime = prime;\n        prime = _prime;\n        emit NewPrimeToken(oldPrime, _prime);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the forced liquidation. Used by _setForcedLiquidation and setForcedLiquidation\n     * @param vTokenBorrowed The market to set the forced liquidation on\n     * @param enable Whether to enable forced liquidations\n     */\n    function __setForcedLiquidation(address vTokenBorrowed, bool enable) internal {\n        ensureAllowed(\"_setForcedLiquidation(address,bool)\");\n        if (vTokenBorrowed != address(vaiController)) {\n            ensureListed(getCorePoolMarket(vTokenBorrowed));\n        }\n        isForcedLiquidationEnabled[vTokenBorrowed] = enable;\n        emit IsForcedLiquidationEnabledUpdated(vTokenBorrowed, enable);\n    }\n\n    /**\n     * @dev Updates the actions paused. Used by _setActionsPaused and setActionsPaused\n     * @param markets_ The markets to set the actions paused on\n     * @param actions_ The actions to set the paused state on\n     * @param paused_ The new paused state to be set\n     */\n    function __setActionsPaused(address[] memory markets_, Action[] memory actions_, bool paused_) internal {\n        ensureAllowed(\"_setActionsPaused(address[],uint8[],bool)\");\n\n        uint256 numMarkets = markets_.length;\n        uint256 numActions = actions_.length;\n        for (uint256 marketIdx; marketIdx < numMarkets; ++marketIdx) {\n            for (uint256 actionIdx; actionIdx < numActions; ++actionIdx) {\n                setActionPausedInternal(markets_[marketIdx], actions_[actionIdx], paused_);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/XVSRewardsHelper.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\n\n/**\n * @title XVSRewardsHelper\n * @author Venus\n * @dev This contract contains internal functions used in RewardFacet and PolicyFacet\n * @notice This facet contract contains the shared functions used by the RewardFacet and PolicyFacet\n */\ncontract XVSRewardsHelper is FacetBase {\n    /// @notice Emitted when XVS is distributed to a borrower\n    event DistributedBorrowerVenus(\n        VToken indexed vToken,\n        address indexed borrower,\n        uint256 venusDelta,\n        uint256 venusBorrowIndex\n    );\n\n    /// @notice Emitted when XVS is distributed to a supplier\n    event DistributedSupplierVenus(\n        VToken indexed vToken,\n        address indexed supplier,\n        uint256 venusDelta,\n        uint256 venusSupplyIndex\n    );\n\n    /**\n     * @notice Accrue XVS to the market by updating the borrow index\n     * @param vToken The market whose borrow index to update\n     */\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n        uint256 borrowSpeed = venusBorrowSpeeds[vToken];\n        uint32 blockNumber = getBlockNumberAsUint32();\n        uint256 deltaBlocks = sub_(blockNumber, borrowState.block);\n        if (deltaBlocks != 0 && borrowSpeed != 0) {\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n            uint256 accruedVenus = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount != 0 ? fraction(accruedVenus, borrowAmount) : Double({ mantissa: 0 });\n            borrowState.index = safe224(add_(Double({ mantissa: borrowState.index }), ratio).mantissa, \"224\");\n            borrowState.block = blockNumber;\n        } else if (deltaBlocks != 0) {\n            borrowState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Accrue XVS to the market by updating the supply index\n     * @param vToken The market whose supply index to update\n     */\n    function updateVenusSupplyIndex(address vToken) internal {\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        uint256 supplySpeed = venusSupplySpeeds[vToken];\n        uint32 blockNumber = getBlockNumberAsUint32();\n\n        uint256 deltaBlocks = sub_(blockNumber, supplyState.block);\n        if (deltaBlocks != 0 && supplySpeed != 0) {\n            uint256 supplyTokens = VToken(vToken).totalSupply();\n            uint256 accruedVenus = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens != 0 ? fraction(accruedVenus, supplyTokens) : Double({ mantissa: 0 });\n            supplyState.index = safe224(add_(Double({ mantissa: supplyState.index }), ratio).mantissa, \"224\");\n            supplyState.block = blockNumber;\n        } else if (deltaBlocks != 0) {\n            supplyState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\n     * @param vToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute XVS to\n     */\n    function distributeSupplierVenus(address vToken, address supplier) internal {\n        if (address(vaiVaultAddress) != address(0)) {\n            releaseToVault();\n        }\n        uint256 supplyIndex = venusSupplyState[vToken].index;\n        uint256 supplierIndex = venusSupplierIndex[vToken][supplier];\n        // Update supplier's index to the current index since we are distributing accrued XVS\n        venusSupplierIndex[vToken][supplier] = supplyIndex;\n        if (supplierIndex == 0 && supplyIndex >= venusInitialIndex) {\n            // Covers the case where users supplied tokens before the market's supply state index was set.\n            // Rewards the user with XVS accrued from the start of when supplier rewards were first\n            // set for the market.\n            supplierIndex = venusInitialIndex;\n        }\n        // Calculate change in the cumulative sum of the XVS per vToken accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\n        // Multiply of supplierTokens and supplierDelta\n        uint256 supplierDelta = mul_(VToken(vToken).balanceOf(supplier), deltaIndex);\n        // Addition of supplierAccrued and supplierDelta\n        venusAccrued[supplier] = add_(venusAccrued[supplier], supplierDelta);\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex);\n    }\n\n    /**\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol\n     * @param vToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute XVS to\n     */\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\n        if (address(vaiVaultAddress) != address(0)) {\n            releaseToVault();\n        }\n        uint256 borrowIndex = venusBorrowState[vToken].index;\n        uint256 borrowerIndex = venusBorrowerIndex[vToken][borrower];\n        // Update borrowers's index to the current index since we are distributing accrued XVS\n        venusBorrowerIndex[vToken][borrower] = borrowIndex;\n        if (borrowerIndex == 0 && borrowIndex >= venusInitialIndex) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\n            // Rewards the user with XVS accrued from the start of when borrower rewards were first\n            // set for the market.\n            borrowerIndex = venusInitialIndex;\n        }\n        // Calculate change in the cumulative sum of the XVS per borrowed unit accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\n        uint256 borrowerDelta = mul_(div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex), deltaIndex);\n        venusAccrued[borrower] = add_(venusAccrued[borrower], borrowerDelta);\n        emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex);\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    function diamondCut(FacetCut[] calldata _diamondCut) external;\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IFacetBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { Action } from \"../../../Comptroller/ComptrollerInterface.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\n\nenum WeightFunction {\n    /// @notice Use the collateral factor of the asset for weighting\n    USE_COLLATERAL_FACTOR,\n    /// @notice Use the liquidation threshold of the asset for weighting\n    USE_LIQUIDATION_THRESHOLD\n}\n\ninterface IFacetBase {\n    /**\n     * @notice The initial XVS rewards index for a market\n     */\n    function venusInitialIndex() external pure returns (uint224);\n\n    /**\n     * @notice Checks if a certain action is paused on a market\n     * @param action Action id\n     * @param market vToken address\n     */\n    function actionPaused(address market, Action action) external view returns (bool);\n\n    /**\n     * @notice Returns the XVS address\n     * @return The address of XVS token\n     */\n    function getXVSAddress() external view returns (address);\n\n    function getPoolMarketIndex(uint96 poolId, address vToken) external pure returns (PoolMarketId);\n\n    function corePoolId() external pure returns (uint96);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IFlashLoanFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\n\ninterface IFlashLoanFacet {\n    function executeFlashLoan(\n        address payable onBehalf,\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        bytes memory param\n    ) external;\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IMarketFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { WeightFunction } from \"./IFacetBase.sol\";\n\ninterface IMarketFacet {\n    function isComptroller() external pure returns (bool);\n\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function checkMembership(address account, VToken vToken) external view returns (bool);\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory);\n\n    function exitMarket(address vToken) external returns (uint256);\n\n    function _supportMarket(VToken vToken) external returns (uint256);\n\n    function supportMarket(VToken vToken) external returns (uint256);\n\n    function isMarketListed(VToken vToken) external view returns (bool);\n\n    function getAssetsIn(address account) external view returns (VToken[] memory);\n\n    function getAllMarkets() external view returns (VToken[] memory);\n\n    function updateDelegate(address delegate, bool allowBorrows) external;\n\n    function unlistMarket(address market) external returns (uint256);\n\n    function createPool(string memory label) external returns (uint96);\n\n    function enterPool(uint96 poolId) external;\n\n    function addPoolMarkets(uint96[] calldata poolIds, address[] calldata vTokens) external;\n\n    function removePoolMarket(uint96 poolId, address vToken) external;\n\n    function markets(\n        address vToken\n    )\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 liquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        );\n\n    function poolMarkets(\n        uint96 poolId,\n        address vToken\n    )\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 liquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        );\n\n    function hasValidPoolBorrows(address user, uint96 targetPoolId) external view returns (bool);\n\n    function getCollateralFactor(address vToken) external view returns (uint256);\n\n    function getLiquidationThreshold(address vToken) external view returns (uint256);\n\n    function getLiquidationIncentive(address vToken) external view returns (uint256);\n\n    function getEffectiveLtvFactor(\n        address account,\n        address vToken,\n        WeightFunction weightingStrategy\n    ) external view returns (uint256);\n\n    function getEffectiveLiquidationIncentive(address account, address vToken) external view returns (uint256);\n\n    function getPoolVTokens(uint96 poolId) external view returns (address[] memory);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IPolicyFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\n\ninterface IPolicyFacet {\n    function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256);\n\n    function mintVerify(address vToken, address minter, uint256 mintAmount, uint256 mintTokens) external;\n\n    function redeemAllowed(address vToken, address redeemer, uint256 redeemTokens) external returns (uint256);\n\n    function redeemVerify(address vToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\n\n    function borrowAllowed(address vToken, address borrower, uint256 borrowAmount) external returns (uint256);\n\n    function borrowVerify(address vToken, address borrower, uint256 borrowAmount) external;\n\n    function repayBorrowAllowed(\n        address vToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external view returns (uint256);\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(address vToken, address src, address dst, uint256 transferTokens) external;\n\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256);\n\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external view returns (uint256, uint256, uint256);\n\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint256[] calldata supplySpeeds,\n        uint256[] calldata borrowSpeeds\n    ) external;\n\n    function getBorrowingPower(\n        address account\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IRewardFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IFacetBase } from \"./IFacetBase.sol\";\n\ninterface IRewardFacet is IFacetBase {\n    function claimVenus(address holder) external;\n\n    function claimVenus(address holder, VToken[] calldata vTokens) external;\n\n    function claimVenus(address[] calldata holders, VToken[] calldata vTokens, bool borrowers, bool suppliers) external;\n\n    function claimVenusAsCollateral(address holder) external;\n\n    function _grantXVS(address recipient, uint256 amount) external;\n\n    function getXVSVTokenAddress() external view returns (address);\n\n    function claimVenus(\n        address[] calldata holders,\n        VToken[] calldata vTokens,\n        bool borrowers,\n        bool suppliers,\n        bool collateral\n    ) external;\n    function seizeVenus(address[] calldata holders, address recipient) external returns (uint256);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/ISetterFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { VAIControllerInterface } from \"../../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { ComptrollerLensInterface } from \"../../../Comptroller/ComptrollerLensInterface.sol\";\nimport { IPrime } from \"../../../Tokens/Prime/IPrime.sol\";\n\ninterface ISetterFacet {\n    function setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256);\n\n    function _setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256);\n\n    function setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n    function _setAccessControl(address newAccessControlAddress) external returns (uint256);\n\n    function setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256);\n\n    function setCollateralFactor(\n        uint96 poolId,\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256);\n\n    function setLiquidationIncentive(\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    ) external returns (uint256);\n\n    function setLiquidationIncentive(\n        uint96 poolId,\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    ) external returns (uint256);\n\n    function _setLiquidatorContract(address newLiquidatorContract_) external;\n\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint256);\n\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external;\n\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external;\n\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external;\n\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external;\n\n    function _setProtocolPaused(bool state) external returns (bool);\n\n    function setActionsPaused(address[] calldata markets, Action[] calldata actions, bool paused) external;\n\n    function _setActionsPaused(address[] calldata markets, Action[] calldata actions, bool paused) external;\n\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint256);\n\n    function _setVAIMintRate(uint256 newVAIMintRate) external returns (uint256);\n\n    function setMintedVAIOf(address owner, uint256 amount) external returns (uint256);\n\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256);\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external returns (uint256);\n\n    function _setVenusVAIVaultRate(uint256 venusVAIVaultRate_) external;\n\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) external;\n\n    function _setForcedLiquidation(address vToken, bool enable) external;\n\n    function setPrimeToken(IPrime _prime) external returns (uint256);\n\n    function _setPrimeToken(IPrime _prime) external returns (uint);\n\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external;\n\n    function _setForcedLiquidationForUser(address borrower, address vTokenBorrowed, bool enable) external;\n\n    function _setXVSToken(address xvs_) external;\n\n    function _setXVSVToken(address xvsVToken_) external;\n\n    function setWhiteListFlashLoanAccount(address account, bool _isWhiteListed) external;\n\n    function setIsBorrowAllowed(uint96 poolId, address vToken, bool borrowAllowed) external;\n\n    function setPoolActive(uint96 poolId, bool active) external;\n\n    function setPoolLabel(uint96 poolId, string calldata newLabel) external;\n\n    function setAllowCorePoolFallback(uint96 poolId, bool allowFallback) external;\n}\n"
    },
    "contracts/Comptroller/legacy/ComptrollerInterfaceR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../../Tokens/VTokens/VToken.sol\";\nimport { VAIControllerInterface } from \"../../Tokens/VAI/VAIControllerInterface.sol\";\n\nenum Action {\n    MINT,\n    REDEEM,\n    BORROW,\n    REPAY,\n    SEIZE,\n    LIQUIDATE,\n    TRANSFER,\n    ENTER_MARKET,\n    EXIT_MARKET\n}\n\ninterface ComptrollerInterfaceR1 {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() external pure returns (bool);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory);\n\n    function exitMarket(address vToken) external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address vToken, address minter, uint mintAmount) external returns (uint);\n\n    function mintVerify(address vToken, address minter, uint mintAmount, uint mintTokens) external;\n\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external returns (uint);\n\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external returns (uint);\n\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external;\n\n    function repayBorrowAllowed(\n        address vToken,\n        address payer,\n        address borrower,\n        uint repayAmount\n    ) external returns (uint);\n\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint repayAmount,\n        uint borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount\n    ) external returns (uint);\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        uint seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external returns (uint);\n\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external;\n\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external returns (uint);\n\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function setMintedVAIOf(address owner, uint amount) external returns (uint);\n\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function getXVSAddress() external view returns (address);\n\n    function markets(address) external view returns (bool, uint);\n\n    function oracle() external view returns (ResilientOracleInterface);\n\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\n\n    function getAssetsIn(address) external view returns (VToken[] memory);\n\n    function claimVenus(address) external;\n\n    function venusAccrued(address) external view returns (uint);\n\n    function venusSupplySpeeds(address) external view returns (uint);\n\n    function venusBorrowSpeeds(address) external view returns (uint);\n\n    function getAllMarkets() external view returns (VToken[] memory);\n\n    function venusSupplierIndex(address, address) external view returns (uint);\n\n    function venusInitialIndex() external view returns (uint224);\n\n    function venusBorrowerIndex(address, address) external view returns (uint);\n\n    function venusBorrowState(address) external view returns (uint224, uint32);\n\n    function venusSupplyState(address) external view returns (uint224, uint32);\n\n    function approvedDelegates(address borrower, address delegate) external view returns (bool);\n\n    function vaiController() external view returns (VAIControllerInterface);\n\n    function liquidationIncentiveMantissa() external view returns (uint);\n\n    function protocolPaused() external view returns (bool);\n\n    function actionPaused(address market, Action action) external view returns (bool);\n\n    function mintedVAIs(address user) external view returns (uint);\n\n    function vaiMintRate() external view returns (uint);\n}\n\ninterface IVAIVault {\n    function updatePendingRewards() external;\n}\n\ninterface IComptroller {\n    function liquidationIncentiveMantissa() external view returns (uint);\n\n    /*** Treasury Data ***/\n    function treasuryAddress() external view returns (address);\n\n    function treasuryPercent() external view returns (uint);\n}\n"
    },
    "contracts/Comptroller/legacy/ComptrollerLensInterfaceR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../Tokens/VTokens/VToken.sol\";\n\ninterface ComptrollerLensInterfaceR1 {\n    function liquidateCalculateSeizeTokens(\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function liquidateVAICalculateSeizeTokens(\n        address comptroller,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function getHypotheticalAccountLiquidity(\n        address comptroller,\n        address account,\n        VToken vTokenModify,\n        uint redeemTokens,\n        uint borrowAmount\n    ) external view returns (uint, uint, uint);\n}\n"
    },
    "contracts/Comptroller/legacy/ComptrollerStorageR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../../Tokens/VTokens/VToken.sol\";\nimport { VAIControllerInterface } from \"../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { ComptrollerLensInterfaceR1 } from \"./ComptrollerLensInterfaceR1.sol\";\nimport { IPrime } from \"../../Tokens/Prime/IPrime.sol\";\n\ncontract UnitrollerAdminStorageR1 {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public comptrollerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1StorageR1 is UnitrollerAdminStorageR1 {\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    ResilientOracleInterface public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint256 public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => VToken[]) public accountAssets;\n\n    struct Market {\n        /// @notice Whether or not this market is listed\n        bool isListed;\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /// @notice Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n        /// @notice Whether or not this market receives XVS\n        bool isVenus;\n    }\n\n    /**\n     * @notice Official mapping of vTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    address public pauseGuardian;\n\n    /// @notice Whether minting is paused (deprecated, superseded by actionPaused)\n    bool private _mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool private _borrowGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal transferGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal seizeGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal borrowGuardianPaused;\n\n    struct VenusMarketState {\n        /// @notice The market's last updated venusBorrowIndex or venusSupplyIndex\n        uint224 index;\n        /// @notice The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice A list of all markets\n    VToken[] public allMarkets;\n\n    /// @notice The rate at which the flywheel distributes XVS, per block\n    uint256 internal venusRate;\n\n    /// @notice The portion of venusRate that each market currently receives\n    mapping(address => uint256) internal venusSpeeds;\n\n    /// @notice The Venus market supply state for each market\n    mapping(address => VenusMarketState) public venusSupplyState;\n\n    /// @notice The Venus market borrow state for each market\n    mapping(address => VenusMarketState) public venusBorrowState;\n\n    /// @notice The Venus supply index for each market for each supplier as of the last time they accrued XVS\n    mapping(address => mapping(address => uint256)) public venusSupplierIndex;\n\n    /// @notice The Venus borrow index for each market for each borrower as of the last time they accrued XVS\n    mapping(address => mapping(address => uint256)) public venusBorrowerIndex;\n\n    /// @notice The XVS accrued but not yet transferred to each user\n    mapping(address => uint256) public venusAccrued;\n\n    /// @notice The Address of VAIController\n    VAIControllerInterface public vaiController;\n\n    /// @notice The minted VAI amount to each user\n    mapping(address => uint256) public mintedVAIs;\n\n    /// @notice VAI Mint Rate as a percentage\n    uint256 public vaiMintRate;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    bool public mintVAIGuardianPaused;\n    bool public repayVAIGuardianPaused;\n\n    /**\n     * @notice Pause/Unpause whole protocol actions\n     */\n    bool public protocolPaused;\n\n    /// @notice The rate at which the flywheel distributes XVS to VAI Minters, per block (deprecated)\n    uint256 private venusVAIRate;\n}\n\ncontract ComptrollerV2StorageR1 is ComptrollerV1StorageR1 {\n    /// @notice The rate at which the flywheel distributes XVS to VAI Vault, per block\n    uint256 public venusVAIVaultRate;\n\n    // address of VAI Vault\n    address public vaiVaultAddress;\n\n    // start block of release to VAI Vault\n    uint256 public releaseStartBlock;\n\n    // minimum release amount to VAI Vault\n    uint256 public minReleaseAmount;\n}\n\ncontract ComptrollerV3StorageR1 is ComptrollerV2StorageR1 {\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address.\n    mapping(address => uint256) public borrowCaps;\n}\n\ncontract ComptrollerV4StorageR1 is ComptrollerV3StorageR1 {\n    /// @notice Treasury Guardian address\n    address public treasuryGuardian;\n\n    /// @notice Treasury address\n    address public treasuryAddress;\n\n    /// @notice Fee percent of accrued interest with decimal 18\n    uint256 public treasuryPercent;\n}\n\ncontract ComptrollerV5StorageR1 is ComptrollerV4StorageR1 {\n    /// @notice The portion of XVS that each contributor receives per block (deprecated)\n    mapping(address => uint256) private venusContributorSpeeds;\n\n    /// @notice Last block at which a contributor's XVS rewards have been allocated (deprecated)\n    mapping(address => uint256) private lastContributorBlock;\n}\n\ncontract ComptrollerV6StorageR1 is ComptrollerV5StorageR1 {\n    address public liquidatorContract;\n}\n\ncontract ComptrollerV7StorageR1 is ComptrollerV6StorageR1 {\n    ComptrollerLensInterfaceR1 public comptrollerLens;\n}\n\ncontract ComptrollerV8StorageR1 is ComptrollerV7StorageR1 {\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\n    mapping(address => uint256) public supplyCaps;\n}\n\ncontract ComptrollerV9StorageR1 is ComptrollerV8StorageR1 {\n    /// @notice AccessControlManager address\n    address internal accessControl;\n\n    /// @notice True if a certain action is paused on a certain market\n    mapping(address => mapping(uint256 => bool)) internal _actionPaused;\n}\n\ncontract ComptrollerV10StorageR1 is ComptrollerV9StorageR1 {\n    /// @notice The rate at which venus is distributed to the corresponding borrow market (per block)\n    mapping(address => uint256) public venusBorrowSpeeds;\n\n    /// @notice The rate at which venus is distributed to the corresponding supply market (per block)\n    mapping(address => uint256) public venusSupplySpeeds;\n}\n\ncontract ComptrollerV11StorageR1 is ComptrollerV10StorageR1 {\n    /// @notice Whether the delegate is allowed to borrow or redeem on behalf of the user\n    //mapping(address user => mapping (address delegate => bool approved)) public approvedDelegates;\n    mapping(address => mapping(address => bool)) public approvedDelegates;\n}\n\ncontract ComptrollerV12StorageR1 is ComptrollerV11StorageR1 {\n    /// @notice Whether forced liquidation is enabled for all users borrowing in a certain market\n    mapping(address => bool) public isForcedLiquidationEnabled;\n}\n\ncontract ComptrollerV13StorageR1 is ComptrollerV12StorageR1 {\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in _facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in _facetAddresses array\n    }\n\n    mapping(bytes4 => FacetAddressAndPosition) internal _selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) internal _facetFunctionSelectors;\n    // facet addresses\n    address[] internal _facetAddresses;\n}\n\ncontract ComptrollerV14StorageR1 is ComptrollerV13StorageR1 {\n    /// @notice Prime token address\n    IPrime public prime;\n}\n\ncontract ComptrollerV15StorageR1 is ComptrollerV14StorageR1 {\n    /// @notice Whether forced liquidation is enabled for the borrows of a user in a market\n    mapping(address user => mapping(address market => bool)) public isForcedLiquidationEnabledForUser;\n}\n\ncontract ComptrollerV16StorageR1 is ComptrollerV15StorageR1 {\n    /// @notice The XVS token contract address\n    address internal xvs;\n\n    /// @notice The XVS vToken contract address\n    address internal xvsVToken;\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/DiamondConsolidatedR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { MarketFacetR1 } from \"./facets/MarketFacetR1.sol\";\nimport { PolicyFacetR1 } from \"./facets/PolicyFacetR1.sol\";\nimport { RewardFacetR1 } from \"./facets/RewardFacetR1.sol\";\nimport { SetterFacetR1 } from \"./facets/SetterFacetR1.sol\";\nimport { DiamondR1 } from \"./DiamondR1.sol\";\n\n/**\n * @title DiamondConsolidated\n * @author Venus\n * @notice This contract contains the functions defined in the different facets of the Diamond, plus the getters to the public variables.\n * This contract cannot be deployed, due to its size. Its main purpose is to allow the easy generation of an ABI and the typechain to interact with the\n * Unitroller contract in a simple way\n */\ncontract DiamondConsolidatedR1 is DiamondR1, MarketFacetR1, PolicyFacetR1, RewardFacetR1, SetterFacetR1 {}\n"
    },
    "contracts/Comptroller/legacy/Diamond/DiamondR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IDiamondCutR1 } from \"./interfaces/IDiamondCutR1.sol\";\nimport { Unitroller } from \"../../Unitroller.sol\";\nimport { ComptrollerV16StorageR1 } from \"../ComptrollerStorageR1.sol\";\n\n/**\n * @title Diamond\n * @author Venus\n * @notice This contract contains functions related to facets\n */\ncontract DiamondR1 is IDiamondCutR1, ComptrollerV16StorageR1 {\n    /// @notice Emitted when functions are added, replaced or removed to facets\n    event DiamondCut(IDiamondCutR1.FacetCut[] _diamondCut);\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /**\n     * @notice Call _acceptImplementation to accept the diamond proxy as new implementaion\n     * @param unitroller Address of the unitroller\n     */\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    /**\n     * @notice To add function selectors to the facet's mapping\n     * @dev Allows the contract admin to add function selectors\n     * @param diamondCut_ IDiamondCutR1 contains facets address, action and function selectors\n     */\n    function diamondCut(IDiamondCutR1.FacetCut[] memory diamondCut_) public {\n        require(msg.sender == admin, \"only unitroller admin can\");\n        libDiamondCut(diamondCut_);\n    }\n\n    /**\n     * @notice Get all function selectors mapped to the facet address\n     * @param facet Address of the facet\n     * @return selectors Array of function selectors\n     */\n    function facetFunctionSelectors(address facet) external view returns (bytes4[] memory) {\n        return _facetFunctionSelectors[facet].functionSelectors;\n    }\n\n    /**\n     * @notice Get facet position in the _facetFunctionSelectors through facet address\n     * @param facet Address of the facet\n     * @return Position of the facet\n     */\n    function facetPosition(address facet) external view returns (uint256) {\n        return _facetFunctionSelectors[facet].facetAddressPosition;\n    }\n\n    /**\n     * @notice Get all facet addresses\n     * @return facetAddresses Array of facet addresses\n     */\n    function facetAddresses() external view returns (address[] memory) {\n        return _facetAddresses;\n    }\n\n    /**\n     * @notice Get facet address and position through function selector\n     * @param functionSelector function selector\n     * @return FacetAddressAndPosition facet address and position\n     */\n    function facetAddress(\n        bytes4 functionSelector\n    ) external view returns (ComptrollerV16StorageR1.FacetAddressAndPosition memory) {\n        return _selectorToFacetAndPosition[functionSelector];\n    }\n\n    /**\n     * @notice Get all facets address and their function selector\n     * @return facets_ Array of Facet\n     */\n    function facets() external view returns (Facet[] memory) {\n        uint256 facetsLength = _facetAddresses.length;\n        Facet[] memory facets_ = new Facet[](facetsLength);\n        for (uint256 i; i < facetsLength; ++i) {\n            address facet = _facetAddresses[i];\n            facets_[i].facetAddress = facet;\n            facets_[i].functionSelectors = _facetFunctionSelectors[facet].functionSelectors;\n        }\n        return facets_;\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping\n     * @param diamondCut_ IDiamondCutR1 contains facets address, action and function selectors\n     */\n    function libDiamondCut(IDiamondCutR1.FacetCut[] memory diamondCut_) internal {\n        uint256 diamondCutLength = diamondCut_.length;\n        for (uint256 facetIndex; facetIndex < diamondCutLength; ++facetIndex) {\n            IDiamondCutR1.FacetCutAction action = diamondCut_[facetIndex].action;\n            if (action == IDiamondCutR1.FacetCutAction.Add) {\n                addFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutR1.FacetCutAction.Replace) {\n                replaceFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutR1.FacetCutAction.Remove) {\n                removeFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(diamondCut_);\n    }\n\n    /**\n     * @notice Add function selectors to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to add in the mapping\n     */\n    function addFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        require(functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(_facetFunctionSelectors[facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(facetAddress);\n        }\n        uint256 functionSelectorsLength = functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(selector, selectorPosition, facetAddress);\n            ++selectorPosition;\n        }\n    }\n\n    /**\n     * @notice Replace facet's address mapping for function selectors i.e selectors already associate to any other existing facet\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to replace in the mapping\n     */\n    function replaceFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        require(functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(_facetFunctionSelectors[facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(facetAddress);\n        }\n        uint256 functionSelectorsLength = functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            addFunction(selector, selectorPosition, facetAddress);\n            ++selectorPosition;\n        }\n    }\n\n    /**\n     * @notice Remove function selectors to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to remove in the mapping\n     */\n    function removeFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        uint256 functionSelectorsLength = functionSelectors.length;\n        require(functionSelectorsLength != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and revert\n        require(facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    /**\n     * @notice Add new facet to the proxy\n     * @param facetAddress Address of the facet\n     */\n    function addFacet(address facetAddress) internal {\n        enforceHasContractCode(facetAddress, \"Diamond: New facet has no code\");\n        _facetFunctionSelectors[facetAddress].facetAddressPosition = _facetAddresses.length;\n        _facetAddresses.push(facetAddress);\n    }\n\n    /**\n     * @notice Add function selector to the facet's address mapping\n     * @param selector funciton selector need to be added\n     * @param selectorPosition funciton selector position\n     * @param facetAddress Address of the facet\n     */\n    function addFunction(bytes4 selector, uint96 selectorPosition, address facetAddress) internal {\n        _selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n        _facetFunctionSelectors[facetAddress].functionSelectors.push(selector);\n        _selectorToFacetAndPosition[selector].facetAddress = facetAddress;\n    }\n\n    /**\n     * @notice Remove function selector to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param selector function selectors need to remove in the mapping\n     */\n    function removeFunction(address facetAddress, bytes4 selector) internal {\n        require(facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = _selectorToFacetAndPosition[selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = _facetFunctionSelectors[facetAddress].functionSelectors.length - 1;\n        // if not the same then replace selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = _facetFunctionSelectors[facetAddress].functionSelectors[lastSelectorPosition];\n            _facetFunctionSelectors[facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            _selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        _facetFunctionSelectors[facetAddress].functionSelectors.pop();\n        delete _selectorToFacetAndPosition[selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = _facetAddresses.length - 1;\n            uint256 facetAddressPosition = _facetFunctionSelectors[facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = _facetAddresses[lastFacetAddressPosition];\n                _facetAddresses[facetAddressPosition] = lastFacetAddress;\n                _facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            _facetAddresses.pop();\n            delete _facetFunctionSelectors[facetAddress];\n        }\n    }\n\n    /**\n     * @dev Ensure that the given address has contract code deployed\n     * @param _contract The address to check for contract code\n     * @param _errorMessage The error message to display if the contract code is not deployed\n     */\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize != 0, _errorMessage);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external {\n        address facet = _selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute public function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/facets/FacetBaseR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\nimport { ComptrollerErrorReporter } from \"../../../../Utils/ErrorReporter.sol\";\nimport { ExponentialNoError } from \"../../../../Utils/ExponentialNoError.sol\";\nimport { IVAIVault, Action } from \"../../ComptrollerInterfaceR1.sol\";\nimport { ComptrollerV16StorageR1 } from \"../../ComptrollerStorageR1.sol\";\n\n/**\n * @title FacetBase\n * @author Venus\n * @notice This facet contract contains functions related to access and checks\n */\ncontract FacetBaseR1 is ComptrollerV16StorageR1, ExponentialNoError, ComptrollerErrorReporter {\n    using SafeERC20 for IERC20;\n\n    /// @notice The initial Venus index for a market\n    uint224 public constant venusInitialIndex = 1e36;\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(VToken indexed vToken, address indexed account);\n\n    /// @notice Emitted when XVS is distributed to VAI Vault\n    event DistributedVAIVaultVenus(uint256 amount);\n\n    /// @notice Reverts if the protocol is paused\n    function checkProtocolPauseState() internal view {\n        require(!protocolPaused, \"protocol is paused\");\n    }\n\n    /// @notice Reverts if a certain action is paused on a market\n    function checkActionPauseState(address market, Action action) internal view {\n        require(!actionPaused(market, action), \"action is paused\");\n    }\n\n    /// @notice Reverts if the caller is not admin\n    function ensureAdmin() internal view {\n        require(msg.sender == admin, \"only admin can\");\n    }\n\n    /// @notice Checks the passed address is nonzero\n    function ensureNonzeroAddress(address someone) internal pure {\n        require(someone != address(0), \"can't be zero address\");\n    }\n\n    /// @notice Reverts if the market is not listed\n    function ensureListed(Market storage market) internal view {\n        require(market.isListed, \"market not listed\");\n    }\n\n    /// @notice Reverts if the caller is neither admin nor the passed address\n    function ensureAdminOr(address privilegedAddress) internal view {\n        require(msg.sender == admin || msg.sender == privilegedAddress, \"access denied\");\n    }\n\n    /// @notice Checks the caller is allowed to call the specified fuction\n    function ensureAllowed(string memory functionSig) internal view {\n        require(IAccessControlManagerV8(accessControl).isAllowedToCall(msg.sender, functionSig), \"access denied\");\n    }\n\n    /**\n     * @notice Checks if a certain action is paused on a market\n     * @param action Action id\n     * @param market vToken address\n     */\n    function actionPaused(address market, Action action) public view returns (bool) {\n        return _actionPaused[market][uint256(action)];\n    }\n\n    /**\n     * @notice Get the latest block number\n     */\n    function getBlockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Get the latest block number with the safe32 check\n     */\n    function getBlockNumberAsUint32() internal view returns (uint32) {\n        return safe32(getBlockNumber(), \"block # > 32 bits\");\n    }\n\n    /**\n     * @notice Transfer XVS to VAI Vault\n     */\n    function releaseToVault() internal {\n        if (releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\n            return;\n        }\n\n        IERC20 xvs_ = IERC20(xvs);\n\n        uint256 xvsBalance = xvs_.balanceOf(address(this));\n        if (xvsBalance == 0) {\n            return;\n        }\n\n        uint256 actualAmount;\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\n        uint256 releaseAmount_ = mul_(venusVAIVaultRate, deltaBlocks);\n\n        if (xvsBalance >= releaseAmount_) {\n            actualAmount = releaseAmount_;\n        } else {\n            actualAmount = xvsBalance;\n        }\n\n        if (actualAmount < minReleaseAmount) {\n            return;\n        }\n\n        releaseStartBlock = getBlockNumber();\n\n        xvs_.safeTransfer(vaiVaultAddress, actualAmount);\n        emit DistributedVAIVaultVenus(actualAmount);\n\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        VToken vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) internal view returns (Error, uint256, uint256) {\n        (uint256 err, uint256 liquidity, uint256 shortfall) = comptrollerLens.getHypotheticalAccountLiquidity(\n            address(this),\n            account,\n            vTokenModify,\n            redeemTokens,\n            borrowAmount\n        );\n        return (Error(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param vToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\n        checkActionPauseState(address(vToken), Action.ENTER_MARKET);\n        Market storage marketToJoin = markets[address(vToken)];\n        ensureListed(marketToJoin);\n        if (marketToJoin.accountMembership[borrower]) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(vToken);\n\n        emit MarketEntered(vToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Checks for the user is allowed to redeem tokens\n     * @param vToken Address of the market\n     * @param redeemer Address of the user\n     * @param redeemTokens Amount of tokens to redeem\n     * @return Success indicator for redeem is allowed or not\n     */\n    function redeemAllowedInternal(\n        address vToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        ensureListed(markets[vToken]);\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[vToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            VToken(vToken),\n            redeemTokens,\n            0\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall != 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Returns the XVS address\n     * @return The address of XVS token\n     */\n    function getXVSAddress() external view returns (address) {\n        return xvs;\n    }\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/facets/MarketFacetR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterfaceR1.sol\";\nimport { IMarketFacetR1 } from \"../interfaces/IMarketFacetR1.sol\";\nimport { FacetBaseR1 } from \"./FacetBaseR1.sol\";\n\n/**\n * @title MarketFacet\n * @author Venus\n * @dev This facet contains all the methods related to the market's management in the pool\n * @notice This facet contract contains functions regarding markets\n */\ncontract MarketFacetR1 is IMarketFacetR1, FacetBaseR1 {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(VToken indexed vToken);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(VToken indexed vToken, address indexed account);\n\n    /// @notice Emitted when the borrowing or redeeming delegate rights are updated for an account\n    event DelegateUpdated(address indexed approver, address indexed delegate, bool approved);\n\n    /// @notice Emitted when an admin unlists a market\n    event MarketUnlisted(address indexed vToken);\n\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() public pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\n        uint256 len;\n        VToken[] memory _accountAssets = accountAssets[account];\n        uint256 _accountAssetsLength = _accountAssets.length;\n\n        VToken[] memory assetsIn = new VToken[](_accountAssetsLength);\n\n        for (uint256 i; i < _accountAssetsLength; ++i) {\n            Market storage market = markets[address(_accountAssets[i])];\n            if (market.isListed) {\n                assetsIn[len] = _accountAssets[i];\n                ++len;\n            }\n        }\n\n        assembly {\n            mstore(assetsIn, len)\n        }\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market\n     * @return The list of market addresses\n     */\n    function getAllMarkets() external view returns (VToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenBorrowed The address of the borrowed vToken\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateCalculateSeizeTokens(\n            address(this),\n            vTokenBorrowed,\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateVAICalculateSeizeTokens(\n            address(this),\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param vToken The vToken to check\n     * @return True if the account is in the asset, otherwise false\n     */\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\n        return markets[address(vToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Check if a market is marked as listed (active)\n     * @param vToken vToken Address for the market to check\n     * @return listed True if listed otherwise false\n     */\n    function isMarketListed(VToken vToken) external view returns (bool) {\n        return markets[address(vToken)].isListed;\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param vTokens The list of addresses of the vToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory) {\n        uint256 len = vTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i; i < len; ++i) {\n            results[i] = uint256(addToMarketInternal(VToken(vTokens[i]), msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Unlist a market by setting isListed to false\n     * @dev Checks if market actions are paused and borrowCap/supplyCap/CF are set to 0\n     * @param market The address of the market (vToken) to unlist\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function unlistMarket(address market) external returns (uint256) {\n        ensureAllowed(\"unlistMarket(address)\");\n\n        Market storage _market = markets[market];\n\n        if (!_market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNLIST_MARKET_NOT_LISTED);\n        }\n\n        require(actionPaused(market, Action.BORROW), \"borrow action is not paused\");\n        require(actionPaused(market, Action.MINT), \"mint action is not paused\");\n        require(actionPaused(market, Action.REDEEM), \"redeem action is not paused\");\n        require(actionPaused(market, Action.REPAY), \"repay action is not paused\");\n        require(actionPaused(market, Action.ENTER_MARKET), \"enter market action is not paused\");\n        require(actionPaused(market, Action.LIQUIDATE), \"liquidate action is not paused\");\n        require(actionPaused(market, Action.SEIZE), \"seize action is not paused\");\n        require(actionPaused(market, Action.TRANSFER), \"transfer action is not paused\");\n        require(actionPaused(market, Action.EXIT_MARKET), \"exit market action is not paused\");\n\n        require(borrowCaps[market] == 0, \"borrow cap is not 0\");\n        require(supplyCaps[market] == 0, \"supply cap is not 0\");\n\n        require(_market.collateralFactorMantissa == 0, \"collateral factor is not 0\");\n\n        _market.isListed = false;\n        emit MarketUnlisted(market);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow\n     * @param vTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address vTokenAddress) external returns (uint256) {\n        checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\n\n        VToken vToken = VToken(vTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(vToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set vToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete vToken from the account’s list of assets */\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\n        VToken[] storage userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 i;\n        for (; i < len; ++i) {\n            if (userAssetList[i] == vToken) {\n                userAssetList[i] = userAssetList[len - 1];\n                userAssetList.pop();\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(i < len);\n\n        emit MarketExited(vToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _supportMarket to support the Isolated Lending Comptroller Interface\n     * @param vToken The address of the market (token) to list\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function supportMarket(VToken vToken) external returns (uint256) {\n        return __supportMarket(vToken);\n    }\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed\n     * @dev Allows a privileged role to add and list markets to the Comptroller\n     * @param vToken The address of the market (token) to list\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(VToken vToken) external returns (uint256) {\n        return __supportMarket(vToken);\n    }\n\n    /**\n     * @notice Grants or revokes the borrowing or redeeming delegate rights to / from an account\n     *  If allowed, the delegate will be able to borrow funds on behalf of the sender\n     *  Upon a delegated borrow, the delegate will receive the funds, and the borrower\n     *  will see the debt on their account\n     *  Upon a delegated redeem, the delegate will receive the redeemed amount and the approver\n     *  will see a deduction in his vToken balance\n     * @param delegate The address to update the rights for\n     * @param approved Whether to grant (true) or revoke (false) the borrowing or redeeming rights\n     */\n    function updateDelegate(address delegate, bool approved) external {\n        ensureNonzeroAddress(delegate);\n        require(approvedDelegates[msg.sender][delegate] != approved, \"Delegation status unchanged\");\n\n        _updateDelegate(msg.sender, delegate, approved);\n    }\n\n    function _updateDelegate(address approver, address delegate, bool approved) internal {\n        approvedDelegates[approver][delegate] = approved;\n        emit DelegateUpdated(approver, delegate, approved);\n    }\n\n    function _addMarketInternal(VToken vToken) internal {\n        uint256 allMarketsLength = allMarkets.length;\n        for (uint256 i; i < allMarketsLength; ++i) {\n            require(allMarkets[i] != vToken, \"already added\");\n        }\n        allMarkets.push(vToken);\n    }\n\n    function _initializeMarket(address vToken) internal {\n        uint32 blockNumber = getBlockNumberAsUint32();\n\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n\n        /*\n         * Update market state indices\n         */\n        if (supplyState.index == 0) {\n            // Initialize supply state index with default value\n            supplyState.index = venusInitialIndex;\n        }\n\n        if (borrowState.index == 0) {\n            // Initialize borrow state index with default value\n            borrowState.index = venusInitialIndex;\n        }\n\n        /*\n         * Update market state block numbers\n         */\n        supplyState.block = borrowState.block = blockNumber;\n    }\n\n    function __supportMarket(VToken vToken) internal returns (uint256) {\n        ensureAllowed(\"_supportMarket(address)\");\n\n        if (markets[address(vToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n        // Note that isVenus is not in active use anymore\n        Market storage newMarket = markets[address(vToken)];\n        newMarket.isListed = true;\n        newMarket.isVenus = false;\n        newMarket.collateralFactorMantissa = 0;\n\n        _addMarketInternal(vToken);\n        _initializeMarket(address(vToken));\n\n        emit MarketListed(vToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/facets/PolicyFacetR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterfaceR1.sol\";\nimport { IPolicyFacetR1 } from \"../interfaces/IPolicyFacetR1.sol\";\n\nimport { XVSRewardsHelperR1 } from \"./XVSRewardsHelperR1.sol\";\n\n/**\n * @title PolicyFacet\n * @author Venus\n * @dev This facet contains all the hooks used while transferring the assets\n * @notice This facet contract contains all the external pre-hook functions related to vToken\n */\ncontract PolicyFacetR1 is IPolicyFacetR1, XVSRewardsHelperR1 {\n    /// @notice Emitted when a new borrow-side XVS speed is calculated for a market\n    event VenusBorrowSpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /// @notice Emitted when a new supply-side XVS speed is calculated for a market\n    event VenusSupplySpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param vToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.MINT);\n        ensureListed(markets[vToken]);\n\n        uint256 supplyCap = supplyCaps[vToken];\n        require(supplyCap != 0, \"market supply cap is 0\");\n\n        uint256 vTokenSupply = VToken(vToken).totalSupply();\n        Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\n        uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\n        require(nextTotalSupply <= supplyCap, \"market supply cap reached\");\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, minter);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    // solhint-disable-next-line no-unused-vars\n    function mintVerify(address vToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(minter, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param vToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address vToken, address redeemer, uint256 redeemTokens) external returns (uint256) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REDEEM);\n\n        uint256 allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, redeemer);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address vToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external {\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(redeemer, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param vToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address vToken, address borrower, uint256 borrowAmount) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.BORROW);\n        ensureListed(markets[vToken]);\n\n        uint256 borrowCap = borrowCaps[vToken];\n        require(borrowCap != 0, \"market borrow cap is 0\");\n\n        if (!markets[vToken].accountMembership[borrower]) {\n            // only vTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == vToken, \"sender must be vToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(VToken(vToken), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n        }\n\n        if (oracle.getUnderlyingPrice(vToken) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        uint256 nextTotalBorrows = add_(VToken(vToken).totalBorrows(), borrowAmount);\n        require(nextTotalBorrows <= borrowCap, \"market borrow cap reached\");\n\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            VToken(vToken),\n            0,\n            borrowAmount\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall != 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    // solhint-disable-next-line no-unused-vars\n    function borrowVerify(address vToken, address borrower, uint256 borrowAmount) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param vToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address vToken,\n        address payer, // solhint-disable-line no-unused-vars\n        address borrower,\n        uint256 repayAmount // solhint-disable-line no-unused-vars\n    ) external returns (uint256) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REPAY);\n        ensureListed(markets[vToken]);\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address vToken,\n        address payer, // solhint-disable-line no-unused-vars\n        address borrower,\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\n        uint256 borrowerIndex // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external view returns (uint256) {\n        checkProtocolPauseState();\n\n        // if we want to pause liquidating to vTokenCollateral, we should pause seizing\n        checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\n\n        if (liquidatorContract != address(0) && liquidator != liquidatorContract) {\n            return uint256(Error.UNAUTHORIZED);\n        }\n\n        ensureListed(markets[vTokenCollateral]);\n\n        uint256 borrowBalance;\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n            borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\n        } else {\n            borrowBalance = vaiController.getVAIRepayAmount(borrower);\n        }\n\n        if (isForcedLiquidationEnabled[vTokenBorrowed] || isForcedLiquidationEnabledForUser[borrower][vTokenBorrowed]) {\n            if (repayAmount > borrowBalance) {\n                return uint(Error.TOO_MUCH_REPAY);\n            }\n            return uint(Error.NO_ERROR);\n        }\n\n        /* The borrower must have shortfall in order to be liquidatable */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(address(0)), 0, 0);\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall == 0) {\n            return uint256(Error.INSUFFICIENT_SHORTFALL);\n        }\n\n        // The liquidator may not repay more than what is allowed by the closeFactor\n        //-- maxClose = multipy of closeFactorMantissa and borrowBalance\n        if (repayAmount > mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance)) {\n            return uint256(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     * @param seizeTokens The amount of collateral token that will be seized\n     */\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral, // solhint-disable-line no-unused-vars\n        address liquidator,\n        address borrower,\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vTokenBorrowed);\n            prime.accrueInterestAndUpdateScore(liquidator, vTokenBorrowed);\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vTokenCollateral, Action.SEIZE);\n\n        Market storage market = markets[vTokenCollateral];\n\n        // We've added VAIController as a borrowed token list check for seize\n        ensureListed(market);\n\n        if (!market.accountMembership[borrower]) {\n            return uint256(Error.MARKET_NOT_COLLATERAL);\n        }\n\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n        }\n\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vTokenCollateral);\n        distributeSupplierVenus(vTokenCollateral, borrower);\n        distributeSupplierVenus(vTokenCollateral, liquidator);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed, // solhint-disable-line no-unused-vars\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vTokenCollateral);\n            prime.accrueInterestAndUpdateScore(liquidator, vTokenCollateral);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param vToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.TRANSFER);\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(vToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, src);\n        distributeSupplierVenus(vToken, dst);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     */\n    // solhint-disable-next-line no-unused-vars\n    function transferVerify(address vToken, address src, address dst, uint256 transferTokens) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(src, vToken);\n            prime.accrueInterestAndUpdateScore(dst, vToken);\n        }\n    }\n\n    /**\n     * @notice Alias to getAccountLiquidity to support the Isolated Lending Comptroller Interface\n     * @param account The account get liquidity for\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getBorrowingPower(address account) external view returns (uint256, uint256, uint256) {\n        return _getAccountLiquidity(account);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @param account The account get liquidity for\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256) {\n        return _getAccountLiquidity(account);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external view returns (uint256, uint256, uint256) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(vTokenModify),\n            redeemTokens,\n            borrowAmount\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    // setter functionality\n    /**\n     * @notice Set XVS speed for a single market\n     * @dev Allows the contract admin to set XVS speed for a market\n     * @param vTokens The market whose XVS speed to update\n     * @param supplySpeeds New XVS speed for supply\n     * @param borrowSpeeds New XVS speed for borrow\n     */\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint256[] calldata supplySpeeds,\n        uint256[] calldata borrowSpeeds\n    ) external {\n        ensureAdmin();\n\n        uint256 numTokens = vTokens.length;\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"invalid input\");\n\n        for (uint256 i; i < numTokens; ++i) {\n            ensureNonzeroAddress(address(vTokens[i]));\n            setVenusSpeedInternal(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n        }\n    }\n\n    function _getAccountLiquidity(address account) internal view returns (uint256, uint256, uint256) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(address(0)),\n            0,\n            0\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    function setVenusSpeedInternal(VToken vToken, uint256 supplySpeed, uint256 borrowSpeed) internal {\n        ensureListed(markets[address(vToken)]);\n\n        if (venusSupplySpeeds[address(vToken)] != supplySpeed) {\n            // Supply speed updated so let's update supply state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n\n            updateVenusSupplyIndex(address(vToken));\n            // Update speed and emit event\n            venusSupplySpeeds[address(vToken)] = supplySpeed;\n            emit VenusSupplySpeedUpdated(vToken, supplySpeed);\n        }\n\n        if (venusBorrowSpeeds[address(vToken)] != borrowSpeed) {\n            // Borrow speed updated so let's update borrow state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n            // Update speed and emit event\n            venusBorrowSpeeds[address(vToken)] = borrowSpeed;\n            emit VenusBorrowSpeedUpdated(vToken, borrowSpeed);\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/facets/RewardFacetR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\nimport { IRewardFacetR1 } from \"../interfaces/IRewardFacetR1.sol\";\nimport { XVSRewardsHelperR1 } from \"./XVSRewardsHelperR1.sol\";\nimport { VBep20Interface } from \"../../../../Tokens/VTokens/VTokenInterfaces.sol\";\n\n/**\n * @title RewardFacet\n * @author Venus\n * @dev This facet contains all the methods related to the reward functionality\n * @notice This facet contract provides the external functions related to all claims and rewards of the protocol\n */\ncontract RewardFacetR1 is IRewardFacetR1, XVSRewardsHelperR1 {\n    /// @notice Emitted when Venus is granted by admin\n    event VenusGranted(address indexed recipient, uint256 amount);\n\n    /// @notice Emitted when XVS are seized for the holder\n    event VenusSeized(address indexed holder, uint256 amount);\n\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\n     * @param holder The address to claim XVS for\n     */\n    function claimVenus(address holder) public {\n        return claimVenus(holder, allMarkets);\n    }\n\n    /**\n     * @notice Claim all the xvs accrued by holder in the specified markets\n     * @param holder The address to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     */\n    function claimVenus(address holder, VToken[] memory vTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimVenus(holders, vTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all xvs accrued by the holders\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     */\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\n        claimVenus(holders, vTokens, borrowers, suppliers, false);\n    }\n\n    /**\n     * @notice Claim all the xvs accrued by holder in all markets, a shorthand for `claimVenus` with collateral set to `true`\n     * @param holder The address to claim XVS for\n     */\n    function claimVenusAsCollateral(address holder) external {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimVenus(holders, allMarkets, true, true, true);\n    }\n\n    /**\n     * @notice Transfer XVS to the user with user's shortfall considered\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all\n     * @param user The address of the user to transfer XVS to\n     * @param amount The amount of XVS to (possibly) transfer\n     * @param shortfall The shortfall of the user\n     * @param collateral Whether or not we will use user's venus reward as collateral to pay off the debt\n     * @return The amount of XVS which was NOT transferred to the user\n     */\n    function grantXVSInternal(\n        address user,\n        uint256 amount,\n        uint256 shortfall,\n        bool collateral\n    ) internal returns (uint256) {\n        // If the user is blacklisted, they can't get XVS rewards\n        require(\n            user != 0xEF044206Db68E40520BfA82D45419d498b4bc7Bf &&\n                user != 0x7589dD3355DAE848FDbF75044A3495351655cB1A &&\n                user != 0x33df7a7F6D44307E1e5F3B15975b47515e5524c0 &&\n                user != 0x24e77E5b74B30b026E9996e4bc3329c881e24968,\n            \"Blacklisted\"\n        );\n\n        IERC20 xvs_ = IERC20(xvs);\n\n        if (amount == 0 || amount > xvs_.balanceOf(address(this))) {\n            return amount;\n        }\n\n        if (shortfall == 0) {\n            xvs_.safeTransfer(user, amount);\n            return 0;\n        }\n        // If user's bankrupt and doesn't use pending xvs as collateral, don't grant\n        // anything, otherwise, we will transfer the pending xvs as collateral to\n        // vXVS token and mint vXVS for the user\n        //\n        // If mintBehalf failed, don't grant any xvs\n        require(collateral, \"bankrupt\");\n\n        address xvsVToken_ = xvsVToken;\n\n        xvs_.safeApprove(xvsVToken_, 0);\n        xvs_.safeApprove(xvsVToken_, amount);\n        require(VBep20Interface(xvsVToken_).mintBehalf(user, amount) == uint256(Error.NO_ERROR), \"mint behalf error\");\n\n        // set venusAccrued[user] to 0\n        return 0;\n    }\n\n    /*** Venus Distribution Admin ***/\n\n    /**\n     * @notice Transfer XVS to the recipient\n     * @dev Allows the contract admin to transfer XVS to any recipient based on the recipient's shortfall\n     *      Note: If there is not enough XVS, we do not perform the transfer all\n     * @param recipient The address of the recipient to transfer XVS to\n     * @param amount The amount of XVS to (possibly) transfer\n     */\n    function _grantXVS(address recipient, uint256 amount) external {\n        ensureAdmin();\n        uint256 amountLeft = grantXVSInternal(recipient, amount, 0, false);\n        require(amountLeft == 0, \"no xvs\");\n        emit VenusGranted(recipient, amount);\n    }\n\n    /**\n     * @dev Seize XVS tokens from the specified holders and transfer to recipient\n     * @notice Seize XVS rewards allocated to holders\n     * @param holders Addresses of the XVS holders\n     * @param recipient Address of the XVS token recipient\n     * @return The total amount of XVS tokens seized and transferred to recipient\n     */\n    function seizeVenus(address[] calldata holders, address recipient) external returns (uint256) {\n        ensureAllowed(\"seizeVenus(address[],address)\");\n\n        uint256 holdersLength = holders.length;\n        uint256 totalHoldings;\n\n        updateAndDistributeRewardsInternal(holders, allMarkets, true, true);\n        for (uint256 j; j < holdersLength; ++j) {\n            address holder = holders[j];\n            uint256 userHolding = venusAccrued[holder];\n\n            if (userHolding != 0) {\n                totalHoldings += userHolding;\n                delete venusAccrued[holder];\n            }\n\n            emit VenusSeized(holder, userHolding);\n        }\n\n        if (totalHoldings != 0) {\n            IERC20(xvs).safeTransfer(recipient, totalHoldings);\n            emit VenusGranted(recipient, totalHoldings);\n        }\n\n        return totalHoldings;\n    }\n\n    /**\n     * @notice Claim all xvs accrued by the holders\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     * @param collateral Whether or not to use XVS earned as collateral, only takes effect when the holder has a shortfall\n     */\n    function claimVenus(\n        address[] memory holders,\n        VToken[] memory vTokens,\n        bool borrowers,\n        bool suppliers,\n        bool collateral\n    ) public {\n        uint256 holdersLength = holders.length;\n\n        updateAndDistributeRewardsInternal(holders, vTokens, borrowers, suppliers);\n        for (uint256 j; j < holdersLength; ++j) {\n            address holder = holders[j];\n\n            // If there is a positive shortfall, the XVS reward is accrued,\n            // but won't be granted to this holder\n            (, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(holder, VToken(address(0)), 0, 0);\n\n            uint256 value = venusAccrued[holder];\n            delete venusAccrued[holder];\n\n            uint256 returnAmount = grantXVSInternal(holder, value, shortfall, collateral);\n\n            // returnAmount can only be positive if balance of xvsAddress is less than grant amount(venusAccrued[holder])\n            if (returnAmount != 0) {\n                venusAccrued[holder] = returnAmount;\n            }\n        }\n    }\n\n    /**\n     * @notice Update and distribute tokens\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     */\n    function updateAndDistributeRewardsInternal(\n        address[] memory holders,\n        VToken[] memory vTokens,\n        bool borrowers,\n        bool suppliers\n    ) internal {\n        uint256 j;\n        uint256 holdersLength = holders.length;\n        uint256 vTokensLength = vTokens.length;\n\n        for (uint256 i; i < vTokensLength; ++i) {\n            VToken vToken = vTokens[i];\n            ensureListed(markets[address(vToken)]);\n            if (borrowers) {\n                Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\n                for (j = 0; j < holdersLength; ++j) {\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\n                }\n            }\n\n            if (suppliers) {\n                updateVenusSupplyIndex(address(vToken));\n                for (j = 0; j < holdersLength; ++j) {\n                    distributeSupplierVenus(address(vToken), holders[j]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the XVS vToken address\n     * @return The address of XVS vToken\n     */\n    function getXVSVTokenAddress() external view returns (address) {\n        return xvsVToken;\n    }\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/facets/SetterFacetR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterfaceR1.sol\";\nimport { ComptrollerLensInterfaceR1 } from \"../../ComptrollerLensInterfaceR1.sol\";\nimport { VAIControllerInterface } from \"../../../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { IPrime } from \"../../../../Tokens/Prime/IPrime.sol\";\nimport { ISetterFacetR1 } from \"../interfaces/ISetterFacetR1.sol\";\nimport { FacetBaseR1 } from \"./FacetBaseR1.sol\";\n\n/**\n * @title SetterFacet\n * @author Venus\n * @dev This facet contains all the setters for the states\n * @notice This facet contract contains all the configurational setter functions\n */\ncontract SetterFacetR1 is ISetterFacetR1, FacetBaseR1 {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(\n        VToken indexed vToken,\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(ResilientOracleInterface oldPriceOracle, ResilientOracleInterface newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint256 oldVAIMintRate, uint256 newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint256 oldTreasuryPercent, uint256 newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address indexed vault_, uint256 releaseStartBlock_, uint256 releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint256 oldVenusVAIVaultRate, uint256 newVenusVAIVaultRate);\n\n    /// @notice Emitted when prime token contract address is changed\n    event NewPrimeToken(IPrime oldPrimeToken, IPrime newPrimeToken);\n\n    /// @notice Emitted when forced liquidation is enabled or disabled for all users in a market\n    event IsForcedLiquidationEnabledUpdated(address indexed vToken, bool enable);\n\n    /// @notice Emitted when forced liquidation is enabled or disabled for a user borrowing in a market\n    event IsForcedLiquidationEnabledForUserUpdated(address indexed borrower, address indexed vToken, bool enable);\n\n    /// @notice Emitted when XVS token address is changed\n    event NewXVSToken(address indexed oldXVS, address indexed newXVS);\n\n    /// @notice Emitted when XVS vToken address is changed\n    event NewXVSVToken(address indexed oldXVSVToken, address indexed newXVSVToken);\n\n    /**\n     * @notice Compare two addresses to ensure they are different\n     * @param oldAddress The original address to compare\n     * @param newAddress The new address to compare\n     */\n    modifier compareAddress(address oldAddress, address newAddress) {\n        require(oldAddress != newAddress, \"old address is same as new address\");\n        _;\n    }\n\n    /**\n     * @notice Compare two values to ensure they are different\n     * @param oldValue The original value to compare\n     * @param newValue The new value to compare\n     */\n    modifier compareValue(uint256 oldValue, uint256 newValue) {\n        require(oldValue != newValue, \"old value is same as new value\");\n        _;\n    }\n\n    /**\n     * @notice Alias to _setPriceOracle to support the Isolated Lending Comptroller Interface\n     * @param newOracle The new price oracle to set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256) {\n        return __setPriceOracle(newOracle);\n    }\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Allows the contract admin to set a new price oracle used by the Comptroller\n     * @param newOracle The new price oracle to set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256) {\n        return __setPriceOracle(newOracle);\n    }\n\n    /**\n     * @notice Alias to _setCloseFactor to support the Isolated Lending Comptroller Interface\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint256 0=success, otherwise will revert\n     */\n    function setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        return __setCloseFactor(newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Allows the contract admin to set the closeFactor used to liquidate borrows\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint256 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        return __setCloseFactor(newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Allows the contract admin to set the address of access control of this contract\n     * @param newAccessControlAddress New address for the access control\n     * @return uint256 0=success, otherwise will revert\n     */\n    function _setAccessControl(\n        address newAccessControlAddress\n    ) external compareAddress(accessControl, newAccessControlAddress) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _setCollateralFactor to support the Isolated Lending Comptroller Interface\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256) {\n        require(\n            newCollateralFactorMantissa == newLiquidationThresholdMantissa,\n            \"collateral factor and liquidation threshold must be the same\"\n        );\n        return __setCollateralFactor(vToken, newCollateralFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Allows a privileged role to set the collateralFactorMantissa\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(VToken vToken, uint256 newCollateralFactorMantissa) external returns (uint256) {\n        return __setCollateralFactor(vToken, newCollateralFactorMantissa);\n    }\n\n    /**\n     * @notice Alias to _setLiquidationIncentive to support the Isolated Lending Comptroller Interface\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n        return __setLiquidationIncentive(newLiquidationIncentiveMantissa);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Allows a privileged role to set the liquidationIncentiveMantissa\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n        return __setLiquidationIncentive(newLiquidationIncentiveMantissa);\n    }\n\n    /**\n     * @notice Update the address of the liquidator contract\n     * @dev Allows the contract admin to update the address of liquidator contract\n     * @param newLiquidatorContract_ The new address of the liquidator contract\n     */\n    function _setLiquidatorContract(\n        address newLiquidatorContract_\n    ) external compareAddress(liquidatorContract, newLiquidatorContract_) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newLiquidatorContract_);\n        address oldLiquidatorContract = liquidatorContract;\n        liquidatorContract = newLiquidatorContract_;\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @dev Allows the contract admin to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(\n        address newPauseGuardian\n    ) external compareAddress(pauseGuardian, newPauseGuardian) returns (uint256) {\n        ensureAdmin();\n        ensureNonzeroAddress(newPauseGuardian);\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _setMarketBorrowCaps to support the Isolated Lending Comptroller Interface\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to Borrow not allowed\n     */\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\n        __setMarketBorrowCaps(vTokens, newBorrowCaps);\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given vToken market Borrowing that brings total borrows to or above borrow cap will revert\n     * @dev Allows a privileged role to set the borrowing cap for a vToken market. A borrow cap of 0 corresponds to Borrow not allowed\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to Borrow not allowed\n     */\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\n        __setMarketBorrowCaps(vTokens, newBorrowCaps);\n    }\n\n    /**\n     * @notice Alias to _setMarketSupplyCaps to support the Isolated Lending Comptroller Interface\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed\n     */\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        __setMarketSupplyCaps(vTokens, newSupplyCaps);\n    }\n\n    /**\n     * @notice Set the given supply caps for the given vToken market Supply that brings total Supply to or above supply cap will revert\n     * @dev Allows a privileged role to set the supply cap for a vToken. A supply cap of 0 corresponds to Minting NotAllowed\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed\n     */\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        __setMarketSupplyCaps(vTokens, newSupplyCaps);\n    }\n\n    /**\n     * @notice Set whole protocol pause/unpause state\n     * @dev Allows a privileged role to pause/unpause protocol\n     * @param state The new state (true=paused, false=unpaused)\n     * @return bool The updated state of the protocol\n     */\n    function _setProtocolPaused(bool state) external returns (bool) {\n        ensureAllowed(\"_setProtocolPaused(bool)\");\n\n        protocolPaused = state;\n        emit ActionProtocolPaused(state);\n        return state;\n    }\n\n    /**\n     * @notice Alias to _setActionsPaused to support the Isolated Lending Comptroller Interface\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        __setActionsPaused(markets_, actions_, paused_);\n    }\n\n    /**\n     * @notice Pause/unpause certain actions\n     * @dev Allows a privileged role to pause/unpause the protocol action state\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        __setActionsPaused(markets_, actions_, paused_);\n    }\n\n    /**\n     * @dev Pause/unpause an action on a market\n     * @param market Market to pause/unpause the action on\n     * @param action Action id to pause/unpause\n     * @param paused The new paused state (true=paused, false=unpaused)\n     */\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\n        ensureListed(markets[market]);\n        _actionPaused[market][uint256(action)] = paused;\n        emit ActionPausedMarket(VToken(market), action, paused);\n    }\n\n    /**\n     * @notice Sets a new VAI controller\n     * @dev Admin function to set a new VAI controller\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIController(\n        VAIControllerInterface vaiController_\n    ) external compareAddress(address(vaiController), address(vaiController_)) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(vaiController_));\n\n        VAIControllerInterface oldVaiController = vaiController;\n        vaiController = vaiController_;\n        emit NewVAIController(oldVaiController, vaiController_);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the VAI mint rate\n     * @param newVAIMintRate The new VAI mint rate to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIMintRate(\n        uint256 newVAIMintRate\n    ) external compareValue(vaiMintRate, newVAIMintRate) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        uint256 oldVAIMintRate = vaiMintRate;\n        vaiMintRate = newVAIMintRate;\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the minted VAI amount of the `owner`\n     * @param owner The address of the account to set\n     * @param amount The amount of VAI to set to the account\n     * @return The number of minted VAI by `owner`\n     */\n    function setMintedVAIOf(address owner, uint256 amount) external returns (uint256) {\n        checkProtocolPauseState();\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n        // Check caller is vaiController\n        if (msg.sender != address(vaiController)) {\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\n        }\n        mintedVAIs[owner] = amount;\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the treasury data.\n     * @param newTreasuryGuardian The new address of the treasury guardian to be set\n     * @param newTreasuryAddress The new address of the treasury to be set\n     * @param newTreasuryPercent The new treasury percent to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256) {\n        // Check caller is admin\n        ensureAdminOr(treasuryGuardian);\n\n        require(newTreasuryPercent < 1e18, \"percent >= 100%\");\n        ensureNonzeroAddress(newTreasuryGuardian);\n        ensureNonzeroAddress(newTreasuryAddress);\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint256 oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Venus Distribution ***/\n\n    /**\n     * @dev Set ComptrollerLens contract address\n     * @param comptrollerLens_ The new ComptrollerLens contract address to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptrollerLens(\n        ComptrollerLensInterfaceR1 comptrollerLens_\n    ) external virtual compareAddress(address(comptrollerLens), address(comptrollerLens_)) returns (uint256) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block to VAI Vault\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\n     */\n    function _setVenusVAIVaultRate(\n        uint256 venusVAIVaultRate_\n    ) external compareValue(venusVAIVaultRate, venusVAIVaultRate_) {\n        ensureAdmin();\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n        uint256 oldVenusVAIVaultRate = venusVAIVaultRate;\n        venusVAIVaultRate = venusVAIVaultRate_;\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n    }\n\n    /**\n     * @notice Set the VAI Vault infos\n     * @param vault_ The address of the VAI Vault\n     * @param releaseStartBlock_ The start block of release to VAI Vault\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\n     */\n    function _setVAIVaultInfo(\n        address vault_,\n        uint256 releaseStartBlock_,\n        uint256 minReleaseAmount_\n    ) external compareAddress(vaiVaultAddress, vault_) {\n        ensureAdmin();\n        ensureNonzeroAddress(vault_);\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n\n        vaiVaultAddress = vault_;\n        releaseStartBlock = releaseStartBlock_;\n        minReleaseAmount = minReleaseAmount_;\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n    }\n\n    /**\n     * @notice Alias to _setPrimeToken to support the Isolated Lending Comptroller Interface\n     * @param _prime The new prime token contract to be set\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function setPrimeToken(IPrime _prime) external returns (uint256) {\n        return __setPrimeToken(_prime);\n    }\n\n    /**\n     * @notice Sets the prime token contract for the comptroller\n     * @param _prime The new prime token contract to be set\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPrimeToken(IPrime _prime) external returns (uint256) {\n        return __setPrimeToken(_prime);\n    }\n\n    /**\n     * @notice Alias to _setForcedLiquidation to support the Isolated Lending Comptroller Interface\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external {\n        __setForcedLiquidation(vTokenBorrowed, enable);\n    }\n\n    /** @notice Enables forced liquidations for a market. If forced liquidation is enabled,\n     * borrows in the market may be liquidated regardless of the account liquidity\n     * @dev Allows a privileged role to set enable/disable forced liquidations\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function _setForcedLiquidation(address vTokenBorrowed, bool enable) external {\n        __setForcedLiquidation(vTokenBorrowed, enable);\n    }\n\n    /**\n     * @notice Enables forced liquidations for user's borrows in a certain market. If forced\n     * liquidation is enabled, user's borrows in the market may be liquidated regardless of\n     * the account liquidity. Forced liquidation may be enabled for a user even if it is not\n     * enabled for the entire market.\n     * @param borrower The address of the borrower\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function _setForcedLiquidationForUser(address borrower, address vTokenBorrowed, bool enable) external {\n        ensureAllowed(\"_setForcedLiquidationForUser(address,address,bool)\");\n        if (vTokenBorrowed != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n        }\n        isForcedLiquidationEnabledForUser[borrower][vTokenBorrowed] = enable;\n        emit IsForcedLiquidationEnabledForUserUpdated(borrower, vTokenBorrowed, enable);\n    }\n\n    /**\n     * @notice Set the address of the XVS token\n     * @param xvs_ The address of the XVS token\n     */\n    function _setXVSToken(address xvs_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(xvs_);\n\n        emit NewXVSToken(xvs, xvs_);\n        xvs = xvs_;\n    }\n\n    /**\n     * @notice Set the address of the XVS vToken\n     * @param xvsVToken_ The address of the XVS vToken\n     */\n    function _setXVSVToken(address xvsVToken_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(xvsVToken_);\n\n        address underlying = VToken(xvsVToken_).underlying();\n        require(underlying == xvs, \"invalid xvs vtoken address\");\n\n        emit NewXVSVToken(xvsVToken, xvsVToken_);\n        xvsVToken = xvsVToken_;\n    }\n\n    /**\n     * @dev Updates the valid price oracle. Used by _setPriceOracle and setPriceOracle\n     * @param newOracle The new price oracle to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setPriceOracle(\n        ResilientOracleInterface newOracle\n    ) internal compareAddress(address(oracle), address(newOracle)) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        ResilientOracleInterface oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the close factor. Used by _setCloseFactor and setCloseFactor\n     * @param newCloseFactorMantissa The new close factor to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setCloseFactor(\n        uint256 newCloseFactorMantissa\n    ) internal compareValue(closeFactorMantissa, newCloseFactorMantissa) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n\n        Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n\n        //-- Check close factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n        //-- Check close factor >= 0.05\n        Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n\n        if (lessThanExp(highLimit, newCloseFactorExp) || greaterThanExp(lowLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the collateral factor. Used by _setCollateralFactor and setCollateralFactor\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa\n    )\n        internal\n        compareValue(markets[address(vToken)].collateralFactorMantissa, newCollateralFactorMantissa)\n        returns (uint256)\n    {\n        // Check caller is allowed by access control manager\n        ensureAllowed(\"_setCollateralFactor(address,uint256)\");\n        ensureNonzeroAddress(address(vToken));\n\n        // Verify market is listed\n        Market storage market = markets[address(vToken)];\n        ensureListed(market);\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        //-- Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(vToken)) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the liquidation incentive. Used by _setLiquidationIncentive and setLiquidationIncentive\n     * @param newLiquidationIncentiveMantissa The new liquidation incentive to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setLiquidationIncentive(\n        uint256 newLiquidationIncentiveMantissa\n    ) internal compareValue(liquidationIncentiveMantissa, newLiquidationIncentiveMantissa) returns (uint256) {\n        ensureAllowed(\"_setLiquidationIncentive(uint256)\");\n\n        require(newLiquidationIncentiveMantissa >= 1e18, \"incentive < 1e18\");\n\n        // Save current value for use in log\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the borrow caps. Used by _setMarketBorrowCaps and setMarketBorrowCaps\n     * @param vTokens The markets to set the borrow caps on\n     * @param newBorrowCaps The new borrow caps to be set\n     */\n    function __setMarketBorrowCaps(VToken[] memory vTokens, uint256[] memory newBorrowCaps) internal {\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\n\n        uint256 numMarkets = vTokens.length;\n        uint256 numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint256 i; i < numMarkets; ++i) {\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Updates the supply caps. Used by _setMarketSupplyCaps and setMarketSupplyCaps\n     * @param vTokens The markets to set the supply caps on\n     * @param newSupplyCaps The new supply caps to be set\n     */\n    function __setMarketSupplyCaps(VToken[] memory vTokens, uint256[] memory newSupplyCaps) internal {\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\n\n        uint256 numMarkets = vTokens.length;\n        uint256 numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint256 i; i < numMarkets; ++i) {\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Updates the prime token. Used by _setPrimeToken and setPrimeToken\n     * @param _prime The new prime token to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setPrimeToken(IPrime _prime) internal returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(_prime));\n\n        IPrime oldPrime = prime;\n        prime = _prime;\n        emit NewPrimeToken(oldPrime, _prime);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the forced liquidation. Used by _setForcedLiquidation and setForcedLiquidation\n     * @param vTokenBorrowed The market to set the forced liquidation on\n     * @param enable Whether to enable forced liquidations\n     */\n    function __setForcedLiquidation(address vTokenBorrowed, bool enable) internal {\n        ensureAllowed(\"_setForcedLiquidation(address,bool)\");\n        if (vTokenBorrowed != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n        }\n        isForcedLiquidationEnabled[vTokenBorrowed] = enable;\n        emit IsForcedLiquidationEnabledUpdated(vTokenBorrowed, enable);\n    }\n\n    /**\n     * @dev Updates the actions paused. Used by _setActionsPaused and setActionsPaused\n     * @param markets_ The markets to set the actions paused on\n     * @param actions_ The actions to set the paused state on\n     * @param paused_ The new paused state to be set\n     */\n    function __setActionsPaused(address[] memory markets_, Action[] memory actions_, bool paused_) internal {\n        ensureAllowed(\"_setActionsPaused(address[],uint8[],bool)\");\n\n        uint256 numMarkets = markets_.length;\n        uint256 numActions = actions_.length;\n        for (uint256 marketIdx; marketIdx < numMarkets; ++marketIdx) {\n            for (uint256 actionIdx; actionIdx < numActions; ++actionIdx) {\n                setActionPausedInternal(markets_[marketIdx], actions_[actionIdx], paused_);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/facets/XVSRewardsHelperR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\nimport { FacetBaseR1 } from \"./FacetBaseR1.sol\";\n\n/**\n * @title XVSRewardsHelper\n * @author Venus\n * @dev This contract contains internal functions used in RewardFacet and PolicyFacet\n * @notice This facet contract contains the shared functions used by the RewardFacet and PolicyFacet\n */\ncontract XVSRewardsHelperR1 is FacetBaseR1 {\n    /// @notice Emitted when XVS is distributed to a borrower\n    event DistributedBorrowerVenus(\n        VToken indexed vToken,\n        address indexed borrower,\n        uint256 venusDelta,\n        uint256 venusBorrowIndex\n    );\n\n    /// @notice Emitted when XVS is distributed to a supplier\n    event DistributedSupplierVenus(\n        VToken indexed vToken,\n        address indexed supplier,\n        uint256 venusDelta,\n        uint256 venusSupplyIndex\n    );\n\n    /**\n     * @notice Accrue XVS to the market by updating the borrow index\n     * @param vToken The market whose borrow index to update\n     */\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n        uint256 borrowSpeed = venusBorrowSpeeds[vToken];\n        uint32 blockNumber = getBlockNumberAsUint32();\n        uint256 deltaBlocks = sub_(blockNumber, borrowState.block);\n        if (deltaBlocks != 0 && borrowSpeed != 0) {\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n            uint256 accruedVenus = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount != 0 ? fraction(accruedVenus, borrowAmount) : Double({ mantissa: 0 });\n            borrowState.index = safe224(add_(Double({ mantissa: borrowState.index }), ratio).mantissa, \"224\");\n            borrowState.block = blockNumber;\n        } else if (deltaBlocks != 0) {\n            borrowState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Accrue XVS to the market by updating the supply index\n     * @param vToken The market whose supply index to update\n     */\n    function updateVenusSupplyIndex(address vToken) internal {\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        uint256 supplySpeed = venusSupplySpeeds[vToken];\n        uint32 blockNumber = getBlockNumberAsUint32();\n\n        uint256 deltaBlocks = sub_(blockNumber, supplyState.block);\n        if (deltaBlocks != 0 && supplySpeed != 0) {\n            uint256 supplyTokens = VToken(vToken).totalSupply();\n            uint256 accruedVenus = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens != 0 ? fraction(accruedVenus, supplyTokens) : Double({ mantissa: 0 });\n            supplyState.index = safe224(add_(Double({ mantissa: supplyState.index }), ratio).mantissa, \"224\");\n            supplyState.block = blockNumber;\n        } else if (deltaBlocks != 0) {\n            supplyState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\n     * @param vToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute XVS to\n     */\n    function distributeSupplierVenus(address vToken, address supplier) internal {\n        if (address(vaiVaultAddress) != address(0)) {\n            releaseToVault();\n        }\n        uint256 supplyIndex = venusSupplyState[vToken].index;\n        uint256 supplierIndex = venusSupplierIndex[vToken][supplier];\n        // Update supplier's index to the current index since we are distributing accrued XVS\n        venusSupplierIndex[vToken][supplier] = supplyIndex;\n        if (supplierIndex == 0 && supplyIndex >= venusInitialIndex) {\n            // Covers the case where users supplied tokens before the market's supply state index was set.\n            // Rewards the user with XVS accrued from the start of when supplier rewards were first\n            // set for the market.\n            supplierIndex = venusInitialIndex;\n        }\n        // Calculate change in the cumulative sum of the XVS per vToken accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\n        // Multiply of supplierTokens and supplierDelta\n        uint256 supplierDelta = mul_(VToken(vToken).balanceOf(supplier), deltaIndex);\n        // Addition of supplierAccrued and supplierDelta\n        venusAccrued[supplier] = add_(venusAccrued[supplier], supplierDelta);\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex);\n    }\n\n    /**\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol\n     * @param vToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute XVS to\n     */\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\n        if (address(vaiVaultAddress) != address(0)) {\n            releaseToVault();\n        }\n        uint256 borrowIndex = venusBorrowState[vToken].index;\n        uint256 borrowerIndex = venusBorrowerIndex[vToken][borrower];\n        // Update borrowers's index to the current index since we are distributing accrued XVS\n        venusBorrowerIndex[vToken][borrower] = borrowIndex;\n        if (borrowerIndex == 0 && borrowIndex >= venusInitialIndex) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\n            // Rewards the user with XVS accrued from the start of when borrower rewards were first\n            // set for the market.\n            borrowerIndex = venusInitialIndex;\n        }\n        // Calculate change in the cumulative sum of the XVS per borrowed unit accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\n        uint256 borrowerDelta = mul_(div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex), deltaIndex);\n        venusAccrued[borrower] = add_(venusAccrued[borrower], borrowerDelta);\n        emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex);\n    }\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/interfaces/IDiamondCutR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IDiamondCutR1 {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    function diamondCut(FacetCut[] calldata _diamondCut) external;\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/interfaces/IMarketFacetR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\n\ninterface IMarketFacetR1 {\n    function isComptroller() external pure returns (bool);\n\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function checkMembership(address account, VToken vToken) external view returns (bool);\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory);\n\n    function exitMarket(address vToken) external returns (uint256);\n\n    function _supportMarket(VToken vToken) external returns (uint256);\n\n    function supportMarket(VToken vToken) external returns (uint256);\n\n    function isMarketListed(VToken vToken) external view returns (bool);\n\n    function getAssetsIn(address account) external view returns (VToken[] memory);\n\n    function getAllMarkets() external view returns (VToken[] memory);\n\n    function updateDelegate(address delegate, bool allowBorrows) external;\n\n    function unlistMarket(address market) external returns (uint256);\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/interfaces/IPolicyFacetR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\n\ninterface IPolicyFacetR1 {\n    function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256);\n\n    function mintVerify(address vToken, address minter, uint256 mintAmount, uint256 mintTokens) external;\n\n    function redeemAllowed(address vToken, address redeemer, uint256 redeemTokens) external returns (uint256);\n\n    function redeemVerify(address vToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\n\n    function borrowAllowed(address vToken, address borrower, uint256 borrowAmount) external returns (uint256);\n\n    function borrowVerify(address vToken, address borrower, uint256 borrowAmount) external;\n\n    function repayBorrowAllowed(\n        address vToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external view returns (uint256);\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(address vToken, address src, address dst, uint256 transferTokens) external;\n\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256);\n\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external view returns (uint256, uint256, uint256);\n\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint256[] calldata supplySpeeds,\n        uint256[] calldata borrowSpeeds\n    ) external;\n\n    function getBorrowingPower(\n        address account\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall);\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/interfaces/IRewardFacetR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\n\ninterface IRewardFacetR1 {\n    function claimVenus(address holder) external;\n\n    function claimVenus(address holder, VToken[] calldata vTokens) external;\n\n    function claimVenus(address[] calldata holders, VToken[] calldata vTokens, bool borrowers, bool suppliers) external;\n\n    function claimVenusAsCollateral(address holder) external;\n\n    function _grantXVS(address recipient, uint256 amount) external;\n\n    function getXVSVTokenAddress() external view returns (address);\n\n    function claimVenus(\n        address[] calldata holders,\n        VToken[] calldata vTokens,\n        bool borrowers,\n        bool suppliers,\n        bool collateral\n    ) external;\n    function seizeVenus(address[] calldata holders, address recipient) external returns (uint256);\n}\n"
    },
    "contracts/Comptroller/legacy/Diamond/interfaces/ISetterFacetR1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { VToken } from \"../../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterfaceR1.sol\";\nimport { VAIControllerInterface } from \"../../../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { ComptrollerLensInterfaceR1 } from \"../../ComptrollerLensInterfaceR1.sol\";\nimport { IPrime } from \"../../../../Tokens/Prime/IPrime.sol\";\n\ninterface ISetterFacetR1 {\n    function setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256);\n\n    function _setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256);\n\n    function setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n    function _setAccessControl(address newAccessControlAddress) external returns (uint256);\n\n    function setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256);\n\n    function _setCollateralFactor(VToken vToken, uint256 newCollateralFactorMantissa) external returns (uint256);\n\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\n\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\n\n    function _setLiquidatorContract(address newLiquidatorContract_) external;\n\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint256);\n\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external;\n\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external;\n\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external;\n\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external;\n\n    function _setProtocolPaused(bool state) external returns (bool);\n\n    function setActionsPaused(address[] calldata markets, Action[] calldata actions, bool paused) external;\n\n    function _setActionsPaused(address[] calldata markets, Action[] calldata actions, bool paused) external;\n\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint256);\n\n    function _setVAIMintRate(uint256 newVAIMintRate) external returns (uint256);\n\n    function setMintedVAIOf(address owner, uint256 amount) external returns (uint256);\n\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256);\n\n    function _setComptrollerLens(ComptrollerLensInterfaceR1 comptrollerLens_) external returns (uint256);\n\n    function _setVenusVAIVaultRate(uint256 venusVAIVaultRate_) external;\n\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) external;\n\n    function _setForcedLiquidation(address vToken, bool enable) external;\n\n    function setPrimeToken(IPrime _prime) external returns (uint256);\n\n    function _setPrimeToken(IPrime _prime) external returns (uint);\n\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external;\n\n    function _setForcedLiquidationForUser(address borrower, address vTokenBorrowed, bool enable) external;\n\n    function _setXVSToken(address xvs_) external;\n\n    function _setXVSVToken(address xvsVToken_) external;\n}\n"
    },
    "contracts/Comptroller/Types/PoolMarketId.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\n/// @notice Strongly-typed identifier for pool markets mapping keys\n/// @dev Underlying storage is bytes32: first 12 bytes (96 bits) = poolId, last 20 bytes = vToken address\ntype PoolMarketId is bytes32;\n\n "
    },
    "contracts/Comptroller/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { UnitrollerAdminStorage } from \"./ComptrollerStorage.sol\";\nimport { ComptrollerErrorReporter } from \"../Utils/ErrorReporter.sol\";\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * VTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n    /**\n     * @notice Emitted when pendingComptrollerImplementation is changed\n     */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n     * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n        }\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptImplementation() public returns (uint) {\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = comptrollerImplementation;\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller is pendingAdmin\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/external/IProtocolShareReserve.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IProtocolShareReserve {\n    enum IncomeType {\n        SPREAD,\n        LIQUIDATION,\n        ERC4626_WRAPPER_REWARDS,\n        FLASHLOAN\n    }\n\n    function updateAssetsState(address comptroller, address asset, IncomeType incomeType) external;\n}\n"
    },
    "contracts/FlashLoan/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../Tokens/VTokens/VToken.sol\";\n\n/// @title IFlashLoanReceiver\n/// @notice Interface for flashLoan receiver contract, which execute custom logic with flash-borrowed assets.\n/// @dev This interface defines the method that must be implemented by any contract wishing to interact with the flashLoan system.\n///      Contracts must ensure they have the means to repay both the flashLoan amount and the associated premium (fee).\ninterface IFlashLoanReceiver {\n    /**\n     * @notice Executes an operation after receiving the flash-borrowed assets.\n     * @dev Implementation of this function must ensure the borrowed amount plus the premium (fee) is repaid within the same transaction.\n     * @param assets The assets that were flash-borrowed.\n     * @param amounts The amounts of each of the flash-borrowed assets.\n     * @param premiums The premiums (fees) associated with each flash-borrowed asset.\n     * @param onBehalf The address of the user whose debt position will be used for the flashLoan.\n     * @param param Additional parameters encoded as bytes. These can be used to pass custom data to the receiver contract.\n     * @return True if the operation succeeds and the borrowed amount plus the premium is repaid, false otherwise.\n     * @return array of uint256 representing the amounts to be repaid for each asset.\n     */\n    function executeOperation(\n        VToken[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address onBehalf,\n        bytes calldata param\n    ) external returns (bool, uint256[] memory);\n}\n"
    },
    "contracts/FlashLoan/interfaces/IFlashLoanSimpleReceiver.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/// @title IFlashLoanSimpleReceiver\n/// @notice Interface for flashLoan receiver contract, which execute custom logic with flash-borrowed asset.\n/// @dev This interface defines the method that must be implemented by any contract wishing to interact with the flashLoan system.\n///      Contracts must ensure they have the means to repay both the flashLoan amount and the associated premium (fee).\ninterface IFlashLoanSimpleReceiver {\n    /**\n     * @notice Executes an operation after receiving the flash-borrowed asset\n     * @dev Ensure that the contract can return the debt + premium, e.g., has\n     *      enough funds to repay and has to transfer the debt + premium to the VToken\n     * @param asset The address of the flash-borrowed asset\n     * @param amount The amount of the flash-borrowed asset\n     * @param premium The premium (fee) associated with flash-borrowed asset\n     * @param onBehalf The address of the user whose debt position will be used for the flashLoan.\n     * @param param The byte-encoded param passed when initiating the flashLoan\n     * @return True if the execution of the operation succeeds, false otherwise\n     */\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address onBehalf,\n        bytes calldata param\n    ) external returns (bool);\n}\n"
    },
    "contracts/InterestRateModels/InterestRateModelV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Venus's InterestRateModelV8 Interface\n * @author Venus\n */\nabstract contract InterestRateModelV8 {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view virtual returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view virtual returns (uint256);\n}\n"
    },
    "contracts/Lens/ComptrollerLens.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { ExponentialNoError } from \"../Utils/ExponentialNoError.sol\";\nimport { ComptrollerErrorReporter } from \"../Utils/ErrorReporter.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { ComptrollerLensInterface } from \"../Comptroller/ComptrollerLensInterface.sol\";\nimport { VAIControllerInterface } from \"../Tokens/VAI/VAIControllerInterface.sol\";\nimport { WeightFunction } from \"../Comptroller/Diamond/interfaces/IFacetBase.sol\";\n\n/**\n * @title ComptrollerLens Contract\n * @author Venus\n * @notice The ComptrollerLens contract has functions to get the number of tokens that\n * can be seized through liquidation, hypothetical account liquidity and shortfall of an account.\n */\ncontract ComptrollerLens is ComptrollerLensInterface, ComptrollerErrorReporter, ExponentialNoError {\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint sumCollateral;\n        uint sumBorrowPlusEffects;\n        uint vTokenBalance;\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        Exp weightedFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Computes the number of collateral tokens to be seized in a liquidation event\n     * @dev This will be used only in vBNB\n     * @param comptroller Address of comptroller\n     * @param vTokenBorrowed Address of the borrowed vToken\n     * @param vTokenCollateral Address of collateral for the borrow\n     * @param actualRepayAmount Repayment amount i.e amount to be repaid of total borrowed amount\n     * @return A tuple of error code, and tokens to seize\n     */\n    function liquidateCalculateSeizeTokens(\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(vTokenBorrowed);\n        uint priceCollateralMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(vTokenCollateral);\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint liquidationIncentiveMantissa = ComptrollerInterface(comptroller).getLiquidationIncentive(vTokenCollateral);\n\n        uint seizeTokens = _calculateSeizeTokens(\n            actualRepayAmount,\n            liquidationIncentiveMantissa,\n            priceBorrowedMantissa,\n            priceCollateralMantissa,\n            exchangeRateMantissa\n        );\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /**\n     * @notice Computes the number of collateral tokens to be seized in a liquidation event\n     * @param borrower Address of borrower whose collateral is being seized\n     * @param comptroller Address of comptroller\n     * @param vTokenBorrowed Address of the borrowed vToken\n     * @param vTokenCollateral Address of collateral for the borrow\n     * @param actualRepayAmount Repayment amount i.e amount to be repaid of total borrowed amount\n     * @return A tuple of error code, and tokens to seize\n     */\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(vTokenBorrowed);\n        uint priceCollateralMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(vTokenCollateral);\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint liquidationIncentiveMantissa = ComptrollerInterface(comptroller).getEffectiveLiquidationIncentive(\n            borrower,\n            vTokenCollateral\n        );\n\n        uint seizeTokens = _calculateSeizeTokens(\n            actualRepayAmount,\n            liquidationIncentiveMantissa,\n            priceBorrowedMantissa,\n            priceCollateralMantissa,\n            exchangeRateMantissa\n        );\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /**\n     * @notice Computes the number of VAI tokens to be seized in a liquidation event\n     * @param comptroller Address of comptroller\n     * @param vTokenCollateral Address of collateral for vToken\n     * @param actualRepayAmount Repayment amount i.e amount to be repaid of the total borrowed amount\n     * @return A tuple of error code, and tokens to seize\n     */\n    function liquidateVAICalculateSeizeTokens(\n        address comptroller,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = 1e18; // Note: this is VAI\n        uint priceCollateralMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(vTokenCollateral);\n        if (priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint liquidationIncentiveMantissa = ComptrollerInterface(comptroller).getLiquidationIncentive(vTokenCollateral);\n        uint seizeTokens = _calculateSeizeTokens(\n            actualRepayAmount,\n            liquidationIncentiveMantissa,\n            priceBorrowedMantissa,\n            priceCollateralMantissa,\n            exchangeRateMantissa\n        );\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /**\n     * @notice Computes the hypothetical liquidity and shortfall of an account given a hypothetical borrow\n     *      A snapshot of the account is taken and the total borrow amount of the account is calculated\n     * @param comptroller Address of comptroller\n     * @param account Address of the borrowed vToken\n     * @param vTokenModify Address of collateral for vToken\n     * @param redeemTokens Number of vTokens being redeemed\n     * @param borrowAmount Amount borrowed\n     * @param weightingStrategy The weighting strategy to use:\n     *                          - `WeightFunction.USE_COLLATERAL_FACTOR` to use collateral factor\n     *                          - `WeightFunction.USE_LIQUIDATION_THRESHOLD` to use liquidation threshold\n     * @return Returns a tuple of error code, liquidity, and shortfall\n     */\n    function getHypotheticalAccountLiquidity(\n        address comptroller,\n        address account,\n        VToken vTokenModify,\n        uint redeemTokens,\n        uint borrowAmount,\n        WeightFunction weightingStrategy\n    ) external view returns (uint, uint, uint) {\n        (uint errorCode, AccountLiquidityLocalVars memory vars) = _calculateAccountPosition(\n            comptroller,\n            account,\n            vTokenModify,\n            redeemTokens,\n            borrowAmount,\n            weightingStrategy\n        );\n        if (errorCode != 0) {\n            return (errorCode, 0, 0);\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (uint(Error.NO_ERROR), vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (uint(Error.NO_ERROR), 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Internal function to calculate account position\n     * @param comptroller Address of comptroller\n     * @param account Address of the account whose liquidity is being calculated\n     * @param vTokenModify The vToken being modified (redeemed or borrowed)\n     * @param redeemTokens Number of vTokens being redeemed\n     * @param borrowAmount Amount borrowed\n     * @param weightingStrategy The weighting strategy to use:\n     *                          - `WeightFunction.USE_COLLATERAL_FACTOR` to use collateral factor\n     *                          - `WeightFunction.USE_LIQUIDATION_THRESHOLD` to use liquidation threshold\n     * @return oErr Returns an error code indicating success or failure\n     * @return vars Returns an AccountLiquidityLocalVars struct containing the calculated values\n     */\n    function _calculateAccountPosition(\n        address comptroller,\n        address account,\n        VToken vTokenModify,\n        uint redeemTokens,\n        uint borrowAmount,\n        WeightFunction weightingStrategy\n    ) internal view returns (uint oErr, AccountLiquidityLocalVars memory vars) {\n        // For each asset the account is in\n        VToken[] memory assets = ComptrollerInterface(comptroller).getAssetsIn(account);\n        uint assetsCount = assets.length;\n        for (uint i = 0; i < assetsCount; ++i) {\n            VToken asset = assets[i];\n\n            // Read the balances and exchange rate from the vToken\n            (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(\n                account\n            );\n            if (oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (uint(Error.SNAPSHOT_ERROR), vars);\n            }\n            vars.weightedFactor = Exp({\n                mantissa: ComptrollerInterface(comptroller).getEffectiveLtvFactor(\n                    account,\n                    address(asset),\n                    weightingStrategy\n                )\n            });\n            vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = ComptrollerInterface(comptroller).oracle().getUnderlyingPrice(address(asset));\n            if (vars.oraclePriceMantissa == 0) {\n                return (uint(Error.PRICE_ERROR), vars);\n            }\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n            // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.weightedFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * vTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n\n            // Calculate effects of interacting with vTokenModify\n            if (asset == vTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.tokensToDenom,\n                    redeemTokens,\n                    vars.sumBorrowPlusEffects\n                );\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.oraclePrice,\n                    borrowAmount,\n                    vars.sumBorrowPlusEffects\n                );\n            }\n        }\n\n        VAIControllerInterface vaiController = ComptrollerInterface(comptroller).vaiController();\n\n        if (address(vaiController) != address(0)) {\n            vars.sumBorrowPlusEffects = add_(vars.sumBorrowPlusEffects, vaiController.getVAIRepayAmount(account));\n        }\n        oErr = uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Calculate the number of tokens to seize during liquidation\n     * @param actualRepayAmount The amount of debt being repaid in the liquidation\n     * @param liquidationIncentiveMantissa The liquidation incentive, scaled by 1e18\n     * @param priceBorrowedMantissa The price of the borrowed asset, scaled by 1e18\n     * @param priceCollateralMantissa The price of the collateral asset, scaled by 1e18\n     * @param exchangeRateMantissa The exchange rate of the collateral asset, scaled by 1e18\n     * @return seizeTokens The number of tokens to seize during liquidation, scaled by 1e18\n     */\n    function _calculateSeizeTokens(\n        uint actualRepayAmount,\n        uint liquidationIncentiveMantissa,\n        uint priceBorrowedMantissa,\n        uint priceCollateralMantissa,\n        uint exchangeRateMantissa\n    ) internal pure returns (uint seizeTokens) {\n        Exp memory numerator = mul_(\n            Exp({ mantissa: liquidationIncentiveMantissa }),\n            Exp({ mantissa: priceBorrowedMantissa })\n        );\n        Exp memory denominator = mul_(\n            Exp({ mantissa: priceCollateralMantissa }),\n            Exp({ mantissa: exchangeRateMantissa })\n        );\n\n        seizeTokens = mul_ScalarTruncate(div_(numerator, denominator), actualRepayAmount);\n    }\n}\n"
    },
    "contracts/Lens/SnapshotLens.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { ExponentialNoError } from \"../Utils/ExponentialNoError.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { VBep20 } from \"../Tokens/VTokens/VBep20.sol\";\nimport { WeightFunction } from \"../Comptroller/Diamond/interfaces/IFacetBase.sol\";\n\ncontract SnapshotLens is ExponentialNoError {\n    struct AccountSnapshot {\n        address account;\n        string assetName;\n        address vTokenAddress;\n        address underlyingAssetAddress;\n        uint256 supply;\n        uint256 supplyInUsd;\n        uint256 collateral;\n        uint256 borrows;\n        uint256 borrowsInUsd;\n        uint256 assetPrice;\n        uint256 accruedInterest;\n        uint vTokenDecimals;\n        uint underlyingDecimals;\n        uint exchangeRate;\n        bool isACollateral;\n    }\n\n    /** Snapshot calculation **/\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account snapshot.\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountSnapshotLocalVars {\n        uint collateral;\n        uint vTokenBalance;\n        uint borrowBalance;\n        uint borrowsInUsd;\n        uint balanceOfUnderlying;\n        uint supplyInUsd;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n        bool isACollateral;\n    }\n\n    function getAccountSnapshot(\n        address payable account,\n        address comptrollerAddress\n    ) public returns (AccountSnapshot[] memory) {\n        // For each asset the account is in\n        VToken[] memory assets = ComptrollerInterface(comptrollerAddress).getAllMarkets();\n        AccountSnapshot[] memory accountSnapshots = new AccountSnapshot[](assets.length);\n        for (uint256 i = 0; i < assets.length; ++i) {\n            accountSnapshots[i] = getAccountSnapshot(account, comptrollerAddress, assets[i]);\n        }\n        return accountSnapshots;\n    }\n\n    function isACollateral(address account, address asset, address comptrollerAddress) public view returns (bool) {\n        VToken[] memory assetsAsCollateral = ComptrollerInterface(comptrollerAddress).getAssetsIn(account);\n        for (uint256 j = 0; j < assetsAsCollateral.length; ++j) {\n            if (address(assetsAsCollateral[j]) == asset) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function getAccountSnapshot(\n        address payable account,\n        address comptrollerAddress,\n        VToken vToken\n    ) public returns (AccountSnapshot memory) {\n        AccountSnapshotLocalVars memory vars; // Holds all our calculation results\n        uint oErr;\n\n        // Read the balances and exchange rate from the vToken\n        (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = vToken.getAccountSnapshot(account);\n        require(oErr == 0, \"Snapshot Error\");\n        vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n        uint collateralFactorMantissa = ComptrollerInterface(comptrollerAddress).getEffectiveLtvFactor(\n            account,\n            address(vToken),\n            WeightFunction.USE_COLLATERAL_FACTOR\n        );\n        vars.collateralFactor = Exp({ mantissa: collateralFactorMantissa });\n\n        // Get the normalized price of the asset\n        vars.oraclePriceMantissa = ComptrollerInterface(comptrollerAddress).oracle().getUnderlyingPrice(\n            address(vToken)\n        );\n        vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n        // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\n        vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n        //Collateral = tokensToDenom * vTokenBalance\n        vars.collateral = mul_ScalarTruncate(vars.tokensToDenom, vars.vTokenBalance);\n\n        vars.balanceOfUnderlying = vToken.balanceOfUnderlying(account);\n        vars.supplyInUsd = mul_ScalarTruncate(vars.oraclePrice, vars.balanceOfUnderlying);\n\n        vars.borrowsInUsd = mul_ScalarTruncate(vars.oraclePrice, vars.borrowBalance);\n\n        address underlyingAssetAddress;\n        uint underlyingDecimals;\n\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\n            underlyingAssetAddress = address(0);\n            underlyingDecimals = 18;\n        } else {\n            VBep20 vBep20 = VBep20(address(vToken));\n            underlyingAssetAddress = vBep20.underlying();\n            underlyingDecimals = IERC20Metadata(vBep20.underlying()).decimals();\n        }\n\n        vars.isACollateral = isACollateral(account, address(vToken), comptrollerAddress);\n\n        return\n            AccountSnapshot({\n                account: account,\n                assetName: vToken.name(),\n                vTokenAddress: address(vToken),\n                underlyingAssetAddress: underlyingAssetAddress,\n                supply: vars.balanceOfUnderlying,\n                supplyInUsd: vars.supplyInUsd,\n                collateral: vars.collateral,\n                borrows: vars.borrowBalance,\n                borrowsInUsd: vars.borrowsInUsd,\n                assetPrice: vars.oraclePriceMantissa,\n                accruedInterest: vToken.borrowIndex(),\n                vTokenDecimals: vToken.decimals(),\n                underlyingDecimals: underlyingDecimals,\n                exchangeRate: vToken.exchangeRateCurrent(),\n                isACollateral: vars.isACollateral\n            });\n    }\n\n    // utilities\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/Lens/VenusLens.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { ExponentialNoError } from \"../Utils/ExponentialNoError.sol\";\nimport { VBep20 } from \"../Tokens/VTokens/VBep20.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { ComptrollerInterface, Action } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { IXVS } from \"../Tokens/XVS/IXVS.sol\";\n\ncontract VenusLens is ExponentialNoError {\n    /// @notice Blocks Per Day\n    uint public constant BLOCKS_PER_DAY = 115200;\n\n    /// @notice Total actions available on VToken\n    uint public constant VTOKEN_ACTIONS = 8;\n\n    struct VenusMarketState {\n        uint224 index;\n        uint32 block;\n    }\n\n    struct VTokenMetadata {\n        address vToken;\n        uint exchangeRateCurrent;\n        uint supplyRatePerBlock;\n        uint borrowRatePerBlock;\n        uint reserveFactorMantissa;\n        uint totalBorrows;\n        uint totalReserves;\n        uint totalSupply;\n        uint totalCash;\n        bool isListed;\n        uint collateralFactorMantissa;\n        address underlyingAssetAddress;\n        uint vTokenDecimals;\n        uint underlyingDecimals;\n        uint venusSupplySpeed;\n        uint venusBorrowSpeed;\n        uint dailySupplyXvs;\n        uint dailyBorrowXvs;\n        uint pausedActions;\n        uint liquidationThresholdMantissa;\n        uint liquidationIncentiveMantissa;\n        bool isBorrowAllowed;\n        uint96 poolId;\n    }\n\n    struct VTokenBalances {\n        address vToken;\n        uint balanceOf;\n        uint borrowBalanceCurrent;\n        uint balanceOfUnderlying;\n        uint tokenBalance;\n        uint tokenAllowance;\n    }\n\n    struct VTokenUnderlyingPrice {\n        address vToken;\n        uint underlyingPrice;\n    }\n\n    struct AccountLimits {\n        VToken[] markets;\n        uint liquidity;\n        uint shortfall;\n    }\n\n    struct XVSBalanceMetadata {\n        uint balance;\n        uint votes;\n        address delegate;\n    }\n\n    struct XVSBalanceMetadataExt {\n        uint balance;\n        uint votes;\n        address delegate;\n        uint allocated;\n    }\n\n    struct VenusVotes {\n        uint blockNumber;\n        uint votes;\n    }\n\n    struct ClaimVenusLocalVariables {\n        uint totalRewards;\n        uint224 borrowIndex;\n        uint32 borrowBlock;\n        uint224 supplyIndex;\n        uint32 supplyBlock;\n    }\n\n    /**\n     * @dev Struct for Pending Rewards for per market\n     */\n    struct PendingReward {\n        address vTokenAddress;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Struct for Reward of a single reward token.\n     */\n    struct RewardSummary {\n        address distributorAddress;\n        address rewardTokenAddress;\n        uint256 totalRewards;\n        PendingReward[] pendingRewards;\n    }\n\n    /// @notice Holds full market information for a single vToken within a specific pool\n    struct MarketData {\n        uint96 poolId;\n        string poolLabel;\n        address vToken;\n        bool isListed;\n        uint256 collateralFactor;\n        bool isVenus;\n        uint256 liquidationThreshold;\n        uint256 liquidationIncentive;\n        bool isBorrowAllowed;\n    }\n\n    /// @notice Struct representing a pool and its associated markets\n    struct PoolWithMarkets {\n        uint96 poolId;\n        string label;\n        bool isActive;\n        bool allowCorePoolFallback;\n        MarketData[] markets;\n    }\n\n    /// @notice Struct representing comptroller markets mapping return type\n    struct MarketsInfo {\n        bool isListed;\n        uint collateralFactorMantissa;\n        bool isVenus;\n        uint liquidationThresholdMantissa;\n        uint liquidationIncentiveMantissa;\n        uint96 poolId;\n        bool isBorrowAllowed;\n    }\n\n    /// @notice Thrown when a given pool ID does not exist\n    error PoolDoesNotExist(uint96 poolId);\n\n    /// @notice Thrown when trying to call pool-specific methods on the Core Pool\n    error InvalidOperationForCorePool();\n\n    /**\n     * @notice Query the metadata of a vToken by its address\n     * @param vToken The address of the vToken to fetch VTokenMetadata\n     * @return VTokenMetadata struct with vToken supply and borrow information.\n     */\n    function vTokenMetadata(VToken vToken) public returns (VTokenMetadata memory) {\n        uint exchangeRateCurrent = vToken.exchangeRateCurrent();\n        address comptrollerAddress = address(vToken.comptroller());\n        ComptrollerInterface comptroller = ComptrollerInterface(comptrollerAddress);\n        MarketsInfo memory market;\n        (\n            market.isListed,\n            market.collateralFactorMantissa,\n            market.isVenus,\n            market.liquidationThresholdMantissa,\n            market.liquidationIncentiveMantissa,\n            market.poolId,\n            market.isBorrowAllowed\n        ) = comptroller.markets(address(vToken));\n        address underlyingAssetAddress;\n        uint underlyingDecimals;\n\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\n            underlyingAssetAddress = address(0);\n            underlyingDecimals = 18;\n        } else {\n            VBep20 vBep20 = VBep20(address(vToken));\n            underlyingAssetAddress = vBep20.underlying();\n            underlyingDecimals = IERC20Metadata(vBep20.underlying()).decimals();\n        }\n\n        uint venusSupplySpeedPerBlock = comptroller.venusSupplySpeeds(address(vToken));\n        uint venusBorrowSpeedPerBlock = comptroller.venusBorrowSpeeds(address(vToken));\n\n        uint256 pausedActions;\n\n        for (uint8 i; i <= VTOKEN_ACTIONS; ++i) {\n            uint256 paused = comptroller.actionPaused(address(vToken), Action(i)) ? 1 : 0;\n            pausedActions |= paused << i;\n        }\n\n        return\n            VTokenMetadata({\n                vToken: address(vToken),\n                exchangeRateCurrent: exchangeRateCurrent,\n                supplyRatePerBlock: vToken.supplyRatePerBlock(),\n                borrowRatePerBlock: vToken.borrowRatePerBlock(),\n                reserveFactorMantissa: vToken.reserveFactorMantissa(),\n                totalBorrows: vToken.totalBorrows(),\n                totalReserves: vToken.totalReserves(),\n                totalSupply: vToken.totalSupply(),\n                totalCash: vToken.getCash(),\n                isListed: market.isListed,\n                collateralFactorMantissa: market.collateralFactorMantissa,\n                underlyingAssetAddress: underlyingAssetAddress,\n                vTokenDecimals: vToken.decimals(),\n                underlyingDecimals: underlyingDecimals,\n                venusSupplySpeed: venusSupplySpeedPerBlock,\n                venusBorrowSpeed: venusBorrowSpeedPerBlock,\n                dailySupplyXvs: venusSupplySpeedPerBlock * BLOCKS_PER_DAY,\n                dailyBorrowXvs: venusBorrowSpeedPerBlock * BLOCKS_PER_DAY,\n                pausedActions: pausedActions,\n                liquidationThresholdMantissa: market.liquidationThresholdMantissa,\n                liquidationIncentiveMantissa: market.liquidationIncentiveMantissa,\n                isBorrowAllowed: market.isBorrowAllowed,\n                poolId: market.poolId\n            });\n    }\n\n    /**\n     * @notice Get VTokenMetadata for an array of vToken addresses\n     * @param vTokens Array of vToken addresses to fetch VTokenMetadata\n     * @return Array of structs with vToken supply and borrow information.\n     */\n    function vTokenMetadataAll(VToken[] calldata vTokens) external returns (VTokenMetadata[] memory) {\n        uint vTokenCount = vTokens.length;\n        VTokenMetadata[] memory res = new VTokenMetadata[](vTokenCount);\n        for (uint i = 0; i < vTokenCount; i++) {\n            res[i] = vTokenMetadata(vTokens[i]);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Get amount of XVS distributed daily to an account\n     * @param account Address of account to fetch the daily XVS distribution\n     * @param comptrollerAddress Address of the comptroller proxy\n     * @return Amount of XVS distributed daily to an account\n     */\n    function getDailyXVS(address payable account, address comptrollerAddress) external returns (uint) {\n        ComptrollerInterface comptrollerInstance = ComptrollerInterface(comptrollerAddress);\n        VToken[] memory vTokens = comptrollerInstance.getAllMarkets();\n        uint dailyXvsPerAccount = 0;\n\n        for (uint i = 0; i < vTokens.length; i++) {\n            VToken vToken = vTokens[i];\n            if (!compareStrings(vToken.symbol(), \"vUST\") && !compareStrings(vToken.symbol(), \"vLUNA\")) {\n                VTokenMetadata memory metaDataItem = vTokenMetadata(vToken);\n\n                //get balanceOfUnderlying and borrowBalanceCurrent from vTokenBalance\n                VTokenBalances memory vTokenBalanceInfo = vTokenBalances(vToken, account);\n\n                VTokenUnderlyingPrice memory underlyingPriceResponse = vTokenUnderlyingPrice(vToken);\n                uint underlyingPrice = underlyingPriceResponse.underlyingPrice;\n                Exp memory underlyingPriceMantissa = Exp({ mantissa: underlyingPrice });\n\n                //get dailyXvsSupplyMarket\n                uint dailyXvsSupplyMarket = 0;\n                uint supplyInUsd = mul_ScalarTruncate(underlyingPriceMantissa, vTokenBalanceInfo.balanceOfUnderlying);\n                uint marketTotalSupply = (metaDataItem.totalSupply * metaDataItem.exchangeRateCurrent) / 1e18;\n                uint marketTotalSupplyInUsd = mul_ScalarTruncate(underlyingPriceMantissa, marketTotalSupply);\n\n                if (marketTotalSupplyInUsd > 0) {\n                    dailyXvsSupplyMarket = (metaDataItem.dailySupplyXvs * supplyInUsd) / marketTotalSupplyInUsd;\n                }\n\n                //get dailyXvsBorrowMarket\n                uint dailyXvsBorrowMarket = 0;\n                uint borrowsInUsd = mul_ScalarTruncate(underlyingPriceMantissa, vTokenBalanceInfo.borrowBalanceCurrent);\n                uint marketTotalBorrowsInUsd = mul_ScalarTruncate(underlyingPriceMantissa, metaDataItem.totalBorrows);\n\n                if (marketTotalBorrowsInUsd > 0) {\n                    dailyXvsBorrowMarket = (metaDataItem.dailyBorrowXvs * borrowsInUsd) / marketTotalBorrowsInUsd;\n                }\n\n                dailyXvsPerAccount += dailyXvsSupplyMarket + dailyXvsBorrowMarket;\n            }\n        }\n\n        return dailyXvsPerAccount;\n    }\n\n    /**\n     * @notice Get the current vToken balance (outstanding borrows) for an account\n     * @param vToken Address of the token to check the balance of\n     * @param account Account address to fetch the balance of\n     * @return VTokenBalances with token balance information\n     */\n    function vTokenBalances(VToken vToken, address payable account) public returns (VTokenBalances memory) {\n        uint balanceOf = vToken.balanceOf(account);\n        uint borrowBalanceCurrent = vToken.borrowBalanceCurrent(account);\n        uint balanceOfUnderlying = vToken.balanceOfUnderlying(account);\n        uint tokenBalance;\n        uint tokenAllowance;\n\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\n            tokenBalance = account.balance;\n            tokenAllowance = account.balance;\n        } else {\n            VBep20 vBep20 = VBep20(address(vToken));\n            IERC20Metadata underlying = IERC20Metadata(vBep20.underlying());\n            tokenBalance = underlying.balanceOf(account);\n            tokenAllowance = underlying.allowance(account, address(vToken));\n        }\n\n        return\n            VTokenBalances({\n                vToken: address(vToken),\n                balanceOf: balanceOf,\n                borrowBalanceCurrent: borrowBalanceCurrent,\n                balanceOfUnderlying: balanceOfUnderlying,\n                tokenBalance: tokenBalance,\n                tokenAllowance: tokenAllowance\n            });\n    }\n\n    /**\n     * @notice Get the current vToken balances (outstanding borrows) for all vTokens on an account\n     * @param vTokens Addresses of the tokens to check the balance of\n     * @param account Account address to fetch the balance of\n     * @return VTokenBalances Array with token balance information\n     */\n    function vTokenBalancesAll(\n        VToken[] calldata vTokens,\n        address payable account\n    ) external returns (VTokenBalances[] memory) {\n        uint vTokenCount = vTokens.length;\n        VTokenBalances[] memory res = new VTokenBalances[](vTokenCount);\n        for (uint i = 0; i < vTokenCount; i++) {\n            res[i] = vTokenBalances(vTokens[i], account);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Get the price for the underlying asset of a vToken\n     * @param vToken address of the vToken\n     * @return response struct with underlyingPrice info of vToken\n     */\n    function vTokenUnderlyingPrice(VToken vToken) public view returns (VTokenUnderlyingPrice memory) {\n        ComptrollerInterface comptroller = ComptrollerInterface(address(vToken.comptroller()));\n        ResilientOracleInterface priceOracle = comptroller.oracle();\n\n        return\n            VTokenUnderlyingPrice({\n                vToken: address(vToken),\n                underlyingPrice: priceOracle.getUnderlyingPrice(address(vToken))\n            });\n    }\n\n    /**\n     * @notice Query the underlyingPrice of an array of vTokens\n     * @param vTokens Array of vToken addresses\n     * @return array of response structs with underlying price information of vTokens\n     */\n    function vTokenUnderlyingPriceAll(\n        VToken[] calldata vTokens\n    ) external view returns (VTokenUnderlyingPrice[] memory) {\n        uint vTokenCount = vTokens.length;\n        VTokenUnderlyingPrice[] memory res = new VTokenUnderlyingPrice[](vTokenCount);\n        for (uint i = 0; i < vTokenCount; i++) {\n            res[i] = vTokenUnderlyingPrice(vTokens[i]);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Query the account liquidity and shortfall of an account\n     * @param comptroller Address of comptroller proxy\n     * @param account Address of the account to query\n     * @return Struct with markets user has entered, liquidity, and shortfall of the account\n     */\n    function getAccountLimits(\n        ComptrollerInterface comptroller,\n        address account\n    ) public view returns (AccountLimits memory) {\n        (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\n        require(errorCode == 0, \"account liquidity error\");\n\n        return AccountLimits({ markets: comptroller.getAssetsIn(account), liquidity: liquidity, shortfall: shortfall });\n    }\n\n    /**\n     * @notice Query the XVSBalance info of an account\n     * @param xvs XVS contract address\n     * @param account Account address\n     * @return Struct with XVS balance and voter details\n     */\n    function getXVSBalanceMetadata(IXVS xvs, address account) external view returns (XVSBalanceMetadata memory) {\n        return\n            XVSBalanceMetadata({\n                balance: xvs.balanceOf(account),\n                votes: uint256(xvs.getCurrentVotes(account)),\n                delegate: xvs.delegates(account)\n            });\n    }\n\n    /**\n     * @notice Query the XVSBalance extended info of an account\n     * @param xvs XVS contract address\n     * @param comptroller Comptroller proxy contract address\n     * @param account Account address\n     * @return Struct with XVS balance and voter details and XVS allocation\n     */\n    function getXVSBalanceMetadataExt(\n        IXVS xvs,\n        ComptrollerInterface comptroller,\n        address account\n    ) external returns (XVSBalanceMetadataExt memory) {\n        uint balance = xvs.balanceOf(account);\n        comptroller.claimVenus(account);\n        uint newBalance = xvs.balanceOf(account);\n        uint accrued = comptroller.venusAccrued(account);\n        uint total = add_(accrued, newBalance, \"sum xvs total\");\n        uint allocated = sub_(total, balance, \"sub allocated\");\n\n        return\n            XVSBalanceMetadataExt({\n                balance: balance,\n                votes: uint256(xvs.getCurrentVotes(account)),\n                delegate: xvs.delegates(account),\n                allocated: allocated\n            });\n    }\n\n    /**\n     * @notice Query the voting power for an account at a specific list of block numbers\n     * @param xvs XVS contract address\n     * @param account Address of the account\n     * @param blockNumbers Array of blocks to query\n     * @return Array of VenusVotes structs with block number and vote count\n     */\n    function getVenusVotes(\n        IXVS xvs,\n        address account,\n        uint32[] calldata blockNumbers\n    ) external view returns (VenusVotes[] memory) {\n        VenusVotes[] memory res = new VenusVotes[](blockNumbers.length);\n        for (uint i = 0; i < blockNumbers.length; i++) {\n            res[i] = VenusVotes({\n                blockNumber: uint256(blockNumbers[i]),\n                votes: uint256(xvs.getPriorVotes(account, blockNumbers[i]))\n            });\n        }\n        return res;\n    }\n\n    /**\n     * @dev Queries the current supply to calculate rewards for an account\n     * @param supplyState VenusMarketState struct\n     * @param vToken Address of a vToken\n     * @param comptroller Address of the comptroller proxy\n     */\n    function updateVenusSupplyIndex(\n        VenusMarketState memory supplyState,\n        address vToken,\n        ComptrollerInterface comptroller\n    ) internal view {\n        uint supplySpeed = comptroller.venusSupplySpeeds(vToken);\n        uint blockNumber = block.number;\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint supplyTokens = VToken(vToken).totalSupply();\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({ mantissa: 0 });\n            Double memory index = add_(Double({ mantissa: supplyState.index }), ratio);\n            supplyState.index = safe224(index.mantissa, \"new index overflows\");\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\n        } else if (deltaBlocks > 0) {\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\n        }\n    }\n\n    /**\n     * @dev Queries the current borrow to calculate rewards for an account\n     * @param borrowState VenusMarketState struct\n     * @param vToken Address of a vToken\n     * @param comptroller Address of the comptroller proxy\n     */\n    function updateVenusBorrowIndex(\n        VenusMarketState memory borrowState,\n        address vToken,\n        Exp memory marketBorrowIndex,\n        ComptrollerInterface comptroller\n    ) internal view {\n        uint borrowSpeed = comptroller.venusBorrowSpeeds(vToken);\n        uint blockNumber = block.number;\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({ mantissa: 0 });\n            Double memory index = add_(Double({ mantissa: borrowState.index }), ratio);\n            borrowState.index = safe224(index.mantissa, \"new index overflows\");\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\n        } else if (deltaBlocks > 0) {\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\n        }\n    }\n\n    /**\n     * @dev Calculate available rewards for an account's supply\n     * @param supplyState VenusMarketState struct\n     * @param vToken Address of a vToken\n     * @param supplier Address of the account supplying\n     * @param comptroller Address of the comptroller proxy\n     * @return Undistributed earned XVS from supplies\n     */\n    function distributeSupplierVenus(\n        VenusMarketState memory supplyState,\n        address vToken,\n        address supplier,\n        ComptrollerInterface comptroller\n    ) internal view returns (uint) {\n        Double memory supplyIndex = Double({ mantissa: supplyState.index });\n        Double memory supplierIndex = Double({ mantissa: comptroller.venusSupplierIndex(vToken, supplier) });\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            supplierIndex.mantissa = comptroller.venusInitialIndex();\n        }\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n        return supplierDelta;\n    }\n\n    /**\n     * @dev Calculate available rewards for an account's borrows\n     * @param borrowState VenusMarketState struct\n     * @param vToken Address of a vToken\n     * @param borrower Address of the account borrowing\n     * @param marketBorrowIndex vToken Borrow index\n     * @param comptroller Address of the comptroller proxy\n     * @return Undistributed earned XVS from borrows\n     */\n    function distributeBorrowerVenus(\n        VenusMarketState memory borrowState,\n        address vToken,\n        address borrower,\n        Exp memory marketBorrowIndex,\n        ComptrollerInterface comptroller\n    ) internal view returns (uint) {\n        Double memory borrowIndex = Double({ mantissa: borrowState.index });\n        Double memory borrowerIndex = Double({ mantissa: comptroller.venusBorrowerIndex(vToken, borrower) });\n        if (borrowerIndex.mantissa > 0) {\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n            return borrowerDelta;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Calculate the total XVS tokens pending and accrued by a user account\n     * @param holder Account to query pending XVS\n     * @param comptroller Address of the comptroller\n     * @return Reward object contraining the totalRewards and pending rewards for each market\n     */\n    function pendingRewards(\n        address holder,\n        ComptrollerInterface comptroller\n    ) external view returns (RewardSummary memory) {\n        VToken[] memory vTokens = comptroller.getAllMarkets();\n        ClaimVenusLocalVariables memory vars;\n        RewardSummary memory rewardSummary;\n        rewardSummary.distributorAddress = address(comptroller);\n        rewardSummary.rewardTokenAddress = comptroller.getXVSAddress();\n        rewardSummary.totalRewards = comptroller.venusAccrued(holder);\n        rewardSummary.pendingRewards = new PendingReward[](vTokens.length);\n        for (uint i; i < vTokens.length; ++i) {\n            (vars.borrowIndex, vars.borrowBlock) = comptroller.venusBorrowState(address(vTokens[i]));\n            VenusMarketState memory borrowState = VenusMarketState({\n                index: vars.borrowIndex,\n                block: vars.borrowBlock\n            });\n\n            (vars.supplyIndex, vars.supplyBlock) = comptroller.venusSupplyState(address(vTokens[i]));\n            VenusMarketState memory supplyState = VenusMarketState({\n                index: vars.supplyIndex,\n                block: vars.supplyBlock\n            });\n\n            Exp memory borrowIndex = Exp({ mantissa: vTokens[i].borrowIndex() });\n\n            PendingReward memory marketReward;\n            marketReward.vTokenAddress = address(vTokens[i]);\n\n            updateVenusBorrowIndex(borrowState, address(vTokens[i]), borrowIndex, comptroller);\n            uint256 borrowReward = distributeBorrowerVenus(\n                borrowState,\n                address(vTokens[i]),\n                holder,\n                borrowIndex,\n                comptroller\n            );\n\n            updateVenusSupplyIndex(supplyState, address(vTokens[i]), comptroller);\n            uint256 supplyReward = distributeSupplierVenus(supplyState, address(vTokens[i]), holder, comptroller);\n\n            marketReward.amount = add_(borrowReward, supplyReward);\n            rewardSummary.pendingRewards[i] = marketReward;\n        }\n        return rewardSummary;\n    }\n\n    /**\n     * @notice Returns all pools (including the Core Pool) along with their associated market data\n     * @param comptroller The Comptroller contract to query\n     * @return poolsData An array of PoolWithMarkets structs, each containing pool info and its markets\n     */\n    function getAllPoolsData(\n        ComptrollerInterface comptroller\n    ) external view returns (PoolWithMarkets[] memory poolsData) {\n        uint96 lastPoolId = comptroller.lastPoolId();\n        poolsData = new PoolWithMarkets[](lastPoolId + 1);\n\n        poolsData[0] = PoolWithMarkets({\n            poolId: 0,\n            label: \"Core Pool\",\n            isActive: true, // dummy value — not applicable to core pool\n            allowCorePoolFallback: true, // dummy value — not applicable to core pool\n            markets: getCorePoolMarketsData(comptroller)\n        });\n\n        for (uint96 i = 1; i <= lastPoolId; ++i) {\n            (string memory label, bool isActive, bool allowCorePoolFallback) = comptroller.pools(i);\n\n            poolsData[i] = PoolWithMarkets({\n                poolId: i,\n                label: label,\n                isActive: isActive,\n                allowCorePoolFallback: allowCorePoolFallback,\n                markets: getMarketsDataByPool(i, comptroller)\n            });\n        }\n    }\n\n    /**\n     * @notice Retrieves full market data for all vTokens in a specific pool (excluding the Core Pool)\n     * @param poolId The pool ID to fetch data for\n     * @param comptroller The address of the Comptroller contract\n     * @return result An array of MarketData structs containing detailed market info for the given pool\n     * @custom:error PoolDoesNotExist Reverts if the given pool ID does not exist\n     * @custom:error InvalidOperationForCorePool Reverts if called on the Core Pool (`poolId = 0`)\n     */\n    function getMarketsDataByPool(\n        uint96 poolId,\n        ComptrollerInterface comptroller\n    ) public view returns (MarketData[] memory result) {\n        if (poolId > comptroller.lastPoolId()) revert PoolDoesNotExist(poolId);\n        if (poolId == comptroller.corePoolId()) revert InvalidOperationForCorePool();\n\n        address[] memory vTokens = comptroller.getPoolVTokens(poolId);\n        uint256 length = vTokens.length;\n        result = new MarketData[](length);\n\n        (string memory label, , ) = comptroller.pools(poolId);\n\n        for (uint256 i; i < length; ++i) {\n            (\n                bool isListed,\n                uint256 collateralFactor,\n                bool isVenus,\n                uint256 liquidationThreshold,\n                uint256 liquidationIncentive,\n                uint96 marketPoolId,\n                bool isBorrowAllowed\n            ) = comptroller.poolMarkets(poolId, vTokens[i]);\n\n            result[i] = MarketData({\n                poolId: marketPoolId,\n                poolLabel: label,\n                vToken: vTokens[i],\n                isListed: isListed,\n                collateralFactor: collateralFactor,\n                isVenus: isVenus,\n                liquidationThreshold: liquidationThreshold,\n                liquidationIncentive: liquidationIncentive,\n                isBorrowAllowed: isBorrowAllowed\n            });\n        }\n    }\n\n    /**\n     * @notice Retrieves full market data for all vTokens in the Core Pool (poolId 0)\n     * @param comptroller The address of the Comptroller contract\n     * @return result An array of MarketData structs containing detailed market info for the core pool\n     */\n    function getCorePoolMarketsData(ComptrollerInterface comptroller) public view returns (MarketData[] memory result) {\n        VToken[] memory vTokens = comptroller.getAllMarkets();\n        uint256 length = vTokens.length;\n        result = new MarketData[](length);\n\n        string memory label = \"Core\";\n\n        for (uint256 i; i < length; ++i) {\n            (\n                bool isListed,\n                uint256 collateralFactor,\n                bool isVenus,\n                uint256 liquidationThreshold,\n                uint256 liquidationIncentive,\n                uint96 marketPoolId,\n                bool isBorrowAllowed\n            ) = comptroller.markets(address(vTokens[i]));\n\n            result[i] = MarketData({\n                poolId: marketPoolId,\n                poolLabel: label,\n                vToken: address(vTokens[i]),\n                isListed: isListed,\n                collateralFactor: collateralFactor,\n                isVenus: isVenus,\n                liquidationThreshold: liquidationThreshold,\n                liquidationIncentive: liquidationIncentive,\n                isBorrowAllowed: isBorrowAllowed\n            });\n        }\n    }\n\n    // utilities\n    /**\n     * @notice Compares if two strings are equal\n     * @param a First string to compare\n     * @param b Second string to compare\n     * @return Boolean depending on if the strings are equal\n     */\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/test/BadFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MockFlashLoanReceiver.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\n\ncontract BadFlashLoanReceiver is MockFlashLoanReceiver {\n    constructor(ComptrollerInterface comptroller) MockFlashLoanReceiver(comptroller) {}\n\n    function executeOperation(\n        VToken[] calldata,\n        uint256[] calldata,\n        uint256[] calldata,\n        address,\n        bytes calldata\n    ) external override returns (bool, uint256[] memory) {\n        return (false, new uint256[](0));\n    }\n}\n"
    },
    "contracts/test/BorrowDebtFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MockFlashLoanReceiver.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\n\ncontract BorrowDebtFlashLoanReceiver is MockFlashLoanReceiver {\n    constructor(ComptrollerInterface comptroller) MockFlashLoanReceiver(comptroller) {}\n\n    function executeOperation(\n        VToken[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata,\n        address onBehalf,\n        bytes calldata param\n    ) external override returns (bool, uint256[] memory) {\n        // 👇 Your custom logic for the flash loan should be implemented here 👇\n        /** YOUR CUSTOM LOGIC HERE */\n        onBehalf;\n        param;\n        // 👆 Your custom logic for the flash loan should be implemented above here 👆\n\n        uint256[] memory approvedTokens = _approveRepaymentsBorrow(assets, amounts);\n        return (true, approvedTokens);\n    }\n\n    function _approveRepaymentsBorrow(\n        VToken[] calldata assets,\n        uint256[] calldata amounts\n    ) private returns (uint256[] memory) {\n        uint256 len = assets.length;\n        uint256[] memory approvedTokens = new uint256[](len);\n        for (uint256 k = 0; k < len; ++k) {\n            uint256 total = amounts[k]; // Intentionally not adding premiums to create debt position\n            IERC20NonStandard(assets[k].underlying()).approve(address(assets[k]), total);\n\n            approvedTokens[k] = total;\n        }\n        return approvedTokens;\n    }\n}\n"
    },
    "contracts/test/ComptrollerHarness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"./ComptrollerMock.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\ncontract ComptrollerHarness is ComptrollerMock {\n    address internal xvsAddress;\n    address internal vXVSAddress;\n    uint public blockNumber;\n\n    constructor() ComptrollerMock() {}\n\n    function setVenusSupplyState(address vToken, uint224 index, uint32 blockNumber_) public {\n        venusSupplyState[vToken].index = index;\n        venusSupplyState[vToken].block = blockNumber_;\n    }\n\n    function setVenusBorrowState(address vToken, uint224 index, uint32 blockNumber_) public {\n        venusBorrowState[vToken].index = index;\n        venusBorrowState[vToken].block = blockNumber_;\n    }\n\n    function setVenusAccrued(address user, uint userAccrued) public {\n        venusAccrued[user] = userAccrued;\n    }\n\n    function setXVSAddress(address xvsAddress_) public {\n        xvsAddress = xvsAddress_;\n    }\n\n    function setXVSVTokenAddress(address vXVSAddress_) public {\n        vXVSAddress = vXVSAddress_;\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block\n     * @param venusRate_ The amount of XVS wei per block to distribute\n     */\n    function harnessSetVenusRate(uint venusRate_) public {\n        venusRate = venusRate_;\n    }\n\n    /**\n     * @notice Recalculate and update XVS speeds for all XVS markets\n     */\n    function harnessRefreshVenusSpeeds() public {\n        VToken[] memory allMarkets_ = allMarkets;\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusSupplyIndex(address(vToken));\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n        }\n\n        Exp memory totalUtility = Exp({ mantissa: 0 });\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            if (venusSpeeds[address(vToken)] > 0) {\n                Exp memory assetPrice = Exp({ mantissa: oracle.getUnderlyingPrice(address(vToken)) });\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\n                utilities[i] = utility;\n                totalUtility = add_(totalUtility, utility);\n            }\n        }\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets[i];\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\n            setVenusSpeedInternal(vToken, newSpeed, newSpeed);\n        }\n    }\n\n    function setVenusBorrowerIndex(address vToken, address borrower, uint index) public {\n        venusBorrowerIndex[vToken][borrower] = index;\n    }\n\n    function setVenusSupplierIndex(address vToken, address supplier, uint index) public {\n        venusSupplierIndex[vToken][supplier] = index;\n    }\n\n    function harnessDistributeAllBorrowerVenus(\n        address vToken,\n        address borrower,\n        uint marketBorrowIndexMantissa\n    ) public {\n        distributeBorrowerVenus(vToken, borrower, Exp({ mantissa: marketBorrowIndexMantissa }));\n        venusAccrued[borrower] = grantXVSInternal(borrower, venusAccrued[borrower], 0, false);\n    }\n\n    function harnessDistributeAllSupplierVenus(address vToken, address supplier) public {\n        distributeSupplierVenus(vToken, supplier);\n        venusAccrued[supplier] = grantXVSInternal(supplier, venusAccrued[supplier], 0, false);\n    }\n\n    function harnessUpdateVenusBorrowIndex(address vToken, uint marketBorrowIndexMantissa) public {\n        updateVenusBorrowIndex(vToken, Exp({ mantissa: marketBorrowIndexMantissa }));\n    }\n\n    function harnessUpdateVenusSupplyIndex(address vToken) public {\n        updateVenusSupplyIndex(vToken);\n    }\n\n    function harnessDistributeBorrowerVenus(address vToken, address borrower, uint marketBorrowIndexMantissa) public {\n        distributeBorrowerVenus(vToken, borrower, Exp({ mantissa: marketBorrowIndexMantissa }));\n    }\n\n    function harnessDistributeSupplierVenus(address vToken, address supplier) public {\n        distributeSupplierVenus(vToken, supplier);\n    }\n\n    function harnessTransferVenus(address user, uint userAccrued, uint threshold) public returns (uint) {\n        if (userAccrued > 0 && userAccrued >= threshold) {\n            return grantXVSInternal(user, userAccrued, 0, false);\n        }\n        return userAccrued;\n    }\n\n    function harnessAddVenusMarkets(address[] memory vTokens) public {\n        for (uint i = 0; i < vTokens.length; i++) {\n            // temporarily set venusSpeed to 1 (will be fixed by `harnessRefreshVenusSpeeds`)\n            setVenusSpeedInternal(VToken(vTokens[i]), 1, 1);\n        }\n    }\n\n    function harnessSetMintedVAIs(address user, uint amount) public {\n        mintedVAIs[user] = amount;\n    }\n\n    function harnessFastForward(uint blocks) public returns (uint) {\n        blockNumber += blocks;\n        return blockNumber;\n    }\n\n    function setBlockNumber(uint number) public {\n        blockNumber = number;\n    }\n\n    function getBlockNumber() internal view override returns (uint) {\n        return blockNumber;\n    }\n\n    function getVenusMarkets() public view returns (address[] memory) {\n        uint m = allMarkets.length;\n        uint n = 0;\n        for (uint i = 0; i < m; i++) {\n            if (venusSpeeds[address(allMarkets[i])] > 0) {\n                n++;\n            }\n        }\n\n        address[] memory venusMarkets = new address[](n);\n        uint k = 0;\n        for (uint i = 0; i < m; i++) {\n            if (venusSpeeds[address(allMarkets[i])] > 0) {\n                venusMarkets[k++] = address(allMarkets[i]);\n            }\n        }\n        return venusMarkets;\n    }\n\n    function harnessSetReleaseStartBlock(uint startBlock) external {\n        releaseStartBlock = startBlock;\n    }\n\n    function harnessAddVtoken(address vToken) external {\n        getCorePoolMarket(vToken).isListed = true;\n    }\n}\n\ncontract EchoTypesComptroller is UnitrollerAdminStorage {\n    function stringy(string memory s) public pure returns (string memory) {\n        return s;\n    }\n\n    function addresses(address a) public pure returns (address) {\n        return a;\n    }\n\n    function booly(bool b) public pure returns (bool) {\n        return b;\n    }\n\n    function listOInts(uint[] memory u) public pure returns (uint[] memory) {\n        return u;\n    }\n\n    function reverty() public pure {\n        require(false, \"gotcha sucka\");\n    }\n\n    function becomeBrains(address payable unitroller) public {\n        Unitroller(unitroller)._acceptImplementation();\n    }\n}\n"
    },
    "contracts/test/ComptrollerMock.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/facets/MarketFacet.sol\";\nimport \"../Comptroller/Diamond/facets/PolicyFacet.sol\";\nimport \"../Comptroller/Diamond/facets/RewardFacet.sol\";\nimport \"../Comptroller/Diamond/facets/SetterFacet.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\n// This contract contains all methods of Comptroller implementation in different facets at one place for testing purpose\n// This contract does not have diamond functionality(i.e delegate call to facets methods)\ncontract ComptrollerMock is MarketFacet, PolicyFacet, RewardFacet, SetterFacet {\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external override returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/test/ComptrollerMockR1.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/facets/MarketFacet.sol\";\nimport \"../Comptroller/Diamond/facets/PolicyFacet.sol\";\nimport \"../Comptroller/Diamond/facets/RewardFacet.sol\";\nimport \"../Comptroller/Diamond/facets/SetterFacet.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\n// This contract contains all methods of Comptroller implementation in different facets at one place for testing purpose\n// This contract does not have diamond functionality(i.e delegate call to facets methods)\ncontract ComptrollerMockR1 is MarketFacet, PolicyFacet, RewardFacet, SetterFacet {\n    event MarketListed(address vToken);\n    event NewCollateralFactor(address vToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n    event MarketEntered(address vToken, address account);\n    event MarketExited(address vToken, address account);\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external override returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/test/ComptrollerScenario.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"./ComptrollerMock.sol\";\n\ncontract ComptrollerScenario is ComptrollerMock {\n    uint public blockNumber;\n    address public xvsAddress;\n    address public vaiAddress;\n\n    constructor() ComptrollerMock() {}\n\n    function setXVSAddress(address xvsAddress_) public {\n        xvsAddress = xvsAddress_;\n    }\n\n    // function getXVSAddress() public view returns (address) {\n    //     return xvsAddress;\n    // }\n\n    function setVAIAddress(address vaiAddress_) public {\n        vaiAddress = vaiAddress_;\n    }\n\n    function getVAIAddress() public view returns (address) {\n        return vaiAddress;\n    }\n\n    function membershipLength(VToken vToken) public view returns (uint) {\n        return accountAssets[address(vToken)].length;\n    }\n\n    function fastForward(uint blocks) public returns (uint) {\n        blockNumber += blocks;\n\n        return blockNumber;\n    }\n\n    function setBlockNumber(uint number) public {\n        blockNumber = number;\n    }\n\n    function getBlockNumber() internal view override returns (uint) {\n        return blockNumber;\n    }\n\n    function getVenusMarkets() public view returns (address[] memory) {\n        uint m = allMarkets.length;\n        uint n = 0;\n        for (uint i = 0; i < m; i++) {\n            if (getCorePoolMarket(address(allMarkets[i])).isVenus) {\n                n++;\n            }\n        }\n\n        address[] memory venusMarkets = new address[](n);\n        uint k = 0;\n        for (uint i = 0; i < m; i++) {\n            if (getCorePoolMarket(address(allMarkets[i])).isVenus) {\n                venusMarkets[k++] = address(allMarkets[i]);\n            }\n        }\n        return venusMarkets;\n    }\n\n    function unlist(VToken vToken) public {\n        getCorePoolMarket(address(vToken)).isListed = false;\n    }\n\n    /**\n     * @notice Recalculate and update XVS speeds for all XVS markets\n     */\n    function refreshVenusSpeeds() public {\n        VToken[] memory allMarkets_ = allMarkets;\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusSupplyIndex(address(vToken));\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n        }\n\n        Exp memory totalUtility = Exp({ mantissa: 0 });\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            if (venusSpeeds[address(vToken)] > 0) {\n                Exp memory assetPrice = Exp({ mantissa: oracle.getUnderlyingPrice(address(vToken)) });\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\n                utilities[i] = utility;\n                totalUtility = add_(totalUtility, utility);\n            }\n        }\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets[i];\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\n            setVenusSpeedInternal(vToken, newSpeed, newSpeed);\n        }\n    }\n}\n"
    },
    "contracts/test/DiamondHarness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/Diamond.sol\";\n\ncontract DiamondHarness is Diamond {\n    function getFacetAddress(bytes4 sig) public view returns (address) {\n        address facet = _selectorToFacetAndPosition[sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        return facet;\n    }\n}\n"
    },
    "contracts/test/EvilXDelegator.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport { InterestRateModelV8 } from \"../InterestRateModels/InterestRateModelV8.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { VTokenInterface, VBep20Interface, VDelegatorInterface } from \"../Tokens/VTokens/VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20Delegator Contract\n * @notice VTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Venus\n */\nabstract contract EvilXDelegator is VTokenInterface, VBep20Interface, VDelegatorInterface {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address implementation_,\n        bytes memory becomeImplementationData\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"initialize(address,address,address,uint256,string,string,uint8)\",\n                underlying_,\n                comptroller_,\n                interestRateModel_,\n                initialExchangeRateMantissa_,\n                name_,\n                symbol_,\n                decimals_\n            )\n        );\n\n        // New implementations always get set via the settor (post-initialize)\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) public {\n        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n\n        if (allowResign) {\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n        }\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint256 mintAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mint(uint256)\", mintAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintBehalf(address receiver, uint256 mintAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"mintBehalf(address,uint256)\", receiver, mintAmount)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(uint256 borrowAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint256 repayAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"liquidateBorrow(address,uint256,address)\", borrower, repayAmount, vTokenCollateral)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount));\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", src, dst, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"allowance(address,address)\", owner, spender)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"balanceOf(address)\", owner));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint256, uint256, uint256, uint256) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"getAccountSnapshot(address)\", account)\n        );\n        return abi.decode(data, (uint256, uint256, uint256, uint256));\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this vToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"borrowBalanceStored(address)\", account)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint256) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getCash()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves.\n     * @dev This calculates interest accrued from the last checkpointed block\n     *      up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(address liquidator, address borrower, uint256 seizeTokens) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"seize(address,address,uint256)\", liquidator, borrower, seizeTokens)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Admin function to set a new comptroller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactor(uint256 newReserveFactorMantissa) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrues interest and adds reserves by transferring from admin\n     * @param addAmount Amount of reserves to add\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint256 addAmount) external returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint256 reduceAmount) external override returns (uint256) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel) public override returns (uint256) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel)\n        );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * @notice Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n        return delegateTo(implementation, data);\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(\n            abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data)\n        );\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/EvilXToken.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VTokens/VBep20Immutable.sol\";\nimport \"../Tokens/VTokens/VBep20Delegator.sol\";\nimport \"../Tokens/VTokens/VBep20Delegate.sol\";\nimport \"./ComptrollerScenario.sol\";\nimport \"../Comptroller/ComptrollerInterface.sol\";\n\ncontract VBep20Scenario is VBep20Immutable {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\n// doTransferOut method of this token supposed to be compromised and contians malicious code which\n// can be used by attacker to compromise the protocol working.\ncontract EvilXToken is VBep20Delegate {\n    event Log(string x, address y);\n    event Log(string x, uint y);\n    event LogLiquidity(uint liquidity);\n\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    address public comptrollerAddress;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    function setComptrollerAddress(address _comptrollerAddress) external {\n        comptrollerAddress = _comptrollerAddress;\n    }\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        super.doTransferOut(to, amount);\n\n        // Checking the Liquidity of the user after the tranfer.\n        // solhint-disable-next-line no-unused-vars\n        (uint errorCode, uint liquidity, uint shortfall) = ComptrollerInterface(comptrollerAddress).getAccountLiquidity(\n            msg.sender\n        );\n        emit LogLiquidity(liquidity);\n        return;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\n        totalBorrows = totalBorrows + addtlBorrow_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount, true);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n    }\n}\n"
    },
    "contracts/test/FlashLoanReceiverBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { IFlashLoanReceiver } from \"../FlashLoan/interfaces/IFlashLoanReceiver.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\n\n/// @title FlashLoanReceiverBase\n/// @notice A base contract for implementing flashLoan receiver logic.\n/// @dev This abstract contract provides the necessary structure for inheriting contracts to implement the `IFlashLoanReceiver` interface.\n///      It stores a reference to the Comptroller contract, which manages various aspects of the protocol.\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\n    /// @notice The Comptroller contract that governs the protocol.\n    /// @dev This variable stores the address of the Comptroller contract, which cannot be changed after deployment.\n    ComptrollerInterface public COMPTROLLER;\n\n    /**\n     * @notice Constructor to initialize the base contract with the Comptroller address.\n     * @param comptroller_ The address of the Comptroller contract that oversees the protocol.\n     */\n    constructor(ComptrollerInterface comptroller_) {\n        COMPTROLLER = comptroller_;\n    }\n}\n"
    },
    "contracts/test/FlashLoanSimpleReceiverBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { IFlashLoanSimpleReceiver } from \"../FlashLoan/interfaces/IFlashLoanSimpleReceiver.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\n\n/**\n * @title FlashLoanSimpleReceiverBase\n * @author Venus\n * @notice Base contract to develop a flashLoan-receiver contract.\n * @dev This contract serves as a foundational contract for implementing custom flash loan receiver logic.\n * Inheritors of this contract need to implement the `executeOperation` function defined in the `IFlashLoanSimpleReceiver` interface.\n */\nabstract contract FlashLoanSimpleReceiverBase is IFlashLoanSimpleReceiver {\n    /// @notice The VToken contract used to initiate and handle flash loan\n    /// @dev This is a reference to the VToken, which enables the flash loan functionality.\n    VToken public VTOKEN;\n\n    /// @notice Initializes the base contract by setting the VToken address\n    /// @param vToken_ The address of the VToken contract that supports flash loan\n    constructor(VToken vToken_) {\n        VTOKEN = vToken_;\n    }\n}\n"
    },
    "contracts/test/InsufficientRepaymentFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MockFlashLoanReceiver.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\n\ncontract InsufficientRepaymentFlashLoanReceiver is MockFlashLoanReceiver {\n    constructor(ComptrollerInterface comptroller) MockFlashLoanReceiver(comptroller) {}\n\n    function executeOperation(\n        VToken[] calldata assets,\n        uint256[] calldata,\n        uint256[] calldata premiums,\n        address onBehalf,\n        bytes calldata param\n    ) external override returns (bool, uint256[] memory) {\n        onBehalf;\n        param;\n\n        uint256[] memory approvedTokens = _approveInsufficientRepayments(assets, premiums);\n        return (true, approvedTokens);\n    }\n\n    function _approveInsufficientRepayments(\n        VToken[] calldata assets,\n        uint256[] calldata premiums\n    ) private returns (uint256[] memory) {\n        uint256 len = assets.length;\n        uint256[] memory approvedTokens = new uint256[](len);\n\n        for (uint256 k = 0; k < len; ++k) {\n            // Approve only half of the premium (fee) - intentionally insufficient\n            uint256 insufficientAmount = premiums[k] / 2;\n            IERC20NonStandard(assets[k].underlying()).approve(address(assets[k]), insufficientAmount);\n\n            approvedTokens[k] = insufficientAmount;\n        }\n        return approvedTokens;\n    }\n}\n"
    },
    "contracts/test/MockFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { FlashLoanReceiverBase } from \"./FlashLoanReceiverBase.sol\";\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { IERC20NonStandard } from \"../Tokens/test/IERC20NonStandard.sol\";\n\n/// @title MockFlashLoanReceiver\n/// @notice A mock implementation of a flashLoan receiver contract that interacts with the Comptroller to request and handle flash loans.\n/// @dev This contract extends `FlashLoanReceiverBase` and implements custom logic to request flash loans and repay them.\ncontract MockFlashLoanReceiver is FlashLoanReceiverBase {\n    /**\n     * @notice Constructor to initialize the flashLoan receiver with the Comptroller contract.\n     * @param comptroller The address of the Comptroller contract used to request flash loans.\n     */\n    constructor(ComptrollerInterface comptroller) FlashLoanReceiverBase(comptroller) {}\n\n    /**\n     * @notice Requests a flash loan from the Comptroller contract.\n     * @dev This function calls the `executeFlashLoan` function from the Comptroller to initiate a flash loan.\n     * @param assets An array of VToken contracts that support flash loans.\n     * @param amounts An array of amounts to borrow in the flash loan for each corresponding asset.\n     * @param receiver The address of the contract that will receive the flashLoan and execute the operation.\n     * @param param Additional encoded parameters passed with the flash loan.\n     */\n    function requestFlashLoan(\n        VToken[] calldata assets,\n        uint256[] calldata amounts,\n        address payable receiver,\n        bytes calldata param\n    ) external {\n        // Request the flashLoan from the Comptroller contract\n        COMPTROLLER.executeFlashLoan(payable(msg.sender), receiver, assets, amounts, param);\n    }\n\n    /**\n     * @notice Executes custom logic after receiving the flash loan.\n     * @dev This function is called by the Comptroller contract as part of the flashLoan process.\n     *      It must repay the loan amount plus the premium for each borrowed asset.\n     * @param assets The VToken contracts for the flash-borrowed assets.\n     * @param amounts The amounts of each asset borrowed.\n     * @param premiums The fees for each flash-borrowed asset.\n     * @param onBehalf The address of the user whose debt position will be used for the flashLoan.\n     * @param param Additional encoded parameters passed with the flash loan.\n     * @return True if the operation succeeds and the debt plus premium is repaid, false otherwise.\n     */\n    function executeOperation(\n        VToken[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address onBehalf,\n        bytes calldata param\n    ) external virtual returns (bool, uint256[] memory) {\n        // 👇 Your custom logic for the flash loan should be implemented here 👇\n        /** YOUR CUSTOM LOGIC HERE */\n        onBehalf;\n        param;\n        // 👆 Your custom logic for the flash loan should be implemented above here 👆\n\n        uint256[] memory approvedTokens = _approveRepayments(assets, amounts, premiums);\n        return (true, approvedTokens);\n    }\n\n    function _approveRepayments(\n        VToken[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums\n    ) private returns (uint256[] memory) {\n        uint256 len = assets.length;\n        uint256[] memory approvedTokens = new uint256[](len);\n        for (uint256 k = 0; k < len; ++k) {\n            uint256 total = amounts[k] + premiums[k];\n            IERC20NonStandard(assets[k].underlying()).approve(address(assets[k]), total);\n            approvedTokens[k] = total;\n        }\n        return approvedTokens;\n    }\n}\n"
    },
    "contracts/test/MockFlashLoanSimpleReceiver.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { FlashLoanSimpleReceiverBase } from \"./FlashLoanSimpleReceiverBase.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { IERC20NonStandard } from \"../Tokens/test/IERC20NonStandard.sol\";\n\n/// @title MockFlashLoanSimpleReceiver\n/// @notice This contract serves as a mock implementation for a flash loan receiver, utilizing the\n///         FlashLoanSimpleReceiverBase as a foundation. It provides the ability to request a flash loan and\n///         defines how the loan is repaid by implementing custom logic in the `executeOperation` function.\ncontract MockFlashLoanSimpleReceiver is FlashLoanSimpleReceiverBase {\n    /**\n     * @notice Constructor that initializes the flashLoan receiver with a reference to the VToken contract.\n     * @param vToken The address of the VToken contract that supports flashLoan functionality.\n     */\n    constructor(VToken vToken) public FlashLoanSimpleReceiverBase(vToken) {}\n\n    /**\n     * @notice Requests a flash loan from the VToken contract.\n     * @param amount The amount of tokens to borrow through the flash loan.\n     * @param receiver The address of the contract that will receive the flashLoan and execute the operation.\n     * @param param Additional encoded parameters passed with the flash loan.\n     * @dev This function calls the `executeFlashLoan` function of the VToken contract.\n     */\n    function requestFlashLoan(uint256 amount, address payable receiver, bytes calldata param) external {\n        // Request the flashLoan from the VToken contract\n        VTOKEN.executeFlashLoan(receiver, amount, param);\n    }\n\n    /**\n     * @notice This function is invoked after receiving the flash loan to handle the loan execution.\n     * @dev Custom logic for the use of the borrowed amount is implemented in this function.\n     *      It is important that the total borrowed amount plus the premium is repaid.\n     * @param asset The address of the token being borrowed in the flash loan.\n     * @param amount The amount of tokens borrowed.\n     * @param premium The fee for the flash loan, typically a small percentage of the borrowed amount.\n     * @param onBehalf The address of the user whose debt position will be used for the flashLoan.\n     * @param param Additional parameters passed along with the flash loan (can be empty).\n     * @return Returns true if the operation is successful.\n     */\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address onBehalf,\n        bytes calldata param\n    ) external returns (bool) {\n        // 👇 Your custom logic for the flash loan should be implemented here 👇\n        /** YOUR CUSTOM LOGIC HERE */\n        onBehalf;\n        param;\n        // 👆 Your custom logic for the flash loan should be implemented above here 👆\n\n        // Calculate the total repayment amount (loan amount + premium)\n        uint256 total = amount + premium;\n\n        // Transfer the total amount (principal + premium) back to the VToken contract to repay the loan\n        IERC20NonStandard(asset).approve(address(VTOKEN), total);\n\n        // Return true to indicate successful execution of the flash loan operation\n        return true;\n    }\n}\n"
    },
    "contracts/test/MockVBNB.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VTokens/VToken.sol\";\n\n/**\n * @title Venus's vBNB Contract\n * @notice vToken which wraps BNB\n * @author Venus\n */\ncontract MockVBNB is VToken {\n    /**\n     * @notice Construct a new vBNB money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n    constructor(\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Send BNB to VBNB to mint\n     */\n    receive() external payable {\n        (uint err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Reverts upon any failure\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits Mint event\n    function mint() external payable {\n        (uint err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @dev Reverts upon any failure\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrow() external payable {\n        (uint err, ) = repayBorrowInternal(msg.value);\n        requireNoError(err, \"repayBorrow failed\");\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @dev Reverts upon any failure\n     * @param borrower The account with the debt being payed off\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrowBehalf(address borrower) external payable {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, msg.value);\n        requireNoError(err, \"repayBorrowBehalf failed\");\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev Reverts upon any failure\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     */\n    // @custom:event Emit LiquidateBorrow event on success\n    function liquidateBorrow(address borrower, VToken vTokenCollateral) external payable {\n        (uint err, ) = liquidateBorrowInternal(borrower, msg.value, vTokenCollateral);\n        requireNoError(err, \"liquidateBorrow failed\");\n    }\n\n    function setTotalReserves(uint totalReserves_) external payable {\n        totalReserves = totalReserves_;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Perform the actual transfer in, which is a no-op\n     * @param from Address sending the BNB\n     * @param amount Amount of BNB being sent\n     * @return The actual amount of BNB transferred\n     */\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\n        // Sanity checks\n        require(msg.sender == from, \"sender mismatch\");\n        require(msg.value == amount, \"value mismatch\");\n        return amount;\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        /* Send the BNB, with minimal gas and revert on failure */\n        to.transfer(amount);\n    }\n\n    /**\n     * @notice Gets balance of this contract in terms of BNB, before this message\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of BNB owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n        require(err == MathError.NO_ERROR, \"cash prior math error\");\n        return startingBalance;\n    }\n\n    function requireNoError(uint errCode, string memory message) internal pure {\n        if (errCode == uint(Error.NO_ERROR)) {\n            return;\n        }\n\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\n        uint i;\n\n        for (i = 0; i < bytes(message).length; i++) {\n            fullMessage[i] = bytes(message)[i];\n        }\n\n        fullMessage[i + 0] = bytes1(uint8(32));\n        fullMessage[i + 1] = bytes1(uint8(40));\n        fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 10)));\n        fullMessage[i + 3] = bytes1(uint8(48 + (errCode % 10)));\n        fullMessage[i + 4] = bytes1(uint8(41));\n\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _reduceReservesFresh(uint reduceAmount) internal override returns (uint) {\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(admin, reduceAmount);\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits ReservesReduced event\n    function _reduceReserves(uint reduceAmount) external override nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    // @custom:event Emits AccrueInterest event\n    function accrueInterest() public override returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            reservesPrior\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return uint(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/test/SimplePriceOracle.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport \"../Tokens/VTokens/VBep20.sol\";\n\ncontract SimplePriceOracle is ResilientOracleInterface {\n    mapping(address => uint) internal prices;\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n    function getUnderlyingPrice(address vToken) public view returns (uint) {\n        string memory symbol = VToken(vToken).symbol();\n        if (compareStrings(symbol, \"vBNB\")) {\n            return 1e18;\n        } else if (compareStrings(symbol, \"VAI\")) {\n            return prices[address(vToken)];\n        } else {\n            return prices[address(VBep20(address(vToken)).underlying())];\n        }\n    }\n\n    function getPrice(address asset) external view returns (uint256) {\n        return prices[asset];\n    }\n\n    function updatePrice(address vToken) external {}\n\n    function updateAssetPrice(address asset) external {}\n\n    function setUnderlyingPrice(VToken vToken, uint underlyingPriceMantissa) public {\n        address asset = address(VBep20(address(vToken)).underlying());\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n        prices[asset] = underlyingPriceMantissa;\n    }\n\n    function setDirectPrice(address asset, uint price) public {\n        emit PricePosted(asset, prices[asset], price, price);\n        prices[asset] = price;\n    }\n\n    // v1 price oracle interface for use as backing of proxy\n    function assetPrices(address asset) external view returns (uint) {\n        return prices[asset];\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/test/VAIControllerHarness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VAI/VAIController.sol\";\n\ncontract VAIControllerHarness is VAIController {\n    uint public blockNumber;\n    uint public blocksPerYear;\n\n    constructor() VAIController() {\n        admin = msg.sender;\n    }\n\n    function setVenusVAIState(uint224 index, uint32 blockNumber_) public {\n        venusVAIState.index = index;\n        venusVAIState.block = blockNumber_;\n    }\n\n    function setVAIAddress(address vaiAddress_) public {\n        vai = vaiAddress_;\n    }\n\n    function getVAIAddress() public view override returns (address) {\n        return vai;\n    }\n\n    function harnessRepayVAIFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayVAIFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateVAIFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateVAIFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessFastForward(uint blocks) public returns (uint) {\n        blockNumber += blocks;\n        return blockNumber;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function setBlockNumber(uint number) public {\n        blockNumber = number;\n    }\n\n    function setBlocksPerYear(uint number) public {\n        blocksPerYear = number;\n    }\n\n    function getBlockNumber() internal view override returns (uint) {\n        return blockNumber;\n    }\n\n    function getBlocksPerYear() public view override returns (uint) {\n        return blocksPerYear;\n    }\n}\n"
    },
    "contracts/test/VBep20Harness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VTokens/VBep20Immutable.sol\";\nimport \"../Tokens/VTokens/VBep20Delegator.sol\";\nimport \"../Tokens/VTokens/VBep20Delegate.sol\";\nimport \"./ComptrollerScenario.sol\";\n\ncontract VBep20Harness is VBep20Immutable {\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        return super.doTransferOut(to, amount);\n    }\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount, true);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n    }\n}\n\ncontract VBep20Scenario is VBep20Immutable {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\ncontract VEvil is VBep20Scenario {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Scenario(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function evilSeize(VToken treasure, address liquidator, address borrower, uint seizeTokens) public returns (uint) {\n        return treasure.seize(liquidator, borrower, seizeTokens);\n    }\n}\n\nabstract contract VBep20DelegatorScenario is VBep20Delegator {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address implementation_,\n        bytes memory becomeImplementationData\n    )\n        VBep20Delegator(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_,\n            implementation_,\n            becomeImplementationData\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n}\n\ncontract VBep20DelegateHarness is VBep20Delegate {\n    event Log(string x, address y);\n    event Log(string x, uint y);\n\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        return super.doTransferOut(to, amount);\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\n        totalBorrows = totalBorrows + addtlBorrow_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount, true);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n    }\n}\n\ncontract VBep20DelegateScenario is VBep20Delegate {\n    constructor() {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\ncontract VBep20DelegateScenarioExtra is VBep20DelegateScenario {\n    function iHaveSpoken() public pure returns (string memory) {\n        return \"i have spoken\";\n    }\n\n    function itIsTheWay() public {\n        admin = payable(address(1)); // make a change to test effect\n    }\n\n    function babyYoda() public pure {\n        revert(\"protect the baby\");\n    }\n}\n"
    },
    "contracts/test/VBep20MockDelegate.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ComptrollerInterface } from \"../Comptroller/ComptrollerInterface.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { InterestRateModelV8 } from \"../InterestRateModels/InterestRateModelV8.sol\";\nimport { VBep20Interface, VTokenInterface } from \"../Tokens/VTokens/VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20 Contract\n * @notice VTokens which wrap an EIP-20 underlying\n * @author Venus\n */\ncontract VBep20MockDelegate is VToken, VBep20Interface {\n    using SafeERC20 for IERC20;\n\n    uint internal blockNumber = 100000;\n\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        // VToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) public {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() public {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err, ) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param receiver the account which is receiving the vTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\n        (uint err, ) = mintBehalfInternal(receiver, mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint) {\n        (uint err, ) = liquidateBorrowInternal(borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard BEP-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\n        IERC20 token = IERC20(underlying);\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard BEP-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal override {\n        IERC20 token = IERC20(underlying);\n        token.safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/Tokens/Prime/IPrime.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title IPrime\n * @author Venus\n * @notice Interface for Prime Token\n */\ninterface IPrime {\n    /**\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\n     * @param user the account address whose balance was updated\n     */\n    function xvsUpdated(address user) external;\n\n    /**\n     * @notice accrues interest and updates score for an user for a specific market\n     * @param user the account address for which to accrue interest and update score\n     * @param market the market for which to accrue interest and update score\n     */\n    function accrueInterestAndUpdateScore(address user, address market) external;\n\n    /**\n     * @notice Distributes income from market since last distribution\n     * @param vToken the market for which to distribute the income\n     */\n    function accrueInterest(address vToken) external;\n\n    /**\n     * @notice Returns if user is a prime holder\n     * @param isPrimeHolder returns if the user is a prime holder\n     */\n    function isUserPrimeHolder(address user) external view returns (bool isPrimeHolder);\n}\n"
    },
    "contracts/Tokens/test/IERC20NonStandard.sol": {
      "content": "pragma solidity 0.8.25;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of BEP20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface IERC20NonStandard {\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance of the owner\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the BEP-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the BEP-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     */\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved\n     * @return success Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return remaining The number of tokens allowed to be spent\n     */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/Tokens/VAI/IVAI.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n\npragma solidity 0.8.25;\n\ninterface IVAI {\n    // --- Auth ---\n    function wards(address) external view returns (uint256);\n    function rely(address guy) external;\n    function deny(address guy) external;\n\n    // --- BEP20 Data ---\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function version() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n    function nonces(address) external view returns (uint256);\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    // --- EIP712 niceties ---\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    // --- Token ---\n    function transfer(address dst, uint256 wad) external returns (bool);\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n    function mint(address usr, uint256 wad) external;\n    function burn(address usr, uint256 wad) external;\n    function approve(address usr, uint256 wad) external returns (bool);\n\n    // --- Alias ---\n    function push(address usr, uint256 wad) external;\n    function pull(address usr, uint256 wad) external;\n    function move(address src, address dst, uint256 wad) external;\n\n    // --- Approve by signature ---\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/Tokens/VAI/VAIController.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport { VAIControllerErrorReporter } from \"../../Utils/ErrorReporter.sol\";\nimport { Exponential } from \"../../Utils/Exponential.sol\";\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { VToken } from \"../VTokens/VToken.sol\";\nimport { VAIUnitroller } from \"./VAIUnitroller.sol\";\nimport { VAIControllerInterface } from \"./VAIControllerInterface.sol\";\nimport { IVAI } from \"./IVAI.sol\";\nimport { IPrime } from \"../Prime/IPrime.sol\";\nimport { VTokenInterface } from \"../VTokens/VTokenInterfaces.sol\";\nimport { VAIControllerStorageG4 } from \"./VAIControllerStorage.sol\";\n\n/**\n * @title VAI Comptroller\n * @author Venus\n * @notice This is the implementation contract for the VAIUnitroller proxy\n */\ncontract VAIController is VAIControllerInterface, VAIControllerStorageG4, VAIControllerErrorReporter, Exponential {\n    /// @notice Initial index used in interest computations\n    uint256 public constant INITIAL_VAI_MINT_INDEX = 1e18;\n\n    /// poolId for core Pool\n    uint96 public constant CORE_POOL_ID = 0;\n\n    /// @notice Emitted when Comptroller is changed\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /// @notice Emitted when mint for prime holder is changed\n    event MintOnlyForPrimeHolder(bool previousMintEnabledOnlyForPrimeHolder, bool newMintEnabledOnlyForPrimeHolder);\n\n    /// @notice Emitted when Prime is changed\n    event NewPrime(address oldPrime, address newPrime);\n\n    /// @notice Event emitted when VAI is minted\n    event MintVAI(address minter, uint256 mintVAIAmount);\n\n    /// @notice Event emitted when VAI is repaid\n    event RepayVAI(address payer, address borrower, uint256 repayVAIAmount);\n\n    /// @notice Event emitted when a borrow is liquidated\n    event LiquidateVAI(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address vTokenCollateral,\n        uint256 seizeTokens\n    );\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint256 oldTreasuryPercent, uint256 newTreasuryPercent);\n\n    /// @notice Event emitted when VAIs are minted and fee are transferred\n    event MintFee(address minter, uint256 feeAmount);\n\n    /// @notice Emiitted when VAI base rate is changed\n    event NewVAIBaseRate(uint256 oldBaseRateMantissa, uint256 newBaseRateMantissa);\n\n    /// @notice Emiitted when VAI float rate is changed\n    event NewVAIFloatRate(uint256 oldFloatRateMantissa, uint256 newFlatRateMantissa);\n\n    /// @notice Emiitted when VAI receiver address is changed\n    event NewVAIReceiver(address oldReceiver, address newReceiver);\n\n    /// @notice Emiitted when VAI mint cap is changed\n    event NewVAIMintCap(uint256 oldMintCap, uint256 newMintCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when VAI token address is changed by admin\n    event NewVaiToken(address oldVaiToken, address newVaiToken);\n\n    function initialize() external onlyAdmin {\n        require(vaiMintIndex == 0, \"already initialized\");\n\n        vaiMintIndex = INITIAL_VAI_MINT_INDEX;\n        accrualBlockNumber = getBlockNumber();\n        mintCap = type(uint256).max;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    function _become(VAIUnitroller unitroller) external {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n    }\n\n    /**\n     * @notice The mintVAI function mints and transfers VAI from the protocol to the user, and adds a borrow balance.\n     * The amount minted must be less than the user's Account Liquidity and the mint vai limit.\n     * @dev If the Comptroller address is not set, minting is a no-op and the function returns the success code.\n     * @param mintVAIAmount The amount of the VAI to be minted.\n     * @return 0 on success, otherwise an error code\n     */\n    // solhint-disable-next-line code-complexity\n    function mintVAI(uint256 mintVAIAmount) external nonReentrant returns (uint256) {\n        if (address(comptroller) == address(0)) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        require(comptroller.userPoolId(msg.sender) == CORE_POOL_ID, \"VAI mint only allowed in the core Pool\");\n\n        _ensureNonzeroAmount(mintVAIAmount);\n        _ensureNotPaused();\n        accrueVAIInterest();\n\n        uint256 err;\n        address minter = msg.sender;\n        address _vai = vai;\n        uint256 vaiTotalSupply = IVAI(_vai).totalSupply();\n\n        uint256 vaiNewTotalSupply = add_(vaiTotalSupply, mintVAIAmount);\n        require(vaiNewTotalSupply <= mintCap, \"mint cap reached\");\n\n        uint256 accountMintableVAI;\n        (err, accountMintableVAI) = getMintableVAI(minter);\n        require(err == uint256(Error.NO_ERROR), \"could not compute mintable amount\");\n\n        // check that user have sufficient mintableVAI balance\n        require(mintVAIAmount <= accountMintableVAI, \"minting more than allowed\");\n\n        // Calculate the minted balance based on interest index\n        uint256 totalMintedVAI = comptroller.mintedVAIs(minter);\n\n        if (totalMintedVAI > 0) {\n            uint256 repayAmount = getVAIRepayAmount(minter);\n            uint256 remainedAmount = sub_(repayAmount, totalMintedVAI);\n            pastVAIInterest[minter] = add_(pastVAIInterest[minter], remainedAmount);\n            totalMintedVAI = repayAmount;\n        }\n\n        uint256 accountMintVAINew = add_(totalMintedVAI, mintVAIAmount);\n        err = comptroller.setMintedVAIOf(minter, accountMintVAINew);\n        require(err == uint256(Error.NO_ERROR), \"comptroller rejection\");\n\n        uint256 remainedAmount;\n        if (treasuryPercent != 0) {\n            uint256 feeAmount = div_(mul_(mintVAIAmount, treasuryPercent), 1e18);\n            remainedAmount = sub_(mintVAIAmount, feeAmount);\n            IVAI(_vai).mint(treasuryAddress, feeAmount);\n\n            emit MintFee(minter, feeAmount);\n        } else {\n            remainedAmount = mintVAIAmount;\n        }\n\n        IVAI(_vai).mint(minter, remainedAmount);\n        vaiMinterInterestIndex[minter] = vaiMintIndex;\n\n        emit MintVAI(minter, remainedAmount);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice The repay function transfers VAI interest into the protocol and burns the rest,\n     * reducing the borrower's borrow balance. Before repaying VAI, users must first approve\n     * VAIController to access their VAI balance.\n     * @dev If the Comptroller address is not set, repayment is a no-op and the function returns the success code.\n     * @param amount The amount of VAI to be repaid.\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function repayVAI(uint256 amount) external nonReentrant returns (uint256, uint256) {\n        return _repayVAI(msg.sender, amount);\n    }\n\n    /**\n     * @notice The repay on behalf function transfers VAI interest into the protocol and burns the rest,\n     * reducing the borrower's borrow balance. Borrowed VAIs are repaid by another user (possibly the borrower).\n     * Before repaying VAI, the payer must first approve VAIController to access their VAI balance.\n     * @dev If the Comptroller address is not set, repayment is a no-op and the function returns the success code.\n     * @param borrower The account to repay the debt for.\n     * @param amount The amount of VAI to be repaid.\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function repayVAIBehalf(address borrower, uint256 amount) external nonReentrant returns (uint256, uint256) {\n        _ensureNonzeroAddress(borrower);\n        return _repayVAI(borrower, amount);\n    }\n\n    /**\n     * @dev Checks the parameters and the protocol state, accrues interest, and invokes repayVAIFresh.\n     * @dev If the Comptroller address is not set, repayment is a no-op and the function returns the success code.\n     * @param borrower The account to repay the debt for.\n     * @param amount The amount of VAI to be repaid.\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function _repayVAI(address borrower, uint256 amount) internal returns (uint256, uint256) {\n        if (address(comptroller) == address(0)) {\n            return (0, 0);\n        }\n        _ensureNonzeroAmount(amount);\n        _ensureNotPaused();\n\n        accrueVAIInterest();\n        return repayVAIFresh(msg.sender, borrower, amount);\n    }\n\n    /**\n     * @dev Repay VAI, expecting interest to be accrued\n     * @dev Borrowed VAIs are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the VAI\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of VAI being repaid\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function repayVAIFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256, uint256) {\n        (uint256 burn, uint256 partOfCurrentInterest, uint256 partOfPastInterest) = getVAICalculateRepayAmount(\n            borrower,\n            repayAmount\n        );\n\n        IVAI _vai = IVAI(vai);\n        _vai.burn(payer, burn);\n        bool success = _vai.transferFrom(payer, receiver, partOfCurrentInterest);\n        require(success == true, \"failed to transfer VAI fee\");\n\n        uint256 vaiBalanceBorrower = comptroller.mintedVAIs(borrower);\n\n        uint256 accountVAINew = sub_(sub_(vaiBalanceBorrower, burn), partOfPastInterest);\n        pastVAIInterest[borrower] = sub_(pastVAIInterest[borrower], partOfPastInterest);\n\n        uint256 error = comptroller.setMintedVAIOf(borrower, accountVAINew);\n        // We have to revert upon error since side-effects already happened at this point\n        require(error == uint256(Error.NO_ERROR), \"comptroller rejection\");\n\n        uint256 repaidAmount = add_(burn, partOfCurrentInterest);\n        emit RepayVAI(payer, borrower, repaidAmount);\n\n        return (uint256(Error.NO_ERROR), repaidAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the vai minters collateral. The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of vai to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function liquidateVAI(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external nonReentrant returns (uint256, uint256) {\n        _ensureNotPaused();\n\n        uint256 error = vTokenCollateral.accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.VAI_LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateVAIFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateVAIFresh(msg.sender, borrower, repayAmount, vTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral by repay borrowers VAI.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev If the Comptroller address is not set, liquidation is a no-op and the function returns the success code.\n     * @param liquidator The address repaying the VAI and seizing collateral\n     * @param borrower The borrower of this VAI to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the VAI to repay\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol)\n     * @return Actual repayment amount\n     */\n    function liquidateVAIFresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) internal returns (uint256, uint256) {\n        if (address(comptroller) != address(0)) {\n            accrueVAIInterest();\n\n            /* Fail if liquidate not allowed */\n            uint256 allowed = comptroller.liquidateBorrowAllowed(\n                address(this),\n                address(vTokenCollateral),\n                liquidator,\n                borrower,\n                repayAmount\n            );\n            if (allowed != 0) {\n                return (failOpaque(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n            }\n\n            /* Verify vTokenCollateral market's block number equals current block number */\n            //if (vTokenCollateral.accrualBlockNumber() != accrualBlockNumber) {\n            if (vTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n            }\n\n            /* Fail if borrower = liquidator */\n            if (borrower == liquidator) {\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n            }\n\n            /* Fail if repayAmount = 0 */\n            if (repayAmount == 0) {\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n            }\n\n            /* Fail if repayAmount = type(uint256).max */\n            if (repayAmount == type(uint256).max) {\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n            }\n\n            /* Fail if repayVAI fails */\n            (uint256 repayBorrowError, uint256 actualRepayAmount) = repayVAIFresh(liquidator, borrower, repayAmount);\n            if (repayBorrowError != uint256(Error.NO_ERROR)) {\n                return (fail(Error(repayBorrowError), FailureInfo.VAI_LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n            }\n\n            /////////////////////////\n            // EFFECTS & INTERACTIONS\n            // (No safe failures beyond this point)\n\n            /* We calculate the number of collateral tokens that will be seized */\n            (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateVAICalculateSeizeTokens(\n                address(vTokenCollateral),\n                actualRepayAmount\n            );\n            require(\n                amountSeizeError == uint256(Error.NO_ERROR),\n                \"VAI_LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\"\n            );\n\n            /* Revert if borrower collateral token balance < seizeTokens */\n            require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \"VAI_LIQUIDATE_SEIZE_TOO_MUCH\");\n\n            uint256 seizeError;\n            seizeError = vTokenCollateral.seize(liquidator, borrower, seizeTokens);\n\n            /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n            require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n            /* We emit a LiquidateBorrow event */\n            emit LiquidateVAI(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\n\n            /* We call the defense hook */\n            comptroller.liquidateBorrowVerify(\n                address(this),\n                address(vTokenCollateral),\n                liquidator,\n                borrower,\n                actualRepayAmount,\n                seizeTokens\n            );\n\n            return (uint256(Error.NO_ERROR), actualRepayAmount);\n        }\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Sets a new comptroller\n     * @dev Admin function to set a new comptroller\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface comptroller_) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n\n        ComptrollerInterface oldComptroller = comptroller;\n        comptroller = comptroller_;\n        emit NewComptroller(oldComptroller, comptroller_);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the prime token contract address\n     * @param prime_ The new address of the prime token contract\n     */\n    function setPrimeToken(address prime_) external onlyAdmin {\n        emit NewPrime(prime, prime_);\n        prime = prime_;\n    }\n\n    /**\n     * @notice Set the VAI token contract address\n     * @param vai_ The new address of the VAI token contract\n     */\n    function setVAIToken(address vai_) external onlyAdmin {\n        emit NewVaiToken(vai, vai_);\n        vai = vai_;\n    }\n\n    /**\n     * @notice Toggle mint only for prime holder\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function toggleOnlyPrimeHolderMint() external returns (uint256) {\n        _ensureAllowed(\"toggleOnlyPrimeHolderMint()\");\n\n        if (!mintEnabledOnlyForPrimeHolder && prime == address(0)) {\n            return uint256(Error.REJECTION);\n        }\n\n        emit MintOnlyForPrimeHolder(mintEnabledOnlyForPrimeHolder, !mintEnabledOnlyForPrimeHolder);\n        mintEnabledOnlyForPrimeHolder = !mintEnabledOnlyForPrimeHolder;\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account total supply balance.\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountAmountLocalVars {\n        uint256 oErr;\n        MathError mErr;\n        uint256 sumSupply;\n        uint256 marketSupply;\n        uint256 sumBorrowPlusEffects;\n        uint256 vTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Function that returns the amount of VAI a user can mint based on their account liquidy and the VAI mint rate\n     * If mintEnabledOnlyForPrimeHolder is true, only Prime holders are able to mint VAI\n     * @param minter The account to check mintable VAI\n     * @return Error code (0=success, otherwise a failure, see ErrorReporter.sol for details)\n     * @return Mintable amount (with 18 decimals)\n     */\n    // solhint-disable-next-line code-complexity\n    function getMintableVAI(address minter) public view returns (uint256, uint256) {\n        if (mintEnabledOnlyForPrimeHolder && !IPrime(prime).isUserPrimeHolder(minter)) {\n            return (uint256(Error.REJECTION), 0);\n        }\n\n        ResilientOracleInterface oracle = comptroller.oracle();\n        VToken[] memory enteredMarkets = comptroller.getAssetsIn(minter);\n\n        AccountAmountLocalVars memory vars; // Holds all our calculation results\n\n        uint256 accountMintableVAI;\n        uint256 i;\n\n        /**\n         * We use this formula to calculate mintable VAI amount.\n         * totalSupplyAmount * VAIMintRate - (totalBorrowAmount + mintedVAIOf)\n         */\n        uint256 marketsCount = enteredMarkets.length;\n        for (i = 0; i < marketsCount; i++) {\n            (vars.oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = enteredMarkets[i]\n                .getAccountSnapshot(minter);\n            if (vars.oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (uint256(Error.SNAPSHOT_ERROR), 0);\n            }\n            vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(address(enteredMarkets[i]));\n            if (vars.oraclePriceMantissa == 0) {\n                return (uint256(Error.PRICE_ERROR), 0);\n            }\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n            (vars.mErr, vars.tokensToDenom) = mulExp(vars.exchangeRate, vars.oraclePrice);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            // marketSupply = tokensToDenom * vTokenBalance\n            (vars.mErr, vars.marketSupply) = mulScalarTruncate(vars.tokensToDenom, vars.vTokenBalance);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            (, uint256 collateralFactorMantissa, , , , , ) = comptroller.markets(address(enteredMarkets[i]));\n            (vars.mErr, vars.marketSupply) = mulUInt(vars.marketSupply, collateralFactorMantissa);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            (vars.mErr, vars.marketSupply) = divUInt(vars.marketSupply, 1e18);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            (vars.mErr, vars.sumSupply) = addUInt(vars.sumSupply, vars.marketSupply);\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            (vars.mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n            if (vars.mErr != MathError.NO_ERROR) {\n                return (uint256(Error.MATH_ERROR), 0);\n            }\n        }\n\n        uint256 totalMintedVAI = comptroller.mintedVAIs(minter);\n        uint256 repayAmount = 0;\n\n        if (totalMintedVAI > 0) {\n            repayAmount = getVAIRepayAmount(minter);\n        }\n\n        (vars.mErr, vars.sumBorrowPlusEffects) = addUInt(vars.sumBorrowPlusEffects, repayAmount);\n        if (vars.mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0);\n        }\n\n        (vars.mErr, accountMintableVAI) = mulUInt(vars.sumSupply, comptroller.vaiMintRate());\n        require(vars.mErr == MathError.NO_ERROR, \"VAI_MINT_AMOUNT_CALCULATION_FAILED\");\n\n        (vars.mErr, accountMintableVAI) = divUInt(accountMintableVAI, 10000);\n        require(vars.mErr == MathError.NO_ERROR, \"VAI_MINT_AMOUNT_CALCULATION_FAILED\");\n\n        (vars.mErr, accountMintableVAI) = subUInt(accountMintableVAI, vars.sumBorrowPlusEffects);\n        if (vars.mErr != MathError.NO_ERROR) {\n            return (uint256(Error.REJECTION), 0);\n        }\n\n        return (uint256(Error.NO_ERROR), accountMintableVAI);\n    }\n\n    /**\n     * @notice Update treasury data\n     * @param newTreasuryGuardian New Treasury Guardian address\n     * @param newTreasuryAddress New Treasury Address\n     * @param newTreasuryPercent New fee percentage for minting VAI that is sent to the treasury\n     */\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256) {\n        // Check caller is admin\n        if (!(msg.sender == admin || msg.sender == treasuryGuardian)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TREASURY_OWNER_CHECK);\n        }\n\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint256 oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Gets yearly VAI interest rate based on the VAI price\n     * @return uint256 Yearly VAI interest rate\n     */\n    function getVAIRepayRate() public view returns (uint256) {\n        ResilientOracleInterface oracle = comptroller.oracle();\n        MathError mErr;\n\n        if (baseRateMantissa > 0) {\n            if (floatRateMantissa > 0) {\n                uint256 oraclePrice = oracle.getUnderlyingPrice(getVAIAddress());\n                if (1e18 > oraclePrice) {\n                    uint256 delta;\n                    uint256 rate;\n\n                    (mErr, delta) = subUInt(1e18, oraclePrice);\n                    require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n                    (mErr, delta) = mulUInt(delta, floatRateMantissa);\n                    require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n                    (mErr, delta) = divUInt(delta, 1e18);\n                    require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n                    (mErr, rate) = addUInt(delta, baseRateMantissa);\n                    require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n                    return rate;\n                } else {\n                    return baseRateMantissa;\n                }\n            } else {\n                return baseRateMantissa;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get interest rate per block\n     * @return uint256 Interest rate per bock\n     */\n    function getVAIRepayRatePerBlock() public view returns (uint256) {\n        uint256 yearlyRate = getVAIRepayRate();\n\n        MathError mErr;\n        uint256 rate;\n\n        (mErr, rate) = divUInt(yearlyRate, getBlocksPerYear());\n        require(mErr == MathError.NO_ERROR, \"VAI_REPAY_RATE_CALCULATION_FAILED\");\n\n        return rate;\n    }\n\n    /**\n     * @notice Get the last updated interest index for a VAI Minter\n     * @param minter Address of VAI minter\n     * @return uint256 Returns the interest rate index for a minter\n     */\n    function getVAIMinterInterestIndex(address minter) public view returns (uint256) {\n        uint256 storedIndex = vaiMinterInterestIndex[minter];\n        // If the user minted VAI before the stability fee was introduced, accrue\n        // starting from stability fee launch\n        if (storedIndex == 0) {\n            return INITIAL_VAI_MINT_INDEX;\n        }\n        return storedIndex;\n    }\n\n    /**\n     * @notice Get the current total VAI a user needs to repay\n     * @param account The address of the VAI borrower\n     * @return (uint256) The total amount of VAI the user needs to repay\n     */\n    function getVAIRepayAmount(address account) public view returns (uint256) {\n        MathError mErr;\n        uint256 delta;\n\n        uint256 amount = comptroller.mintedVAIs(account);\n        uint256 interest = pastVAIInterest[account];\n        uint256 totalMintedVAI;\n        uint256 newInterest;\n\n        (mErr, totalMintedVAI) = subUInt(amount, interest);\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, delta) = subUInt(vaiMintIndex, getVAIMinterInterestIndex(account));\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, newInterest) = mulUInt(delta, totalMintedVAI);\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, newInterest) = divUInt(newInterest, 1e18);\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, amount) = addUInt(amount, newInterest);\n        require(mErr == MathError.NO_ERROR, \"VAI_TOTAL_REPAY_AMOUNT_CALCULATION_FAILED\");\n\n        return amount;\n    }\n\n    /**\n     * @notice Calculate how much VAI the user needs to repay\n     * @param borrower The address of the VAI borrower\n     * @param repayAmount The amount of VAI being returned\n     * @return Amount of VAI to be burned\n     * @return Amount of VAI the user needs to pay in current interest\n     * @return Amount of VAI the user needs to pay in past interest\n     */\n    function getVAICalculateRepayAmount(\n        address borrower,\n        uint256 repayAmount\n    ) public view returns (uint256, uint256, uint256) {\n        MathError mErr;\n        uint256 totalRepayAmount = getVAIRepayAmount(borrower);\n        uint256 currentInterest;\n\n        (mErr, currentInterest) = subUInt(totalRepayAmount, comptroller.mintedVAIs(borrower));\n        require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n\n        (mErr, currentInterest) = addUInt(pastVAIInterest[borrower], currentInterest);\n        require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n\n        uint256 burn;\n        uint256 partOfCurrentInterest = currentInterest;\n        uint256 partOfPastInterest = pastVAIInterest[borrower];\n\n        if (repayAmount >= totalRepayAmount) {\n            (mErr, burn) = subUInt(totalRepayAmount, currentInterest);\n            require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n        } else {\n            uint256 delta;\n\n            (mErr, delta) = mulUInt(repayAmount, 1e18);\n            require(mErr == MathError.NO_ERROR, \"VAI_PART_CALCULATION_FAILED\");\n\n            (mErr, delta) = divUInt(delta, totalRepayAmount);\n            require(mErr == MathError.NO_ERROR, \"VAI_PART_CALCULATION_FAILED\");\n\n            uint256 totalMintedAmount;\n            (mErr, totalMintedAmount) = subUInt(totalRepayAmount, currentInterest);\n            require(mErr == MathError.NO_ERROR, \"VAI_MINTED_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, burn) = mulUInt(totalMintedAmount, delta);\n            require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, burn) = divUInt(burn, 1e18);\n            require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, partOfCurrentInterest) = mulUInt(currentInterest, delta);\n            require(mErr == MathError.NO_ERROR, \"VAI_CURRENT_INTEREST_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, partOfCurrentInterest) = divUInt(partOfCurrentInterest, 1e18);\n            require(mErr == MathError.NO_ERROR, \"VAI_CURRENT_INTEREST_AMOUNT_CALCULATION_FAILED\");\n\n            (mErr, partOfPastInterest) = mulUInt(pastVAIInterest[borrower], delta);\n            require(mErr == MathError.NO_ERROR, \"VAI_PAST_INTEREST_CALCULATION_FAILED\");\n\n            (mErr, partOfPastInterest) = divUInt(partOfPastInterest, 1e18);\n            require(mErr == MathError.NO_ERROR, \"VAI_PAST_INTEREST_CALCULATION_FAILED\");\n        }\n\n        return (burn, partOfCurrentInterest, partOfPastInterest);\n    }\n\n    /**\n     * @notice Accrue interest on outstanding minted VAI\n     */\n    function accrueVAIInterest() public {\n        MathError mErr;\n        uint256 delta;\n\n        (mErr, delta) = mulUInt(getVAIRepayRatePerBlock(), getBlockNumber() - accrualBlockNumber);\n        require(mErr == MathError.NO_ERROR, \"VAI_INTEREST_ACCRUE_FAILED\");\n\n        (mErr, delta) = addUInt(delta, vaiMintIndex);\n        require(mErr == MathError.NO_ERROR, \"VAI_INTEREST_ACCRUE_FAILED\");\n\n        vaiMintIndex = delta;\n        accrualBlockNumber = getBlockNumber();\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlAddress New address for the access control\n     */\n    function setAccessControl(address newAccessControlAddress) external onlyAdmin {\n        _ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, accessControl);\n    }\n\n    /**\n     * @notice Set VAI borrow base rate\n     * @param newBaseRateMantissa the base rate multiplied by 10**18\n     */\n    function setBaseRate(uint256 newBaseRateMantissa) external {\n        _ensureAllowed(\"setBaseRate(uint256)\");\n\n        uint256 old = baseRateMantissa;\n        baseRateMantissa = newBaseRateMantissa;\n        emit NewVAIBaseRate(old, baseRateMantissa);\n    }\n\n    /**\n     * @notice Set VAI borrow float rate\n     * @param newFloatRateMantissa the VAI float rate multiplied by 10**18\n     */\n    function setFloatRate(uint256 newFloatRateMantissa) external {\n        _ensureAllowed(\"setFloatRate(uint256)\");\n\n        uint256 old = floatRateMantissa;\n        floatRateMantissa = newFloatRateMantissa;\n        emit NewVAIFloatRate(old, floatRateMantissa);\n    }\n\n    /**\n     * @notice Set VAI stability fee receiver address\n     * @param newReceiver the address of the VAI fee receiver\n     */\n    function setReceiver(address newReceiver) external onlyAdmin {\n        _ensureNonzeroAddress(newReceiver);\n\n        address old = receiver;\n        receiver = newReceiver;\n        emit NewVAIReceiver(old, newReceiver);\n    }\n\n    /**\n     * @notice Set VAI mint cap\n     * @param _mintCap the amount of VAI that can be minted\n     */\n    function setMintCap(uint256 _mintCap) external {\n        _ensureAllowed(\"setMintCap(uint256)\");\n\n        uint256 old = mintCap;\n        mintCap = _mintCap;\n        emit NewVAIMintCap(old, _mintCap);\n    }\n\n    function getBlockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    function getBlocksPerYear() public view virtual returns (uint256) {\n        return 42048000; //(24 * 60 * 60 * 365) / 0.75;\n    }\n\n    /**\n     * @notice Return the address of the VAI token\n     * @return The address of VAI\n     */\n    function getVAIAddress() public view virtual returns (address) {\n        return vai;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin can\");\n        _;\n    }\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    function _ensureAllowed(string memory functionSig) private view {\n        require(IAccessControlManagerV8(accessControl).isAllowedToCall(msg.sender, functionSig), \"access denied\");\n    }\n\n    /// @dev Reverts if the protocol is paused\n    function _ensureNotPaused() private view {\n        require(!comptroller.protocolPaused(), \"protocol is paused\");\n    }\n\n    /// @dev Reverts if the passed address is zero\n    function _ensureNonzeroAddress(address someone) private pure {\n        require(someone != address(0), \"can't be zero address\");\n    }\n\n    /// @dev Reverts if the passed amount is zero\n    function _ensureNonzeroAmount(uint256 amount) private pure {\n        require(amount > 0, \"amount can't be zero\");\n    }\n}\n"
    },
    "contracts/Tokens/VAI/VAIControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VTokenInterface } from \"../VTokens/VTokenInterfaces.sol\";\n\ninterface VAIControllerInterface {\n    function mintVAI(uint256 mintVAIAmount) external returns (uint256);\n\n    function repayVAI(uint256 amount) external returns (uint256, uint256);\n\n    function repayVAIBehalf(address borrower, uint256 amount) external returns (uint256, uint256);\n\n    function liquidateVAI(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint256, uint256);\n\n    function getMintableVAI(address minter) external view returns (uint256, uint256);\n\n    function getVAIAddress() external view returns (address);\n\n    function getVAIRepayAmount(address account) external view returns (uint256);\n}\n"
    },
    "contracts/Tokens/VAI/VAIControllerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\n\ncontract VAIUnitrollerAdminStorage {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public vaiControllerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingVAIControllerImplementation;\n}\n\ncontract VAIControllerStorageG1 is VAIUnitrollerAdminStorage {\n    ComptrollerInterface public comptroller;\n\n    struct VenusVAIState {\n        /// @notice The last updated venusVAIMintIndex\n        uint224 index;\n        /// @notice The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice The Venus VAI state\n    VenusVAIState public venusVAIState;\n\n    /// @notice The Venus VAI state initialized\n    bool public isVenusVAIInitialized;\n\n    /// @notice The Venus VAI minter index as of the last time they accrued XVS\n    mapping(address => uint256) public venusVAIMinterIndex;\n}\n\ncontract VAIControllerStorageG2 is VAIControllerStorageG1 {\n    /// @notice Treasury Guardian address\n    address public treasuryGuardian;\n\n    /// @notice Treasury address\n    address public treasuryAddress;\n\n    /// @notice Fee percent of accrued interest with decimal 18\n    uint256 public treasuryPercent;\n\n    /// @notice Guard variable for re-entrancy checks\n    bool internal _notEntered;\n\n    /// @notice The base rate for stability fee\n    uint256 public baseRateMantissa;\n\n    /// @notice The float rate for stability fee\n    uint256 public floatRateMantissa;\n\n    /// @notice The address for VAI interest receiver\n    address public receiver;\n\n    /// @notice Accumulator of the total earned interest rate since the opening of the market. For example: 0.6 (60%)\n    uint256 public vaiMintIndex;\n\n    /// @notice Block number that interest was last accrued at\n    uint256 internal accrualBlockNumber;\n\n    /// @notice Global vaiMintIndex as of the most recent balance-changing action for user\n    mapping(address => uint256) internal vaiMinterInterestIndex;\n\n    /// @notice Tracks the amount of mintedVAI of a user that represents the accrued interest\n    mapping(address => uint256) public pastVAIInterest;\n\n    /// @notice VAI mint cap\n    uint256 public mintCap;\n\n    /// @notice Access control manager address\n    address public accessControl;\n}\n\ncontract VAIControllerStorageG3 is VAIControllerStorageG2 {\n    /// @notice The address of the prime contract. It can be a ZERO address\n    address public prime;\n\n    /// @notice Tracks if minting is enabled only for prime token holders. Only used if prime is set\n    bool public mintEnabledOnlyForPrimeHolder;\n}\n\ncontract VAIControllerStorageG4 is VAIControllerStorageG3 {\n    /// @notice The address of the VAI token\n    address internal vai;\n}\n"
    },
    "contracts/Tokens/VAI/VAIUnitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { VAIControllerErrorReporter } from \"../../Utils/ErrorReporter.sol\";\nimport { VAIUnitrollerAdminStorage } from \"./VAIControllerStorage.sol\";\n\n/**\n * @title VAI Unitroller\n * @author Venus\n * @notice This is the proxy contract for the VAIComptroller\n */\ncontract VAIUnitroller is VAIUnitrollerAdminStorage, VAIControllerErrorReporter {\n    /**\n     * @notice Emitted when pendingVAIControllerImplementation is changed\n     */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n     * @notice Emitted when pendingVAIControllerImplementation is accepted, which means comptroller implementation is updated\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint256) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n        }\n\n        address oldPendingImplementation = pendingVAIControllerImplementation;\n\n        pendingVAIControllerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingVAIControllerImplementation);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptImplementation() public returns (uint256) {\n        // Check caller is pendingImplementation\n        if (msg.sender != pendingVAIControllerImplementation) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = vaiControllerImplementation;\n        address oldPendingImplementation = pendingVAIControllerImplementation;\n\n        vaiControllerImplementation = pendingVAIControllerImplementation;\n\n        pendingVAIControllerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, vaiControllerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingVAIControllerImplementation);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint256) {\n        // Check caller is pendingAdmin\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = vaiControllerImplementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VBep20Interface, VTokenInterface } from \"./VTokenInterfaces.sol\";\nimport { VToken } from \"./VToken.sol\";\n\n/**\n * @title Venus's VBep20 Contract\n * @notice vTokens which wrap an ERC-20 underlying\n * @author Venus\n */\ncontract VBep20 is VToken, VBep20Interface {\n    using SafeERC20 for IERC20;\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits Mint event\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err, ) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param receiver The account which is receiving the vTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits MintBehalf event\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\n        (uint err, ) = mintBehalfInternal(receiver, mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The user on behalf of whom to redeem\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemBehalf(address redeemer, uint redeemTokens) external returns (uint) {\n        require(comptroller.approvedDelegates(redeemer, msg.sender), \"not an approved delegate\");\n\n        return redeemInternal(redeemer, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender redeems underlying assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer, on behalf of whom to redeem\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlyingBehalf(address redeemer, uint redeemAmount) external returns (uint) {\n        require(comptroller.approvedDelegates(redeemer, msg.sender), \"not an approved delegate\");\n\n        return redeemUnderlyingInternal(redeemer, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the borrower using `comptroller.updateDelegate`\n     * @param borrower The borrower, on behalf of whom to borrow.\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrowBehalf(address borrower, uint borrowAmount) external returns (uint) {\n        require(comptroller.approvedDelegates(borrower, msg.sender), \"not an approved delegate\");\n        return borrowInternal(borrower, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrowing account\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emit LiquidateBorrow event on success\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint) {\n        (uint err, ) = liquidateBorrowInternal(borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount of underlying tokens to add as reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits ReservesAdded event\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        // VToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @dev Similar to ERC-20 transfer, but handles tokens that have transfer fees.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     * @param from Sender of the underlying tokens\n     * @param amount Amount of underlying to transfer\n     * @return Actual amount received\n     */\n    function doTransferIn(address from, uint256 amount) internal virtual override returns (uint256) {\n        IERC20 token = IERC20(underlying);\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        uint256 balanceAfter = token.balanceOf(address(this));\n        // Return the amount that was *actually* transferred\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Just a regular ERC-20 transfer, reverts on failure\n     * @param to Receiver of the underlying tokens\n     * @param amount Amount of underlying to transfer\n     */\n    function doTransferOut(address payable to, uint256 amount) internal virtual override {\n        IERC20 token = IERC20(underlying);\n        token.safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Delegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VBep20 } from \"./VBep20.sol\";\nimport { VDelegateInterface } from \"./VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20Delegate Contract\n * @notice VTokens which wrap an EIP-20 underlying and are delegated to\n * @author Venus\n */\ncontract VBep20Delegate is VBep20, VDelegateInterface {\n    /**\n     * @notice Construct an empty delegate\n     */\n    constructor() {}\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) public {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() public {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Delegator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VTokenInterface, VBep20Interface, VDelegatorInterface } from \"./VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20Delegator Contract\n * @notice vTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Venus\n */\nabstract contract VBep20Delegator is VTokenInterface, VBep20Interface, VDelegatorInterface {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address implementation_,\n        bytes memory becomeImplementationData\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"initialize(address,address,address,uint256,string,string,uint8)\",\n                underlying_,\n                comptroller_,\n                interestRateModel_,\n                initialExchangeRateMantissa_,\n                name_,\n                symbol_,\n                decimals_\n            )\n        );\n\n        // New implementations always get set via the settor (post-initialize)\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mint(uint256)\", mintAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"mintBehalf(address,uint256)\", receiver, mintAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying asset\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function borrow(uint borrowAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrower\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"liquidateBorrow(address,uint256,address)\", borrower, repayAmount, vTokenCollateral)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount));\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", src, dst, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (type(uint256).max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  It's absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function seize(address liquidator, address borrower, uint seizeTokens) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"seize(address,address,uint256)\", liquidator, borrower, seizeTokens)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setReserveFactor(uint newReserveFactorMantissa) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. `msg.sender` must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _acceptAdmin() external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and adds reserves by transferring from admin\n     * @param addAmount Amount of reserves to add\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _reduceReserves(uint reduceAmount) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getCash()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (type(uint256).max means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"allowance(address,address)\", owner, spender)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"balanceOf(address)\", owner));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint, uint, uint, uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"getAccountSnapshot(address)\", account)\n        );\n        return abi.decode(data, (uint, uint, uint, uint));\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this vToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    // @custom:access Only callable by admin\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) public {\n        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n\n        if (allowResign) {\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n        }\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves.\n     * @dev This calculates interest accrued from the last checkpointed block\n     *      up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Admin function to set a new comptroller\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and updates the interest rate model using `_setInterestRateModelFresh`\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel The new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel) public override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n        return delegateTo(implementation, data);\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(\n            abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data)\n        );\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"borrowBalanceStored(address)\", account)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Immutable.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VBep20 } from \"./VBep20.sol\";\n\n/**\n * @title Venus's VBep20Immutable Contract\n * @notice VTokens which wrap an EIP-20 underlying and are immutable\n * @author Venus\n */\ncontract VBep20Immutable is VBep20 {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        // Initialize the market\n        initialize(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_\n        );\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBNB.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VToken } from \"./VToken.sol\";\n\n/**\n * @title Venus's vBNB Contract\n * @notice vToken which wraps BNB\n * @author Venus\n */\ncontract VBNB is VToken {\n    /**\n     * @notice Construct a new vBNB money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n    constructor(\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Send BNB to VBNB to mint\n     */\n    receive() external payable {\n        (uint err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Reverts upon any failure\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits Mint event\n    function mint() external payable {\n        (uint err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @dev Reverts upon any failure\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrow() external payable {\n        (uint err, ) = repayBorrowInternal(msg.value);\n        requireNoError(err, \"repayBorrow failed\");\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @dev Reverts upon any failure\n     * @param borrower The account with the debt being payed off\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrowBehalf(address borrower) external payable {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, msg.value);\n        requireNoError(err, \"repayBorrowBehalf failed\");\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev Reverts upon any failure\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     */\n    // @custom:event Emit LiquidateBorrow event on success\n    function liquidateBorrow(address borrower, VToken vTokenCollateral) external payable {\n        (uint err, ) = liquidateBorrowInternal(borrower, msg.value, vTokenCollateral);\n        requireNoError(err, \"liquidateBorrow failed\");\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Perform the actual transfer in, which is a no-op\n     * @param from Address sending the BNB\n     * @param amount Amount of BNB being sent\n     * @return The actual amount of BNB transferred\n     */\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\n        // Sanity checks\n        require(msg.sender == from, \"sender mismatch\");\n        require(msg.value == amount, \"value mismatch\");\n        return amount;\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        /* Send the BNB, with minimal gas and revert on failure */\n        to.transfer(amount);\n    }\n\n    /**\n     * @notice Gets balance of this contract in terms of BNB, before this message\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of BNB owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n        require(err == MathError.NO_ERROR, \"cash prior math error\");\n        return startingBalance;\n    }\n\n    function requireNoError(uint errCode, string memory message) internal pure {\n        if (errCode == uint(Error.NO_ERROR)) {\n            return;\n        }\n\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\n        uint i;\n\n        for (i = 0; i < bytes(message).length; i++) {\n            fullMessage[i] = bytes(message)[i];\n        }\n\n        fullMessage[i + 0] = bytes1(uint8(32));\n        fullMessage[i + 1] = bytes1(uint8(40));\n        fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 10)));\n        fullMessage[i + 3] = bytes1(uint8(48 + (errCode % 10)));\n        fullMessage[i + 4] = bytes1(uint8(41));\n\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport { IProtocolShareReserve } from \"../../external/IProtocolShareReserve.sol\";\nimport { ComptrollerInterface, IComptroller } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { TokenErrorReporter } from \"../../Utils/ErrorReporter.sol\";\nimport { Exponential } from \"../../Utils/Exponential.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VTokenInterface } from \"./VTokenInterfaces.sol\";\nimport { IFlashLoanSimpleReceiver } from \"../../FlashLoan/interfaces/IFlashLoanSimpleReceiver.sol\";\n\n/**\n * @title Venus's vToken Contract\n * @notice Abstract base for vTokens\n * @author Venus\n */\nabstract contract VToken is VTokenInterface, Exponential, TokenErrorReporter {\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    // @custom:event Emits Transfer event\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    // @custom:event Emits Transfer event\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (type(uint256).max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    // @custom:event Emits Approval event on successful approve\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        transferAllowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        ensureNoMathError(mErr);\n        return balance;\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    function seize(\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external override nonReentrant returns (uint) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewPendingAdmin event with old and new admin addresses\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        // Check caller = admin\n        ensureAdmin(msg.sender);\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewAdmin event on successful acceptance\n    // @custom:event Emits NewPendingAdmin event with null new pending admin\n    function _acceptAdmin() external override returns (uint) {\n        // Check caller is pendingAdmin\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = payable(address(0));\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using `_setReserveFactorFresh`\n     * @dev Governor function to accrue interest and set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewReserveFactor event\n    function _setReserveFactor(uint newReserveFactorMantissa_) external override nonReentrant returns (uint) {\n        ensureAllowed(\"_setReserveFactor(uint256)\");\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa_);\n    }\n\n    /**\n     * @notice Sets the address of the access control manager of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlManagerAddress New address for the access control\n     * @return uint 0=success, otherwise will revert\n     */\n    function setAccessControlManager(address newAccessControlManagerAddress) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n\n        ensureNonZeroAddress(newAccessControlManagerAddress);\n\n        emit NewAccessControlManager(accessControlManager, newAccessControlManagerAddress);\n        accessControlManager = newAccessControlManagerAddress;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to protocol share reserve\n     * @param reduceAmount_ Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits ReservesReduced event\n    function _reduceReserves(uint reduceAmount_) external virtual override nonReentrant returns (uint) {\n        ensureAllowed(\"_reduceReserves(uint256)\");\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n\n        // If reserves were reduced in accrueInterest\n        if (reduceReservesBlockNumber == block.number) return (uint(Error.NO_ERROR));\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount_);\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (type(uint256).max means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint, uint, uint, uint) {\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), accountTokens[account], borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this vToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Governance function to set new threshold of block difference after which funds will be sent to the protocol share reserve\n     * @param newReduceReservesBlockDelta_ block difference value\n     */\n    function setReduceReservesBlockDelta(uint256 newReduceReservesBlockDelta_) external {\n        require(newReduceReservesBlockDelta_ > 0, \"Invalid Input\");\n        ensureAllowed(\"setReduceReservesBlockDelta(uint256)\");\n        emit NewReduceReservesBlockDelta(reduceReservesBlockDelta, newReduceReservesBlockDelta_);\n        reduceReservesBlockDelta = newReduceReservesBlockDelta_;\n    }\n\n    /**\n     * @notice Sets protocol share reserve contract address\n     * @param protcolShareReserve_ The address of protocol share reserve contract\n     */\n    function setProtocolShareReserve(address payable protcolShareReserve_) external {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n        ensureNonZeroAddress(protcolShareReserve_);\n        emit NewProtocolShareReserve(protocolShareReserve, protcolShareReserve_);\n        protocolShareReserve = protcolShareReserve_;\n    }\n\n    /**\n     * @notice Transfers the underlying asset to the specified address.\n     * @dev Can only be called by the Comptroller contract. This function performs the actual transfer of the underlying\n     *      asset by calling the `doTransferOut` internal function.\n     *      - The caller must be the Comptroller contract.\n     *      - If the `to` address is not the protocol share reserve, the flashLoanAmount is incremented by the amount transferred out.\n     * @param to The address to which the underlying asset is to be transferred.\n     * @param amount The amount of the underlying asset to transfer.\n     * @custom:error InvalidComptroller is thrown if the caller is not the Comptroller.\n     * @custom:event Emits TransferOutUnderlyingFlashLoan event on successful transfer of amount to receiver\n     */\n\n    function transferOutUnderlyingFlashLoan(address payable to, uint256 amount) external nonReentrant {\n        if (msg.sender != address(comptroller)) {\n            revert InvalidComptroller();\n        }\n\n        if (flashLoanAmount > 0) {\n            revert FlashLoanAlreadyActive();\n        }\n        flashLoanAmount = amount;\n        doTransferOut(to, amount);\n        emit TransferOutUnderlyingFlashLoan(underlying, to, amount);\n    }\n\n    /**\n     * @notice Transfers the underlying asset from the specified address.\n     * @dev Can only be called by the Comptroller contract. This function performs the actual transfer of the underlying\n     *      asset by calling the `doTransferIn` internal function.\n     *      - The caller must be the Comptroller contract.\n     * @param from The address from which the underlying asset is to be transferred.\n     * @param amountRepaid The amount of the underlying asset to transfer.\n     * @param protocolFee The protocol fee amount to be transferred to the protocol share reserve.\n     * @return actualAmountTransferred The actual amount transferred in.\n     * @custom:error InvalidComptroller is thrown if the caller is not the Comptroller.\n     * @custom:event Emits TransferInUnderlyingFlashLoan event on successful transfer of amount from the receiver to the vToken\n     */\n    function transferInUnderlyingFlashLoan(\n        address payable from,\n        uint256 amountRepaid,\n        uint256 protocolFee\n    ) external nonReentrant returns (uint256) {\n        if (msg.sender != address(comptroller)) {\n            revert InvalidComptroller();\n        }\n\n        uint256 actualAmountTransferred = doTransferIn(from, amountRepaid);\n\n        // Transfer protocol fee to protocol share reserve\n        doTransferOut(protocolShareReserve, protocolFee);\n\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\n            address(comptroller),\n            underlying,\n            IProtocolShareReserve.IncomeType.FLASHLOAN\n        );\n        flashLoanAmount = 0;\n\n        emit TransferInUnderlyingFlashLoan(underlying, from, actualAmountTransferred);\n        return actualAmountTransferred;\n    }\n\n    /**\n     * @notice Executes a flashLoan operation.\n     * @dev Transfers the amount to the receiver contract and ensures that the total repayment (amount + fee)\n     *      is returned by the receiver contract after the operation. The function performs checks to ensure the validity\n     *      of parameters, that flashLoan is enabled for the given asset, and that the total repayment is sufficient.\n     *      Reverts on invalid parameters, disabled flashLoans, or insufficient repayment.\n     *      requirements\n     *      - The `receiver` address must not be the zero address.\n     *      - FlashLoans must be enabled for the asset.\n     *      - The `receiver` contract must repay the loan with the appropriate fee.\n     * @param receiver The address of the contract that will receive the flashLoan and execute the operation.\n     * @param amount The amount of asset to be loaned.\n     * @param param Additional encoded parameters passed with the flash loan.\n     * @custom:error FlashLoanNotEnabled is thrown if flash loans are disabled for the asset.\n     * @custom:error SenderNotAuthorized is thrown if the 'msg.sender' is not authorized to execute flash loan.\n     * @custom:error ExecuteFlashLoanFailed is thrown if the receiver contract fails to execute the operation.\n     * @custom:error InsufficientRepayment is thrown if the repayment (amount + fee) is insufficient after the operation.\n     * @custom:event Emits FlashLoanExecuted event on success\n     */\n    function executeFlashLoan(\n        address payable receiver,\n        uint256 amount,\n        bytes calldata param\n    ) external nonReentrant returns (uint256) {\n        if (!isFlashLoanEnabled) {\n            revert FlashLoanNotEnabled();\n        }\n\n        ensureNonZeroAddress(receiver);\n\n        // Check if the caller is authorized to execute flash loans\n        if (!comptroller.authorizedFlashLoan(msg.sender)) {\n            revert SenderNotAuthorized(msg.sender);\n        }\n\n        // Tracks the flashLoan amount before transferring amount to the receiver\n        flashLoanAmount += amount;\n\n        // Transfer the underlying asset to the receiver\n        doTransferOut(receiver, amount);\n\n        uint256 balanceBefore = getCashPrior();\n        (uint256 totalFee, uint256 protocolFee) = calculateFlashLoanFee(amount);\n        uint256 repayAmount = amount + totalFee;\n\n        // Call the execute operation on receiver contract\n        if (!IFlashLoanSimpleReceiver(receiver).executeOperation(underlying, amount, totalFee, msg.sender, param)) {\n            revert ExecuteFlashLoanFailed();\n        }\n\n        doTransferIn(receiver, repayAmount);\n        flashLoanAmount -= amount;\n\n        if ((getCashPrior() - balanceBefore) < repayAmount) revert InsufficientRepayment();\n\n        // Transfer protocol fee to protocol share reserve\n        doTransferOut(protocolShareReserve, protocolFee);\n\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\n            address(comptroller),\n            underlying,\n            IProtocolShareReserve.IncomeType.FLASHLOAN\n        );\n\n        emit FlashLoanExecuted(receiver, underlying, amount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets flash loan status for the market\n     * @param enabled True to enable flash loans, false to disable\n     * @custom:access Only Governance\n     * @custom:event Emits FlashLoanStatusChanged event on success\n     */\n    function setFlashLoanEnabled(bool enabled) external returns (uint256) {\n        ensureAllowed(\"setFlashLoanEnabled(bool)\");\n\n        if (isFlashLoanEnabled != enabled) {\n            emit FlashLoanStatusChanged(isFlashLoanEnabled, enabled);\n            isFlashLoanEnabled = enabled;\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Update flashLoan fee mantissa\n     * @param flashLoanFeeMantissa_  FlashLoan fee, scaled by 1e18\n     * @param flashLoanProtocolShare_ FlashLoan protocol fee share, transferred to protocol share reserve\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     * @custom:access Only Governance\n     * @custom:event Emits FlashLoanFeeUpdated event on success\n     */\n    function setFlashLoanFeeMantissa(\n        uint256 flashLoanFeeMantissa_,\n        uint256 flashLoanProtocolShare_\n    ) external returns (uint256) {\n        // update the signature\n        ensureAllowed(\"setFlashLoanFeeMantissa(uint256,uint256)\");\n\n        emit FlashLoanFeeUpdated(\n            flashLoanFeeMantissa,\n            flashLoanFeeMantissa_,\n            flashLoanProtocolShareMantissa,\n            flashLoanProtocolShare_\n        );\n        flashLoanFeeMantissa = flashLoanFeeMantissa_;\n        flashLoanProtocolShareMantissa = flashLoanProtocolShare_;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        ensureAdmin(msg.sender);\n        require(\n            accrualBlockNumber == 0 && borrowIndex == 0 && (initialExchangeRateMantissa_ > 0),\n            \"market may only be initialized once\"\n        );\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        // Set the comptroller\n        uint ComptrollerErr = _setComptroller(comptroller_);\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = block.number;\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        uint InterestModelErr = _setInterestRateModelFresh(interestRateModel_);\n        require(\n            (ComptrollerErr == uint(Error.NO_ERROR)) && (InterestModelErr == uint(Error.NO_ERROR)),\n            \"comptroller or interest model initialization failed\"\n        );\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     * up to the current block and writes new checkpoint to storage and\n     * reduce spread reserves to protocol share reserve\n     * if currentBlock - reduceReservesBlockNumber >= blockDelta\n     */\n    // @custom:event Emits AccrueInterest event\n    function accrueInterest() public virtual override returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = block.number;\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        ensureNoMathError(mathErr);\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            reservesPrior\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        (mathErr, blockDelta) = subUInt(currentBlockNumber, reduceReservesBlockNumber);\n        ensureNoMathError(mathErr);\n        if (blockDelta >= reduceReservesBlockDelta) {\n            reduceReservesBlockNumber = currentBlockNumber;\n            if (cashPrior < totalReservesNew) {\n                _reduceReservesFresh(cashPrior);\n            } else {\n                _reduceReservesFresh(totalReservesNew);\n            }\n        }\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Admin function to set a new comptroller\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewComptroller event\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint) {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(comptroller, newComptroller);\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Governance function to accrue interest and update the interest rate model\n     * @param newInterestRateModel_ The new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel_) public override returns (uint) {\n        ensureAllowed(\"_setInterestRateModel(address)\");\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors.\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel_);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        ensureNoMathError(err);\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        ensureNoMathError(err);\n        return result;\n    }\n\n    /**\n     * @notice open a debt position for the borrower\n     * @dev This function checks if the borrow is allowed, accrues interest, and updates the borrower's balance.\n     *      It also emits a Borrow event and calls the comptroller's borrowVerify function.\n     *      It reverts if the borrow is not allowed, if the market's block number is not current, or if the protocol has insufficient cash.\n     * @param borrower The address of the borrower\n     * @param borrowAmount The amount of underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     * @custom:error InvalidComptroller is thrown if the caller is not the Comptroller.\n     */\n    function borrowDebtPosition(address borrower, uint borrowAmount) external override returns (uint256) {\n        // Reverts if the caller is not the comptroller\n        if (msg.sender != address(comptroller)) {\n            revert InvalidComptroller();\n        }\n\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors.\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(borrower, payable(address(0)), borrowAmount, false);\n    }\n\n    /**\n     * @notice Calculates the total fee and protocol fee for a flash loan..\n     * @param amount The amount of the flash loan.\n     * @return totalFee The total fee for the flash loan.\n     * @return protocolFee The portion of the total fee allocated to the protocol.\n     */\n    function calculateFlashLoanFee(uint256 amount) public view returns (uint256, uint256) {\n        MathError mErr;\n        uint256 totalFee;\n        uint256 protocolFee;\n\n        (mErr, totalFee) = mulScalarTruncate(Exp({ mantissa: amount }), flashLoanFeeMantissa);\n        ensureNoMathError(mErr);\n\n        (mErr, protocolFee) = mulScalarTruncate(Exp({ mantissa: totalFee }), flashLoanProtocolShareMantissa);\n        ensureNoMathError(mErr);\n\n        return (totalFee, protocolFee);\n    }\n\n    /**\n     * @notice Transfers `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srvTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srvTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srvTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint256).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted mint failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives vTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        ensureNoMathError(vars.mathErr);\n\n        /*\n         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens, vars.accountTokensNew);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param receiver The address of the account which is receiving the vTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfInternal(address receiver, uint mintAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted mintBehalf failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n\n        // mintBehalfFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintBehalfFresh(msg.sender, receiver, mintAmount);\n    }\n\n    /**\n     * @notice Payer supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param payer The address of the account which is paying the underlying token\n     * @param receiver The address of the account which is receiving vToken\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfFresh(address payer, address receiver, uint mintAmount) internal returns (uint, uint) {\n        ensureNonZeroAddress(receiver);\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), receiver, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the payer and the mintAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(payer, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        ensureNoMathError(vars.mathErr);\n\n        /*\n         * We calculate the new total supply of vTokens and receiver token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[receiver] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[receiver], vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[receiver] = vars.accountTokensNew;\n\n        /* We emit a MintBehalf event, and a Transfer event */\n        emit MintBehalf(payer, receiver, vars.actualMintAmount, vars.mintTokens, vars.accountTokensNew);\n        emit Transfer(address(this), receiver, vars.mintTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.mintVerify(address(this), receiver, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Redeemer redeems vTokens in exchange for the underlying assets, transferred to the receiver. Redeemer and receiver can be the same\n     *   address, or different addresses if the receiver was previously approved by the redeemer as a valid delegate (see MarketFacet.updateDelegate)\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemInternal(\n        address redeemer,\n        address payable receiver,\n        uint redeemTokens\n    ) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(redeemer, receiver, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems underlying assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens, if called by a delegate\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemUnderlyingInternal(\n        address redeemer,\n        address payable receiver,\n        uint redeemAmount\n    ) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(redeemer, receiver, 0, redeemAmount);\n    }\n\n    /**\n     * @notice Redeemer redeems vTokens in exchange for the underlying assets, transferred to the receiver. Redeemer and receiver can be the same\n     *   address, or different addresses if the receiver was previously approved by the redeemer as a valid delegate (see MarketFacet.updateDelegate)\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens\n     * @param redeemTokensIn The number of vTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming vTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // solhint-disable-next-line code-complexity\n    function redeemFresh(\n        address redeemer,\n        address payable receiver,\n        uint redeemTokensIn,\n        uint redeemAmountIn\n    ) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        ensureNoMathError(vars.mathErr);\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n                Exp({ mantissa: vars.exchangeRateMantissa }),\n                redeemTokensIn\n            );\n            ensureNoMathError(vars.mathErr);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n                redeemAmountIn,\n                Exp({ mantissa: vars.exchangeRateMantissa })\n            );\n            ensureNoMathError(vars.mathErr);\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_CASH_NOT_AVAILABLE);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /*\n         * We invoke doTransferOut for the receiver and the redeemAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n\n        uint feeAmount;\n        uint remainedAmount;\n        if (IComptroller(address(comptroller)).treasuryPercent() != 0) {\n            (vars.mathErr, feeAmount) = mulUInt(\n                vars.redeemAmount,\n                IComptroller(address(comptroller)).treasuryPercent()\n            );\n            ensureNoMathError(vars.mathErr);\n\n            (vars.mathErr, feeAmount) = divUInt(feeAmount, 1e18);\n            ensureNoMathError(vars.mathErr);\n\n            (vars.mathErr, remainedAmount) = subUInt(vars.redeemAmount, feeAmount);\n            ensureNoMathError(vars.mathErr);\n\n            address payable treasuryAddress = payable(IComptroller(address(comptroller)).treasuryAddress());\n            doTransferOut(treasuryAddress, feeAmount);\n\n            emit RedeemFee(redeemer, feeAmount, vars.redeemTokens);\n        } else {\n            remainedAmount = vars.redeemAmount;\n        }\n\n        doTransferOut(receiver, remainedAmount);\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, remainedAmount, vars.redeemTokens, vars.accountTokensNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Receiver gets the borrow on behalf of the borrower address\n     * @param borrower The borrower, on behalf of whom to borrow\n     * @param receiver The account that would receive the funds (can be the same as the borrower)\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function borrowInternal(\n        address borrower,\n        address payable receiver,\n        uint borrowAmount\n    ) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(borrower, receiver, borrowAmount, true);\n    }\n\n    /**\n     * @notice Receiver gets the borrow on behalf of the borrower address, controls whether to do the transfer\n     * @dev Before calling this function, ensure that the interest has been accrued\n     * @param borrower The borrower, on behalf of whom to borrow\n     * @param receiver The account that would receive the funds (can be the same as the borrower)\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @param shouldTransfer Whether to call doTransferOut for the receiver\n     * @return uint Returns 0 on success, otherwise revert (see ErrorReporter.sol for details).\n     */\n    function borrowFresh(\n        address borrower,\n        address payable receiver,\n        uint borrowAmount,\n        bool shouldTransfer\n    ) internal returns (uint) {\n        /* Revert if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        /* Revert if protocol has insufficient underlying cash */\n        if (shouldTransfer && getCashPrior() < borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        ensureNoMathError(vars.mathErr);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        if (shouldTransfer) {\n            /*\n             * We invoke doTransferOut for the receiver and the borrowAmount.\n             *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n             *  On success, the vToken borrowAmount less of cash.\n             *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n             */\n            doTransferOut(receiver, borrowAmount);\n        }\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrowing account\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer The account paying off the borrow\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return (\n                failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        ensureNoMathError(vars.mathErr);\n\n        /* If repayAmount == type(uint256).max, repayAmount = accountBorrows */\n        if (repayAmount == type(uint256).max) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n\n        error = vTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, vTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    // solhint-disable-next-line code-complexity\n    function liquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) internal returns (uint, uint) {\n        /* Fail if liquidate not allowed */\n        uint allowed = comptroller.liquidateBorrowAllowed(\n            address(this),\n            address(vTokenCollateral),\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n\n        /* Verify vTokenCollateral market's block number equals current block number */\n        if (vTokenCollateral.accrualBlockNumber() != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n\n        /* Fail if repayAmount = type(uint256).max */\n        if (repayAmount == type(uint256).max) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n\n        /* Fail if repayBorrow fails */\n        uint err;\n        uint actualRepayAmount;\n        (err, actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (err != uint(Error.NO_ERROR)) {\n            return (fail(Error(err), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n            borrower,\n            address(this),\n            address(vTokenCollateral),\n            actualRepayAmount\n        );\n\n        require(\n            (err == uint(Error.NO_ERROR)) && (vTokenCollateral.balanceOf(borrower) >= seizeTokens),\n            \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED or LIQUIDATE_SEIZE_TOO_MUCH\"\n        );\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        if (address(vTokenCollateral) == address(this)) {\n            err = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            err = vTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(err == uint(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.liquidateBorrowVerify(\n            address(this),\n            address(vTokenCollateral),\n            liquidator,\n            borrower,\n            actualRepayAmount,\n            seizeTokens\n        );\n\n        return (uint(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another vToken.\n     *  Its absolutely critical to use msg.sender as the seizer vToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed vToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function seizeInternal(\n        address seizerToken,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) internal returns (uint) {\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n     * @dev Governance function to set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and adds reserves by transferring from `msg.sender`\n     * @param addAmount Amount of addition to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n        (error, ) = _addReservesFresh(addAmount);\n        return error;\n    }\n\n    /**\n     * @notice Add reserves by transferring from caller\n     * @dev Requires fresh interest accrual\n     * @param addAmount Amount of addition to reserves\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n     */\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n        // totalReserves + actualAddAmount\n        uint totalReservesNew;\n        uint actualAddAmount;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n        /* Return (NO_ERROR, actualAddAmount) */\n        return (uint(Error.NO_ERROR), actualAddAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to protocol share reserve contract\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _reduceReservesFresh(uint reduceAmount) internal virtual returns (uint) {\n        if (reduceAmount == 0) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReserves - reduceAmount;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(protocolShareReserve, reduceAmount);\n\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\n            address(comptroller),\n            underlying,\n            IProtocolShareReserve.IncomeType.SPREAD\n        );\n\n        emit ReservesReduced(protocolShareReserve, reduceAmount, totalReserves);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Governance function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) internal returns (uint) {\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(interestRateModel, newInterestRateModel);\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint amount) internal virtual returns (uint);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint amount) internal virtual;\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return Tuple of error code and the calculated balance or 0 if error code is non-zero\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the vToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Tuple of error code and calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStoredInternal() internal view virtual returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows + flashLoanAmount - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n                totalCash + flashLoanAmount,\n                totalBorrows,\n                totalReserves\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    function ensureAllowed(string memory functionSig) private view {\n        require(\n            IAccessControlManagerV8(accessControlManager).isAllowedToCall(msg.sender, functionSig),\n            \"access denied\"\n        );\n    }\n\n    function ensureAdmin(address caller_) private view {\n        require(caller_ == admin, \"Unauthorized\");\n    }\n\n    function ensureNoMathError(MathError mErr) private pure {\n        require(mErr == MathError.NO_ERROR, \"math error\");\n    }\n\n    function ensureNonZeroAddress(address address_) private pure {\n        require(address_ != address(0), \"zero address\");\n    }\n\n    function ensureAccrueInterest() private {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal view virtual returns (uint);\n}\n"
    },
    "contracts/Tokens/VTokens/VTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\n\ncontract VTokenStorageBase {\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    bool internal _notEntered;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public decimals;\n\n    /**\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     */\n\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n    /**\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     */\n    uint internal constant reserveFactorMaxMantissa = 1e18;\n\n    /**\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address payable public pendingAdmin;\n\n    /**\n     * @notice Contract which oversees inter-vToken operations\n     */\n    ComptrollerInterface public comptroller;\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModelV8 public interestRateModel;\n\n    /**\n     * @notice Initial exchange rate used when minting the first VTokens (used when totalSupply = 0)\n     */\n    uint internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint public reserveFactorMantissa;\n\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint public borrowIndex;\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint public totalBorrows;\n\n    /**\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint public totalSupply;\n\n    /**\n     * @notice Official record of token balances for each account\n     */\n    mapping(address => uint) internal accountTokens;\n\n    /**\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping(address => mapping(address => uint)) internal transferAllowances;\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     * @notice Underlying asset for this VToken\n     */\n    address public underlying;\n\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n\n    /**\n     * @notice delta block after which reserves will be reduced\n     */\n    uint public reduceReservesBlockDelta;\n\n    /**\n     * @notice last block number at which reserves were reduced\n     */\n    uint public reduceReservesBlockNumber;\n\n    /**\n     * @notice address of protocol share reserve contract\n     */\n    address payable public protocolShareReserve;\n\n    /**\n     * @notice address of accessControlManager\n     */\n\n    address public accessControlManager;\n}\n\ncontract VTokenStorage is VTokenStorageBase {\n    /**\n     * @notice flashLoan is enabled for this market or not\n     */\n    bool public isFlashLoanEnabled;\n\n    /**\n     * @notice total fee percentage collected on flashLoan (scaled by 1e18)\n     */\n    uint256 public flashLoanFeeMantissa;\n\n    /**\n     * @notice fee percentage of flashLoan that goes to protocol (scaled by 1e18)\n     */\n    uint256 public flashLoanProtocolShareMantissa;\n\n    /**\n     * @notice Amount of flashLoan taken by the receiver\n     * @dev This is used to track the amount of flashLoan taken to correctly calculate the exchange rate\n     *      during the flashLoan process. It is added to the total cash when calculating the exchange rate.\n     */\n    uint256 public flashLoanAmount;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n\nabstract contract VTokenInterface is VTokenStorage {\n    /**\n     * @notice Indicator that this is a vToken contract (for inspection)\n     */\n    bool public constant isVToken = true;\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint mintAmount, uint mintTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are minted behalf by payer to receiver\n     */\n    event MintBehalf(address payer, address receiver, uint mintAmount, uint mintTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are redeemed and fee is transferred\n     */\n    event RedeemFee(address redeemer, uint feeAmount, uint redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        address vTokenCollateral,\n        uint seizeTokens\n    );\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Event emitted when pendingAdmin is accepted, which means admin has been updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(\n        InterestRateModelV8 oldInterestRateModel,\n        InterestRateModelV8 newInterestRateModel\n    );\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address protocolShareReserve, uint reduceAmount, uint newTotalReserves);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    /**\n     * @notice Event emitted when block delta for reduce reserves get updated\n     */\n    event NewReduceReservesBlockDelta(uint256 oldReduceReservesBlockDelta, uint256 newReduceReservesBlockDelta);\n\n    /**\n     * @notice Event emitted when address of ProtocolShareReserve contract get updated\n     */\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserve);\n\n    /**\n     * @notice Emitted when access control address is changed by admin\n     */\n    event NewAccessControlManager(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /**\n     * @notice Event emitted when flashLoanEnabled status is changed\n     */\n    event FlashLoanStatusChanged(bool previousStatus, bool newStatus);\n\n    /**\n     * @notice Event emitted when flashLoan is executed\n     */\n    event FlashLoanExecuted(address receiver, address underlying, uint256 amount);\n\n    /**\n     * @notice Event emitted when asset is transferred to receiver\n     */\n    event TransferOutUnderlyingFlashLoan(address asset, address receiver, uint256 amount);\n\n    /**\n     * @notice Event emitted when asset is transferred from sender and verified\n     */\n    event TransferInUnderlyingFlashLoan(address asset, address sender, uint256 amount);\n\n    /**\n     * @notice Event emitted when flashLoan fee mantissa is updated\n     */\n    event FlashLoanFeeUpdated(\n        uint256 oldFlashLoanFeeMantissa,\n        uint256 newFlashLoanFeeMantissa,\n        uint256 oldFlashLoanProtocolShare,\n        uint256 newFlashLoanProtocolShare\n    );\n\n    // @notice Thrown when comptroller is not valid\n    error InvalidComptroller();\n\n    // @notice Thrown when flashLoan is not enabled\n    error FlashLoanNotEnabled();\n\n    // @notice Thrown when the receiver contract execute operation fails\n    error ExecuteFlashLoanFailed();\n\n    // @notice Thrown when the sender is not authorized to do flash loan\n    error SenderNotAuthorized(address sender);\n\n    // @notice Thrown when the repayment is insufficient\n    error InsufficientRepayment();\n\n    // @notice Thrown when there is already an active flashLoan\n    error FlashLoanAlreadyActive();\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint amount) external virtual returns (bool);\n\n    function transferFrom(address src, address dst, uint amount) external virtual returns (bool);\n\n    function approve(address spender, uint amount) external virtual returns (bool);\n\n    function balanceOfUnderlying(address owner) external virtual returns (uint);\n\n    function totalBorrowsCurrent() external virtual returns (uint);\n\n    function borrowBalanceCurrent(address account) external virtual returns (uint);\n\n    function seize(address liquidator, address borrower, uint seizeTokens) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _acceptAdmin() external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setReserveFactor(uint newReserveFactorMantissa) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _reduceReserves(uint reduceAmount) external virtual returns (uint);\n\n    function borrowDebtPosition(address borrower, uint borrowAmount) external virtual returns (uint);\n\n    function balanceOf(address owner) external view virtual returns (uint);\n\n    function allowance(address owner, address spender) external view virtual returns (uint);\n\n    function getAccountSnapshot(address account) external view virtual returns (uint, uint, uint, uint);\n\n    function borrowRatePerBlock() external view virtual returns (uint);\n\n    function supplyRatePerBlock() external view virtual returns (uint);\n\n    function getCash() external view virtual returns (uint);\n\n    function exchangeRateCurrent() public virtual returns (uint);\n\n    function accrueInterest() public virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setComptroller(ComptrollerInterface newComptroller) public virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel) public virtual returns (uint);\n\n    function borrowBalanceStored(address account) public view virtual returns (uint);\n\n    function exchangeRateStored() public view virtual returns (uint);\n}\n\ninterface VBep20Interface {\n    /*** User Interface ***/\n\n    function mint(uint mintAmount) external returns (uint);\n\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint);\n\n    function redeem(uint redeemTokens) external returns (uint);\n\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n\n    function borrow(uint borrowAmount) external returns (uint);\n\n    function repayBorrow(uint repayAmount) external returns (uint);\n\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\n\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint);\n\n    /*** Admin Functions ***/\n\n    function _addReserves(uint addAmount) external returns (uint);\n}\n\ninterface VDelegatorInterface {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) external;\n}\n\ninterface VDelegateInterface {\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) external;\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() external;\n}\n"
    },
    "contracts/Tokens/XVS/IXVS.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IXVS {\n    /// @notice BEP-20 token name for this token\n    function name() external pure returns (string memory);\n\n    /// @notice BEP-20 token symbol for this token\n    function symbol() external pure returns (string memory);\n\n    /// @notice BEP-20 token decimals for this token\n    function decimals() external pure returns (uint8);\n\n    /// @notice Total number of tokens in circulation\n    function totalSupply() external pure returns (uint256);\n\n    /// @notice A record of each accounts delegate\n    function delegates(address) external view returns (address);\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    function checkpoints(address, uint32) external view returns (Checkpoint memory);\n\n    /// @notice The number of checkpoints for each account\n    function numCheckpoints(address) external view returns (uint32);\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    function DOMAIN_TYPEHASH() external pure returns (bytes32);\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    function DELEGATION_TYPEHASH() external pure returns (bytes32);\n\n    /// @notice A record of states for signing / validating signatures\n    function nonces(address) external view returns (uint256);\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard BEP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard BEP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint);\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool);\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint);\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external returns (bool);\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96);\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/Utils/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Careful Math\n * @author Venus\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c;\n        unchecked {\n            c = a * b;\n        }\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            unchecked {\n                return (MathError.NO_ERROR, a - b);\n            }\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c;\n        unchecked {\n            c = a + b;\n        }\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
    },
    "contracts/Utils/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { WeightFunction } from \"../Comptroller/Diamond/interfaces/IFacetBase.sol\";\n\ncontract ComptrollerErrorReporter {\n    /// @notice Thrown when You are already in the selected pool.\n    error AlreadyInSelectedPool();\n\n    /// @notice Thrown when One or more of your assets are not compatible with the selected pool.\n    error IncompatibleBorrowedAssets();\n\n    /// @notice Thrown when Switching to this pool would fail the liquidity check or lead to liquidation.\n    error LiquidityCheckFailed(uint256 errorCode, uint256 shortfall);\n\n    /// @notice Thrown when trying to call pool-specific methods on the Core Pool\n    error InvalidOperationForCorePool();\n\n    /// @notice Thrown when input array lengths do not match\n    error ArrayLengthMismatch();\n\n    /// @notice Thrown when market trying to add in a pool is not listed in the core pool\n    error MarketNotListedInCorePool();\n\n    /// @notice Thrown when market is not set in the _poolMarkets mapping\n    error MarketConfigNotFound();\n\n    /// @notice Thrown when borrowing is not allowed in the selected pool for a given market.\n    error BorrowNotAllowedInPool();\n\n    /// @notice Thrown when trying to remove a market that is not listed in the given pool.\n    error PoolMarketNotFound(uint96 poolId, address vToken);\n\n    /// @notice Thrown when a given pool ID does not exist\n    error PoolDoesNotExist(uint96 poolId);\n\n    /// @notice Thrown when the pool label is empty\n    error EmptyPoolLabel();\n\n    /// @notice Thrown when a vToken is already listed in the specified pool\n    error MarketAlreadyListed(uint96 poolId, address vToken);\n\n    /// @notice Thrown when an invalid weighting strategy is provided\n    error InvalidWeightingStrategy(WeightFunction strategy);\n\n    // @notice Thrown when no assets are requested for flash loan\n    error NoAssetsRequested();\n\n    // @notice Thrown when invalid flash loan parameters are provided\n    error InvalidFlashLoanParams();\n\n    // @notice Thrown when flash loan is not enabled on the vToken\n    error FlashLoanNotEnabled();\n\n    // @notice Thrown when the sender is not authorized to use flashloan onBehalfOf\n    error SenderNotAuthorizedForFlashLoan(address sender);\n\n    // @notice Thrown when the onBehalfOf didn't approve the contract that receives flashloan\n    error NotAnApprovedDelegate();\n\n    // @notice Thrown when an invalid mode is provided\n    error InvalidMode();\n\n    // @notice Thrown when executeOperation on the receiver contract fails\n    error ExecuteFlashLoanFailed();\n\n    // @notice Thrown when the requested amount is zero\n    error InvalidAmount();\n\n    // @notice Thrown when failing to create a debt position in mode 1\n    error FailedToCreateDebtPosition();\n\n    /// @notice Thrown when attempting to interact with an inactive pool\n    error InactivePool(uint96 poolId);\n\n    /// @notice Thrown when repayment amount is insufficient to cover the fee\n    error NotEnoughRepayment(uint256 repaid, uint256 required);\n\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY,\n        INSUFFICIENT_BALANCE_FOR_VAI,\n        MARKET_NOT_COLLATERAL,\n        INVALID_LIQUIDATION_THRESHOLD\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        SET_VAI_MINT_RATE_CHECK,\n        SET_VAICONTROLLER_OWNER_CHECK,\n        SET_MINTED_VAI_REJECTION,\n        SET_TREASURY_OWNER_CHECK,\n        UNLIST_MARKET_NOT_LISTED,\n        SET_LIQUIDATION_THRESHOLD_VALIDATION,\n        COLLATERAL_FACTOR_GREATER_THAN_LIQUIDATION_THRESHOLD\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        COMPTROLLER_REJECTION,\n        COMPTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED,\n        TOKEN_PRICE_ERROR\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_COMPTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_COMPTROLLER_REJECTION,\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_COMPTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_COMPTROLLER_REJECTION,\n        REDEEM_CASH_NOT_AVAILABLE,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_COMPTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COMPTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_COMPTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n        TOKEN_GET_UNDERLYING_PRICE_ERROR,\n        REPAY_VAI_COMPTROLLER_REJECTION,\n        REPAY_VAI_FRESHNESS_CHECK,\n        VAI_MINT_EXCHANGE_CALCULATION_FAILED,\n        SFT_MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract VAIControllerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED, // The sender is not authorized to perform this action.\n        REJECTION, // The action would violate the comptroller, vaicontroller policy.\n        SNAPSHOT_ERROR, // The comptroller could not get the account borrows and exchange rate from the market.\n        PRICE_ERROR, // The comptroller could not obtain a required price of an asset.\n        MATH_ERROR, // A math calculation error occurred.\n        INSUFFICIENT_BALANCE_FOR_VAI // Caller does not have sufficient balance to mint VAI.\n    }\n\n    enum FailureInfo {\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_COMPTROLLER_OWNER_CHECK,\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        VAI_MINT_REJECTION,\n        VAI_BURN_REJECTION,\n        VAI_LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        VAI_LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        VAI_LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        VAI_LIQUIDATE_COMPTROLLER_REJECTION,\n        VAI_LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        VAI_LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        VAI_LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        VAI_LIQUIDATE_FRESHNESS_CHECK,\n        VAI_LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        VAI_LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        VAI_LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        VAI_LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        VAI_LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        VAI_LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        VAI_LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_FEE_CALCULATION_FAILED,\n        SET_TREASURY_OWNER_CHECK\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n"
    },
    "contracts/Utils/Exponential.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { CarefulMath } from \"./CarefulMath.sol\";\nimport { ExponentialNoError } from \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Venus\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: rational }));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({ mantissa: result }));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({ mantissa: result }));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({ mantissa: 0 }));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({ mantissa: product }));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n        return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"
    },
    "contracts/Utils/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint internal constant expScale = 1e18;\n    uint internal constant doubleScale = 1e36;\n    uint internal constant halfExpScale = expScale / 2;\n    uint internal constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) internal pure returns (uint224) {\n        require(n < 2 ** 224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\n    }\n\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: add_(a.mantissa, b.mantissa) });\n    }\n\n    function add_(uint a, uint b) internal pure returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\n    }\n\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\n    }\n\n    function sub_(uint a, uint b) internal pure returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\n    }\n\n    function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: mul_(a.mantissa, b) });\n    }\n\n    function mul_(uint a, Exp memory b) internal pure returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\n    }\n\n    function mul_(Double memory a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: mul_(a.mantissa, b) });\n    }\n\n    function mul_(uint a, Double memory b) internal pure returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) internal pure returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\n    }\n\n    function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: div_(a.mantissa, b) });\n    }\n\n    function div_(uint a, Exp memory b) internal pure returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\n    }\n\n    function div_(Double memory a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(a.mantissa, b) });\n    }\n\n    function div_(uint a, Double memory b) internal pure returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) internal pure returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(mul_(a, doubleScale), b) });\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
