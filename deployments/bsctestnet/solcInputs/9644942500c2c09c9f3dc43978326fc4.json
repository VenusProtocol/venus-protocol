{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IAccessControlManagerV8\n * @author Venus\n * @notice Interface implemented by the `AccessControlManagerV8` contract.\n */\ninterface IAccessControlManagerV8 is IAccessControl {\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\n\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) external;\n\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\n\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) external view returns (bool);\n}\n"
    },
    "@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\ninterface OracleInterface {\n    function getPrice(address asset) external view returns (uint256);\n}\n\ninterface ResilientOracleInterface is OracleInterface {\n    function updatePrice(address vToken) external;\n\n    function updateAssetPrice(address asset) external;\n\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\n}\n\ninterface TwapInterface is OracleInterface {\n    function updateTwap(address asset) external returns (uint256);\n}\n\ninterface BoundValidatorInterface {\n    function validatePriceWithAnchorPrice(\n        address asset,\n        uint256 reporterPrice,\n        uint256 anchorPrice\n    ) external view returns (bool);\n}\n"
    },
    "contracts/Comptroller/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { VAIControllerInterface } from \"../Tokens/VAI/VAIControllerInterface.sol\";\nimport { WeightFunction } from \"./Diamond/interfaces/IFacetBase.sol\";\n\nenum Action {\n    MINT,\n    REDEEM,\n    BORROW,\n    REPAY,\n    SEIZE,\n    LIQUIDATE,\n    TRANSFER,\n    ENTER_MARKET,\n    EXIT_MARKET\n}\n\ninterface ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() external pure returns (bool);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory);\n\n    function exitMarket(address vToken) external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address vToken, address minter, uint mintAmount) external returns (uint);\n\n    function mintVerify(address vToken, address minter, uint mintAmount, uint mintTokens) external;\n\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external returns (uint);\n\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external returns (uint);\n\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external;\n\n    function executeFlashLoan(\n        address payable initiator,\n        address payable receiver,\n        VToken[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata param\n    ) external;\n\n    function repayBorrowAllowed(\n        address vToken,\n        address payer,\n        address borrower,\n        uint repayAmount\n    ) external returns (uint);\n\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint repayAmount,\n        uint borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount\n    ) external returns (uint);\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        uint seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external returns (uint);\n\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external;\n\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external returns (uint);\n\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function setMintedVAIOf(address owner, uint amount) external returns (uint);\n\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint repayAmount\n    ) external view returns (uint, uint);\n\n    function getXVSAddress() external view returns (address);\n\n    function markets(address) external view returns (bool, uint);\n\n    function oracle() external view returns (ResilientOracleInterface);\n\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\n\n    function getAssetsIn(address) external view returns (VToken[] memory);\n\n    function claimVenus(address) external;\n\n    function venusAccrued(address) external view returns (uint);\n\n    function venusSupplySpeeds(address) external view returns (uint);\n\n    function venusBorrowSpeeds(address) external view returns (uint);\n\n    function getAllMarkets() external view returns (VToken[] memory);\n\n    function venusSupplierIndex(address, address) external view returns (uint);\n\n    function venusInitialIndex() external view returns (uint224);\n\n    function venusBorrowerIndex(address, address) external view returns (uint);\n\n    function venusBorrowState(address) external view returns (uint224, uint32);\n\n    function venusSupplyState(address) external view returns (uint224, uint32);\n\n    function approvedDelegates(address borrower, address delegate) external view returns (bool);\n\n    function vaiController() external view returns (VAIControllerInterface);\n\n    function oldLiquidationIncentiveMantissa() external view returns (uint);\n\n    function protocolPaused() external view returns (bool);\n\n    function actionPaused(address market, Action action) external view returns (bool);\n\n    function mintedVAIs(address user) external view returns (uint);\n\n    function vaiMintRate() external view returns (uint);\n\n    function authorizedFlashLoan(address account) external view returns (bool);\n    function delegateAuthorizationFlashloan(\n        address account,\n        address market,\n        address delegate\n    ) external view returns (bool);\n    function userPoolId(address account) external view returns (uint96);\n\n    function getLiquidationIncentive(address vToken) external view returns (uint256);\n\n    function getEffectiveLiquidationIncentive(address account, address vToken) external view returns (uint256);\n\n    function getEffectiveLtvFactor(\n        address account,\n        address vToken,\n        WeightFunction weightingStrategy\n    ) external view returns (uint256);\n\n    function lastPoolId() external view returns (uint96);\n\n    function pools(uint96 poolId) external view returns (string memory label);\n\n    function getPoolVTokens(uint96 poolId) external view returns (address[] memory);\n\n    function poolMarkets(\n        uint96 poolId,\n        address vToken\n    )\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 maxLiquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        );\n}\n\ninterface IVAIVault {\n    function updatePendingRewards() external;\n}\n\ninterface IComptroller {\n    function liquidationIncentiveMantissa() external view returns (uint);\n\n    /*** Treasury Data ***/\n    function treasuryAddress() external view returns (address);\n\n    function treasuryPercent() external view returns (uint);\n}\n"
    },
    "contracts/Comptroller/ComptrollerLensInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { WeightFunction } from \"./Diamond/interfaces/IFacetBase.sol\";\n\ninterface ComptrollerLensInterface {\n    function liquidateCalculateSeizeTokens(\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address comptroller,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function liquidateVAICalculateSeizeTokens(\n        address comptroller,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n\n    function getHypotheticalAccountLiquidity(\n        address comptroller,\n        address account,\n        VToken vTokenModify,\n        uint redeemTokens,\n        uint borrowAmount,\n        WeightFunction weightingStrategy\n    ) external view returns (uint, uint, uint);\n}\n"
    },
    "contracts/Comptroller/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { PoolMarketId } from \"./Types/PoolMarketId.sol\";\n\nimport { VToken } from \"../Tokens/VTokens/VToken.sol\";\nimport { VAIControllerInterface } from \"../Tokens/VAI/VAIControllerInterface.sol\";\nimport { ComptrollerLensInterface } from \"./ComptrollerLensInterface.sol\";\nimport { IPrime } from \"../Tokens/Prime/IPrime.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public comptrollerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    ResilientOracleInterface public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives (deprecated)\n     */\n    uint256 public oldLiquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint256 public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => VToken[]) public accountAssets;\n\n    struct Market {\n        /// @notice Whether or not this market is listed\n        bool isListed;\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /// @notice Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n        /// @notice Whether or not this market receives XVS\n        bool isVenus;\n        /**\n         * @notice Multiplier representing the collateralization after which the borrow is eligible\n         * for liquidation. For instance, 0.8 liquidate when the borrow is 80% of collateral\n         * value. Must be between 0 and collateral factor, stored as a mantissa.\n         */\n        uint256 liquidationThresholdMantissa;\n        /// @notice discount on collateral that a liquidator receives when liquidating a borrow in this market\n        uint256 liquidationIncentiveMantissa;\n        /// @notice The pool ID this market is associated with, Used to support pools/emodes\n        uint96 poolId;\n        /// @notice Flag  to restrict borrowing in certain pools/emodes.\n        bool isBorrowAllowed;\n    }\n\n    /**\n     * @notice Mapping of PoolMarketId -> Market metadata\n     * Underlying key layout: First 12 bytes (96 bits) represent the poolId, last 20 bytes the vToken address\n     */\n    mapping(PoolMarketId => Market) internal _poolMarkets;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    address public pauseGuardian;\n\n    /// @notice Whether minting is paused (deprecated, superseded by actionPaused)\n    bool private _mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool private _borrowGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal transferGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal seizeGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal borrowGuardianPaused;\n\n    struct VenusMarketState {\n        /// @notice The market's last updated venusBorrowIndex or venusSupplyIndex\n        uint224 index;\n        /// @notice The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice A list of all markets\n    VToken[] public allMarkets;\n\n    /// @notice The rate at which the flywheel distributes XVS, per block\n    uint256 internal venusRate;\n\n    /// @notice The portion of venusRate that each market currently receives\n    mapping(address => uint256) internal venusSpeeds;\n\n    /// @notice The Venus market supply state for each market\n    mapping(address => VenusMarketState) public venusSupplyState;\n\n    /// @notice The Venus market borrow state for each market\n    mapping(address => VenusMarketState) public venusBorrowState;\n\n    /// @notice The Venus supply index for each market for each supplier as of the last time they accrued XVS\n    mapping(address => mapping(address => uint256)) public venusSupplierIndex;\n\n    /// @notice The Venus borrow index for each market for each borrower as of the last time they accrued XVS\n    mapping(address => mapping(address => uint256)) public venusBorrowerIndex;\n\n    /// @notice The XVS accrued but not yet transferred to each user\n    mapping(address => uint256) public venusAccrued;\n\n    /// @notice The Address of VAIController\n    VAIControllerInterface public vaiController;\n\n    /// @notice The minted VAI amount to each user\n    mapping(address => uint256) public mintedVAIs;\n\n    /// @notice VAI Mint Rate as a percentage\n    uint256 public vaiMintRate;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    bool public mintVAIGuardianPaused;\n    bool public repayVAIGuardianPaused;\n\n    /**\n     * @notice Pause/Unpause whole protocol actions\n     */\n    bool public protocolPaused;\n\n    /// @notice The rate at which the flywheel distributes XVS to VAI Minters, per block (deprecated)\n    uint256 private venusVAIRate;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    /// @notice The rate at which the flywheel distributes XVS to VAI Vault, per block\n    uint256 public venusVAIVaultRate;\n\n    // address of VAI Vault\n    address public vaiVaultAddress;\n\n    // start block of release to VAI Vault\n    uint256 public releaseStartBlock;\n\n    // minimum release amount to VAI Vault\n    uint256 public minReleaseAmount;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address.\n    mapping(address => uint256) public borrowCaps;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n    /// @notice Treasury Guardian address\n    address public treasuryGuardian;\n\n    /// @notice Treasury address\n    address public treasuryAddress;\n\n    /// @notice Fee percent of accrued interest with decimal 18\n    uint256 public treasuryPercent;\n}\n\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\n    /// @notice The portion of XVS that each contributor receives per block (deprecated)\n    mapping(address => uint256) private venusContributorSpeeds;\n\n    /// @notice Last block at which a contributor's XVS rewards have been allocated (deprecated)\n    mapping(address => uint256) private lastContributorBlock;\n}\n\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\n    address public liquidatorContract;\n}\n\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\n    ComptrollerLensInterface public comptrollerLens;\n}\n\ncontract ComptrollerV8Storage is ComptrollerV7Storage {\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\n    mapping(address => uint256) public supplyCaps;\n}\n\ncontract ComptrollerV9Storage is ComptrollerV8Storage {\n    /// @notice AccessControlManager address\n    address internal accessControl;\n\n    /// @notice True if a certain action is paused on a certain market\n    mapping(address => mapping(uint256 => bool)) internal _actionPaused;\n}\n\ncontract ComptrollerV10Storage is ComptrollerV9Storage {\n    /// @notice The rate at which venus is distributed to the corresponding borrow market (per block)\n    mapping(address => uint256) public venusBorrowSpeeds;\n\n    /// @notice The rate at which venus is distributed to the corresponding supply market (per block)\n    mapping(address => uint256) public venusSupplySpeeds;\n}\n\ncontract ComptrollerV11Storage is ComptrollerV10Storage {\n    /// @notice Whether the delegate is allowed to borrow or redeem on behalf of the user\n    //mapping(address user => mapping (address delegate => bool approved)) public approvedDelegates;\n    mapping(address => mapping(address => bool)) public approvedDelegates;\n}\n\ncontract ComptrollerV12Storage is ComptrollerV11Storage {\n    /// @notice Whether forced liquidation is enabled for all users borrowing in a certain market\n    mapping(address => bool) public isForcedLiquidationEnabled;\n}\n\ncontract ComptrollerV13Storage is ComptrollerV12Storage {\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in _facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in _facetAddresses array\n    }\n\n    mapping(bytes4 => FacetAddressAndPosition) internal _selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) internal _facetFunctionSelectors;\n    // facet addresses\n    address[] internal _facetAddresses;\n}\n\ncontract ComptrollerV14Storage is ComptrollerV13Storage {\n    /// @notice Prime token address\n    IPrime public prime;\n}\n\ncontract ComptrollerV15Storage is ComptrollerV14Storage {\n    /// @notice Whether forced liquidation is enabled for the borrows of a user in a market\n    mapping(address user => mapping(address market => bool)) public isForcedLiquidationEnabledForUser;\n}\n\ncontract ComptrollerV16Storage is ComptrollerV15Storage {\n    /// @notice The XVS token contract address\n    address internal xvs;\n\n    /// @notice The XVS vToken contract address\n    address internal xvsVToken;\n}\n\ncontract ComptrollerV17Storage is ComptrollerV16Storage {\n    struct PoolData {\n        /// @notice label for the pool\n        string label;\n        /// @notice List of vToken addresses associated with this pool\n        address[] vTokens;\n    }\n\n    /**\n     * @notice Tracks the selected pool for each user.\n     * @dev\n     * - The mapping stores the pool ID (`uint96`) that each user (`address`) is currently in.\n     * - A value of `0` represents the default core pool (legacy behavior).\n     */\n    mapping(address => uint96) public userPoolId;\n\n    /**\n     * @notice Mapping of pool ID to its corresponding metadata and configuration\n     * @dev Pool IDs are unique and incremented via `nextPoolId` when a new pool is created\n     */\n    mapping(uint96 => PoolData) public pools;\n\n    /**\n     * @notice Counter used to generate unique pool IDs\n     * @dev Increments each time a pool is created; `poolId = 0` is reserved for the core pool\n     */\n    uint96 public lastPoolId;\n\n    /// @notice Mapping of accounts authorized to execute flash loans\n    mapping(address => bool) public authorizedFlashLoan;\n\n    struct FlashLoanData {\n        uint256[] protocolFees;\n        uint256[] supplierFees;\n        uint256[] totalFees;\n        uint256[] balanceAfterTransfer;\n        uint256[] actualRepayments;\n        uint256[] remainingDebts;\n    }\n    /// @notice Mapping to store delegate authorization for flash loans\n    mapping(address /* delegator */ => mapping(address /* market */ => mapping(address /* sender */ => bool)))\n        public delegateAuthorizationFlashloan;\n}\n"
    },
    "contracts/Comptroller/Diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport { Unitroller } from \"../Unitroller.sol\";\nimport { ComptrollerV17Storage } from \"../ComptrollerStorage.sol\";\n\n/**\n * @title Diamond\n * @author Venus\n * @notice This contract contains functions related to facets\n */\ncontract Diamond is IDiamondCut, ComptrollerV17Storage {\n    /// @notice Emitted when functions are added, replaced or removed to facets\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut);\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /**\n     * @notice Call _acceptImplementation to accept the diamond proxy as new implementaion\n     * @param unitroller Address of the unitroller\n     */\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    /**\n     * @notice To add function selectors to the facet's mapping\n     * @dev Allows the contract admin to add function selectors\n     * @param diamondCut_ IDiamondCut contains facets address, action and function selectors\n     */\n    function diamondCut(IDiamondCut.FacetCut[] memory diamondCut_) public {\n        require(msg.sender == admin, \"only unitroller admin can\");\n        libDiamondCut(diamondCut_);\n    }\n\n    /**\n     * @notice Get all function selectors mapped to the facet address\n     * @param facet Address of the facet\n     * @return selectors Array of function selectors\n     */\n    function facetFunctionSelectors(address facet) external view returns (bytes4[] memory) {\n        return _facetFunctionSelectors[facet].functionSelectors;\n    }\n\n    /**\n     * @notice Get facet position in the _facetFunctionSelectors through facet address\n     * @param facet Address of the facet\n     * @return Position of the facet\n     */\n    function facetPosition(address facet) external view returns (uint256) {\n        return _facetFunctionSelectors[facet].facetAddressPosition;\n    }\n\n    /**\n     * @notice Get all facet addresses\n     * @return facetAddresses Array of facet addresses\n     */\n    function facetAddresses() external view returns (address[] memory) {\n        return _facetAddresses;\n    }\n\n    /**\n     * @notice Get facet address and position through function selector\n     * @param functionSelector function selector\n     * @return FacetAddressAndPosition facet address and position\n     */\n    function facetAddress(\n        bytes4 functionSelector\n    ) external view returns (ComptrollerV17Storage.FacetAddressAndPosition memory) {\n        return _selectorToFacetAndPosition[functionSelector];\n    }\n\n    /**\n     * @notice Get all facets address and their function selector\n     * @return facets_ Array of Facet\n     */\n    function facets() external view returns (Facet[] memory) {\n        uint256 facetsLength = _facetAddresses.length;\n        Facet[] memory facets_ = new Facet[](facetsLength);\n        for (uint256 i; i < facetsLength; ++i) {\n            address facet = _facetAddresses[i];\n            facets_[i].facetAddress = facet;\n            facets_[i].functionSelectors = _facetFunctionSelectors[facet].functionSelectors;\n        }\n        return facets_;\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping\n     * @param diamondCut_ IDiamondCut contains facets address, action and function selectors\n     */\n    function libDiamondCut(IDiamondCut.FacetCut[] memory diamondCut_) internal {\n        uint256 diamondCutLength = diamondCut_.length;\n        for (uint256 facetIndex; facetIndex < diamondCutLength; ++facetIndex) {\n            IDiamondCut.FacetCutAction action = diamondCut_[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(diamondCut_[facetIndex].facetAddress, diamondCut_[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(diamondCut_);\n    }\n\n    /**\n     * @notice Add function selectors to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to add in the mapping\n     */\n    function addFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        require(functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(_facetFunctionSelectors[facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(facetAddress);\n        }\n        uint256 functionSelectorsLength = functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(selector, selectorPosition, facetAddress);\n            ++selectorPosition;\n        }\n    }\n\n    /**\n     * @notice Replace facet's address mapping for function selectors i.e selectors already associate to any other existing facet\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to replace in the mapping\n     */\n    function replaceFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        require(functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(_facetFunctionSelectors[facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(facetAddress);\n        }\n        uint256 functionSelectorsLength = functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            addFunction(selector, selectorPosition, facetAddress);\n            ++selectorPosition;\n        }\n    }\n\n    /**\n     * @notice Remove function selectors to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param functionSelectors Array of function selectors need to remove in the mapping\n     */\n    function removeFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {\n        uint256 functionSelectorsLength = functionSelectors.length;\n        require(functionSelectorsLength != 0, \"LibDiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and revert\n        require(facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; ++selectorIndex) {\n            bytes4 selector = functionSelectors[selectorIndex];\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    /**\n     * @notice Add new facet to the proxy\n     * @param facetAddress Address of the facet\n     */\n    function addFacet(address facetAddress) internal {\n        enforceHasContractCode(facetAddress, \"Diamond: New facet has no code\");\n        _facetFunctionSelectors[facetAddress].facetAddressPosition = _facetAddresses.length;\n        _facetAddresses.push(facetAddress);\n    }\n\n    /**\n     * @notice Add function selector to the facet's address mapping\n     * @param selector funciton selector need to be added\n     * @param selectorPosition funciton selector position\n     * @param facetAddress Address of the facet\n     */\n    function addFunction(bytes4 selector, uint96 selectorPosition, address facetAddress) internal {\n        _selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n        _facetFunctionSelectors[facetAddress].functionSelectors.push(selector);\n        _selectorToFacetAndPosition[selector].facetAddress = facetAddress;\n    }\n\n    /**\n     * @notice Remove function selector to the facet's address mapping\n     * @param facetAddress Address of the facet\n     * @param selector function selectors need to remove in the mapping\n     */\n    function removeFunction(address facetAddress, bytes4 selector) internal {\n        require(facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = _selectorToFacetAndPosition[selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = _facetFunctionSelectors[facetAddress].functionSelectors.length - 1;\n        // if not the same then replace selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = _facetFunctionSelectors[facetAddress].functionSelectors[lastSelectorPosition];\n            _facetFunctionSelectors[facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            _selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        _facetFunctionSelectors[facetAddress].functionSelectors.pop();\n        delete _selectorToFacetAndPosition[selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = _facetAddresses.length - 1;\n            uint256 facetAddressPosition = _facetFunctionSelectors[facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = _facetAddresses[lastFacetAddressPosition];\n                _facetAddresses[facetAddressPosition] = lastFacetAddress;\n                _facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            _facetAddresses.pop();\n            delete _facetFunctionSelectors[facetAddress];\n        }\n    }\n\n    /**\n     * @dev Ensure that the given address has contract code deployed\n     * @param _contract The address to check for contract code\n     * @param _errorMessage The error message to display if the contract code is not deployed\n     */\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize != 0, _errorMessage);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external {\n        address facet = _selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute public function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/DiamondConsolidated.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { MarketFacet } from \"./facets/MarketFacet.sol\";\nimport { PolicyFacet } from \"./facets/PolicyFacet.sol\";\nimport { RewardFacet } from \"./facets/RewardFacet.sol\";\nimport { SetterFacet } from \"./facets/SetterFacet.sol\";\nimport { Diamond } from \"./Diamond.sol\";\n\n/**\n * @title DiamondConsolidated\n * @author Venus\n * @notice This contract contains the functions defined in the different facets of the Diamond, plus the getters to the public variables.\n * This contract cannot be deployed, due to its size. Its main purpose is to allow the easy generation of an ABI and the typechain to interact with the\n * Unitroller contract in a simple way\n */\ncontract DiamondConsolidated is Diamond, MarketFacet, PolicyFacet, RewardFacet, SetterFacet {}\n"
    },
    "contracts/Comptroller/Diamond/facets/FacetBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { ComptrollerErrorReporter } from \"../../../Utils/ErrorReporter.sol\";\nimport { ExponentialNoError } from \"../../../Utils/ExponentialNoError.sol\";\nimport { IVAIVault, Action } from \"../../../Comptroller/ComptrollerInterface.sol\";\nimport { ComptrollerV17Storage } from \"../../../Comptroller/ComptrollerStorage.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\nimport { IFacetBase, WeightFunction } from \"../interfaces/IFacetBase.sol\";\n\n/**\n * @title FacetBase\n * @author Venus\n * @notice This facet contract contains functions related to access and checks\n */\ncontract FacetBase is IFacetBase, ComptrollerV17Storage, ExponentialNoError, ComptrollerErrorReporter {\n    using SafeERC20 for IERC20;\n\n    /// @notice The initial Venus index for a market\n    uint224 public constant venusInitialIndex = 1e36;\n    // poolId for core Pool\n    uint96 public constant corePoolId = 0;\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(VToken indexed vToken, address indexed account);\n\n    /// @notice Emitted when XVS is distributed to VAI Vault\n    event DistributedVAIVaultVenus(uint256 amount);\n\n    /// @notice Reverts if the protocol is paused\n    function checkProtocolPauseState() internal view {\n        require(!protocolPaused, \"protocol is paused\");\n    }\n\n    /// @notice Reverts if a certain action is paused on a market\n    function checkActionPauseState(address market, Action action) internal view {\n        require(!actionPaused(market, action), \"action is paused\");\n    }\n\n    /// @notice Reverts if the caller is not admin\n    function ensureAdmin() internal view {\n        require(msg.sender == admin, \"only admin can\");\n    }\n\n    /// @notice Checks the passed address is nonzero\n    function ensureNonzeroAddress(address someone) internal pure {\n        require(someone != address(0), \"can't be zero address\");\n    }\n\n    /// @notice Reverts if the market is not listed\n    function ensureListed(Market storage market) internal view {\n        require(market.isListed, \"market not listed\");\n    }\n\n    /// @notice Reverts if the caller is neither admin nor the passed address\n    function ensureAdminOr(address privilegedAddress) internal view {\n        require(msg.sender == admin || msg.sender == privilegedAddress, \"access denied\");\n    }\n\n    /// @notice Checks the caller is allowed to call the specified fuction\n    function ensureAllowed(string memory functionSig) internal view {\n        require(IAccessControlManagerV8(accessControl).isAllowedToCall(msg.sender, functionSig), \"access denied\");\n    }\n\n    /**\n     * @notice Checks if a certain action is paused on a market\n     * @param action Action id\n     * @param market vToken address\n     */\n    function actionPaused(address market, Action action) public view returns (bool) {\n        return _actionPaused[market][uint256(action)];\n    }\n\n    /**\n     * @notice Get the latest block number\n     */\n    function getBlockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Get the latest block number with the safe32 check\n     */\n    function getBlockNumberAsUint32() internal view returns (uint32) {\n        return safe32(getBlockNumber(), \"block # > 32 bits\");\n    }\n\n    /**\n     * @notice Transfer XVS to VAI Vault\n     */\n    function releaseToVault() internal {\n        if (releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\n            return;\n        }\n\n        IERC20 xvs_ = IERC20(xvs);\n\n        uint256 xvsBalance = xvs_.balanceOf(address(this));\n        if (xvsBalance == 0) {\n            return;\n        }\n\n        uint256 actualAmount;\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\n        uint256 releaseAmount_ = mul_(venusVAIVaultRate, deltaBlocks);\n\n        if (xvsBalance >= releaseAmount_) {\n            actualAmount = releaseAmount_;\n        } else {\n            actualAmount = xvsBalance;\n        }\n\n        if (actualAmount < minReleaseAmount) {\n            return;\n        }\n\n        releaseStartBlock = getBlockNumber();\n\n        xvs_.safeTransfer(vaiVaultAddress, actualAmount);\n        emit DistributedVAIVaultVenus(actualAmount);\n\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @param weightingStrategy The weighting strategy to use:\n     *                          - `WeightFunction.USE_COLLATERAL_FACTOR` to use collateral factor\n     *                          - `WeightFunction.USE_LIQUIDATION_THRESHOLD` to use liquidation threshold\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        VToken vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount,\n        WeightFunction weightingStrategy\n    ) internal view returns (Error, uint256, uint256) {\n        (uint256 err, uint256 liquidity, uint256 shortfall) = comptrollerLens.getHypotheticalAccountLiquidity(\n            address(this),\n            account,\n            vTokenModify,\n            redeemTokens,\n            borrowAmount,\n            weightingStrategy\n        );\n        return (Error(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param vToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\n        checkActionPauseState(address(vToken), Action.ENTER_MARKET);\n        Market storage marketToJoin = _poolMarkets[getCorePoolMarketIndex(address(vToken))];\n        ensureListed(marketToJoin);\n        if (marketToJoin.accountMembership[borrower]) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(vToken);\n\n        emit MarketEntered(vToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Checks for the user is allowed to redeem tokens\n     * @param vToken Address of the market\n     * @param redeemer Address of the user\n     * @param redeemTokens Amount of tokens to redeem\n     * @return Success indicator for redeem is allowed or not\n     */\n    function redeemAllowedInternal(\n        address vToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        ensureListed(getCorePoolMarket(vToken));\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!getCorePoolMarket(vToken).accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            VToken(vToken),\n            redeemTokens,\n            0,\n            WeightFunction.USE_COLLATERAL_FACTOR\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall != 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Returns the XVS address\n     * @return The address of XVS token\n     */\n    function getXVSAddress() external view returns (address) {\n        return xvs;\n    }\n\n    /**\n     * @notice Returns the market index for a given vToken\n     * @dev Computes a unique key for a (poolId, market) pair used in the `_poolMarkets` mapping.\n     * - For the core pool (`poolId == 0`), this results in the address being left-padded to 32 bytes,\n     *   maintaining backward compatibility with legacy mappings.\n     * - For other pools, packs the `poolId` and `market` address into a single `bytes32` key,\n     *   The first 96 bits are used for the `poolId`, and the remaining 160 bits for the `market` address.\n     * @param poolId The ID of the pool.\n     * @param vToken The address of the market (vToken).\n     * @return A `bytes32` key that uniquely represents the (poolId, market) pair.\n     */\n    function getPoolMarketIndex(uint96 poolId, address vToken) public pure returns (PoolMarketId) {\n        return PoolMarketId.wrap(bytes32((uint256(poolId) << 160) | uint160(vToken)));\n    }\n\n    /**\n     * @dev Returns the market index for a given vToken in the Core Pool (poolId = 0)\n     * @param vToken The address of the vToken\n     * @return The bytes32 key used to index into the _poolMarkets mapping for the Core Pool\n     */\n    function getCorePoolMarketIndex(address vToken) internal pure returns (PoolMarketId) {\n        return getPoolMarketIndex(corePoolId, vToken);\n    }\n\n    /**\n     * @notice Returns the Market struct for a given vToken in the core pool\n     * @param vToken The vToken address for which the market details are requested\n     * @return Market data corresponding to the given vToken\n     */\n    function getCorePoolMarket(address vToken) internal view returns (Market storage) {\n        return _poolMarkets[getCorePoolMarketIndex(address(vToken))];\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @param account The account to get liquidity for\n     * @param weightingStrategy The weighting strategy to use:\n     *                          - `WeightFunction.USE_COLLATERAL_FACTOR` to use collateral factor\n     *                          - `WeightFunction.USE_LIQUIDATION_THRESHOLD` to use liquidation threshold\n     * @return (possible error code (semi-opaque),\n     * account liquidity in excess of collateral requirements,\n     * account shortfall below collateral requirements)\n     */\n    function _getAccountLiquidity(\n        address account,\n        WeightFunction weightingStrategy\n    ) internal view returns (uint256, uint256, uint256) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(address(0)),\n            0,\n            0,\n            weightingStrategy\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/MarketFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IMarketFacet } from \"../interfaces/IMarketFacet.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\nimport { WeightFunction } from \"../interfaces/IFacetBase.sol\";\n\n/**\n * @title MarketFacet\n * @author Venus\n * @dev This facet contains all the methods related to the market's management in the pool\n * @notice This facet contract contains functions regarding markets\n */\ncontract MarketFacet is IMarketFacet, FacetBase {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(VToken indexed vToken);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(VToken indexed vToken, address indexed account);\n\n    /// @notice Emitted when the borrowing or redeeming delegate rights are updated for an account\n    event DelegateUpdated(address indexed approver, address indexed delegate, bool approved);\n\n    /// @notice Emitted when an admin unlists a market\n    event MarketUnlisted(address indexed vToken);\n\n    /// @notice Emitted when a market is initialized in a pool\n    event PoolMarketInitialized(uint96 indexed poolId, address indexed market);\n\n    /// @notice Emitted when a user enters or exits a pool (poolId = 0 means exit)\n    event PoolSelected(address indexed account, uint96 previousPoolId, uint96 indexed newPoolId);\n\n    /// @notice Emitted when a vToken market is removed from a pool\n    event PoolMarketRemoved(uint96 indexed poolId, address indexed vToken);\n\n    /// @notice Emitted when a new pool is created\n    event PoolCreated(uint96 indexed poolId, string label);\n\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() public pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\n        uint256 len;\n        VToken[] memory _accountAssets = accountAssets[account];\n        uint256 _accountAssetsLength = _accountAssets.length;\n\n        VToken[] memory assetsIn = new VToken[](_accountAssetsLength);\n\n        for (uint256 i; i < _accountAssetsLength; ++i) {\n            Market storage market = getCorePoolMarket(address(_accountAssets[i]));\n            if (market.isListed) {\n                assetsIn[len] = _accountAssets[i];\n                ++len;\n            }\n        }\n\n        assembly {\n            mstore(assetsIn, len)\n        }\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market\n     * @return The list of market addresses\n     */\n    function getAllMarkets() external view returns (VToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenBorrowed The address of the borrowed vToken\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateCalculateSeizeTokens(\n            address(this),\n            vTokenBorrowed,\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param borrower Address of borrower whose collateral is being seized\n     * @param vTokenBorrowed The address of the borrowed vToken\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateCalculateSeizeTokens(\n            borrower,\n            address(this),\n            vTokenBorrowed,\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        (uint256 err, uint256 seizeTokens) = comptrollerLens.liquidateVAICalculateSeizeTokens(\n            address(this),\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param vToken The vToken to check\n     * @return True if the account is in the asset, otherwise false\n     */\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\n        return _poolMarkets[getCorePoolMarketIndex(address(vToken))].accountMembership[account];\n    }\n\n    /**\n     * @notice Check if a market is marked as listed (active)\n     * @param vToken vToken Address for the market to check\n     * @return listed True if listed otherwise false\n     */\n    function isMarketListed(VToken vToken) external view returns (bool) {\n        return _poolMarkets[getCorePoolMarketIndex(address(vToken))].isListed;\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param vTokens The list of addresses of the vToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory) {\n        uint256 len = vTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i; i < len; ++i) {\n            results[i] = uint256(addToMarketInternal(VToken(vTokens[i]), msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Unlist a market by setting isListed to false\n     * @dev Checks if market actions are paused and borrowCap/supplyCap/CF are set to 0\n     * @param market The address of the market (vToken) to unlist\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function unlistMarket(address market) external returns (uint256) {\n        ensureAllowed(\"unlistMarket(address)\");\n\n        Market storage _market = _poolMarkets[getCorePoolMarketIndex(market)];\n\n        if (!_market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNLIST_MARKET_NOT_LISTED);\n        }\n\n        require(actionPaused(market, Action.BORROW), \"borrow action is not paused\");\n        require(actionPaused(market, Action.MINT), \"mint action is not paused\");\n        require(actionPaused(market, Action.REDEEM), \"redeem action is not paused\");\n        require(actionPaused(market, Action.REPAY), \"repay action is not paused\");\n        require(actionPaused(market, Action.ENTER_MARKET), \"enter market action is not paused\");\n        require(actionPaused(market, Action.LIQUIDATE), \"liquidate action is not paused\");\n        require(actionPaused(market, Action.SEIZE), \"seize action is not paused\");\n        require(actionPaused(market, Action.TRANSFER), \"transfer action is not paused\");\n        require(actionPaused(market, Action.EXIT_MARKET), \"exit market action is not paused\");\n\n        require(borrowCaps[market] == 0, \"borrow cap is not 0\");\n        require(supplyCaps[market] == 0, \"supply cap is not 0\");\n\n        require(_market.collateralFactorMantissa == 0, \"collateral factor is not 0\");\n\n        _market.isListed = false;\n        emit MarketUnlisted(market);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow\n     * @param vTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address vTokenAddress) external returns (uint256) {\n        checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\n\n        VToken vToken = VToken(vTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = _poolMarkets[getCorePoolMarketIndex(address(vToken))];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set vToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete vToken from the account’s list of assets */\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\n        VToken[] storage userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 i;\n        for (; i < len; ++i) {\n            if (userAssetList[i] == vToken) {\n                userAssetList[i] = userAssetList[len - 1];\n                userAssetList.pop();\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(i < len);\n\n        emit MarketExited(vToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _supportMarket to support the Isolated Lending Comptroller Interface\n     * @param vToken The address of the market (token) to list\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function supportMarket(VToken vToken) external returns (uint256) {\n        return __supportMarket(vToken);\n    }\n\n    /**\n     * @notice Add the market to the _poolMarkets mapping and set it as listed\n     * @dev Allows a privileged role to add and list markets to the Comptroller\n     * @param vToken The address of the market (token) to list\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(VToken vToken) external returns (uint256) {\n        return __supportMarket(vToken);\n    }\n\n    /**\n     * @notice Grants or revokes the borrowing or redeeming delegate rights to / from an account\n     *  If allowed, the delegate will be able to borrow funds on behalf of the sender\n     *  Upon a delegated borrow, the delegate will receive the funds, and the borrower\n     *  will see the debt on their account\n     *  Upon a delegated redeem, the delegate will receive the redeemed amount and the approver\n     *  will see a deduction in his vToken balance\n     * @param delegate The address to update the rights for\n     * @param approved Whether to grant (true) or revoke (false) the borrowing or redeeming rights\n     */\n    function updateDelegate(address delegate, bool approved) external {\n        ensureNonzeroAddress(delegate);\n        require(approvedDelegates[msg.sender][delegate] != approved, \"Delegation status unchanged\");\n\n        _updateDelegate(msg.sender, delegate, approved);\n    }\n\n    /**\n     * @notice Allows a user to switch to a new pool (e.g., e-mode ).\n     * @param poolId The ID of the pool the user wants to enter.\n     * @custom:error PoolDoesNotExist The specified pool ID does not exist.\n     * @custom:error AlreadyInSelectedPool The user is already in the target pool.\n     * @custom:error IncompatibleBorrowedAssets The user's current borrows are incompatible with the new pool.\n     * @custom:error LiquidityCheckFailed The user's liquidity is insufficient after switching pools.\n     * @custom:event PoolSelected Emitted after a successful pool switch.\n     */\n    function enterPool(uint96 poolId) external {\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        if (poolId == userPoolId[msg.sender]) {\n            revert AlreadyInSelectedPool();\n        }\n\n        if (!hasValidPoolBorrows(msg.sender, poolId)) {\n            revert IncompatibleBorrowedAssets();\n        }\n\n        emit PoolSelected(msg.sender, userPoolId[msg.sender], poolId);\n\n        userPoolId[msg.sender] = poolId;\n\n        (uint256 error, , uint256 shortfall) = _getAccountLiquidity(msg.sender, WeightFunction.USE_COLLATERAL_FACTOR);\n\n        if (error != 0 || shortfall > 0) {\n            revert LiquidityCheckFailed(error, shortfall);\n        }\n    }\n\n    /**\n     * @notice Creates a new pool with the given label.\n     * @param label name for the pool (must be non-empty).\n     * @return poolId The incremental unique identifier of the newly created pool.\n     * @custom:error EmptyPoolLabel Reverts if the provided label is an empty string.\n     * @custom:event PoolCreated Emitted after successfully creating a new pool.\n     */\n    function createPool(string memory label) external returns (uint96) {\n        ensureAllowed(\"createPool(string)\");\n\n        if (bytes(label).length == 0) {\n            revert EmptyPoolLabel();\n        }\n\n        uint96 poolId = ++lastPoolId;\n        pools[poolId].label = label;\n\n        emit PoolCreated(poolId, label);\n        return poolId;\n    }\n\n    /**\n     * @notice Batch initializes market entries with basic config.\n     * @param poolIds Array of pool IDs.\n     * @param vTokens Array of market (vToken) addresses.\n     * @custom:error ArrayLengthMismatch Reverts if `poolIds` and `vTokens` arrays have different lengths.\n     * @custom:error CorePoolModificationNotAllowed Reverts if attempting to modify the core pool.\n     * @custom:error PoolDoesNotExist Reverts if the target pool ID does not exist.\n     * @custom:error MarketNotListedInCorePool Reverts if the market is not listed in the core pool.\n     * @custom:error MarketAlreadyListed Reverts if the given market is already listed in the specified pool.\n     * @custom:event PoolMarketInitialized Emitted after successfully initializing a market in a pool.\n     */\n    function addPoolMarkets(uint96[] calldata poolIds, address[] calldata vTokens) external {\n        uint256 len = poolIds.length;\n        if (vTokens.length != len) {\n            revert ArrayLengthMismatch();\n        }\n\n        for (uint256 i; i < len; i++) {\n            _addPoolMarket(poolIds[i], vTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Removes a market (vToken) from the specified pool.\n     * @param poolId The ID of the pool from which the market should be removed.\n     * @param vToken The address of the market token to remove.\n     * @custom:error PoolMarketNotFound Reverts if the market is not listed in the pool.\n     * @custom:event PoolMarketRemoved Emitted after a market is successfully removed from a pool.\n     */\n    function removePoolMarket(uint96 poolId, address vToken) external {\n        ensureAllowed(\"removePoolMarket(uint96,address)\");\n\n        PoolMarketId index = getPoolMarketIndex(poolId, vToken);\n        if (!_poolMarkets[index].isListed) {\n            revert PoolMarketNotFound(poolId, vToken);\n        }\n\n        address[] storage assets = pools[poolId].vTokens;\n\n        uint256 length = assets.length;\n        for (uint256 i; i < length; i++) {\n            if (assets[i] == vToken) {\n                assets[i] = assets[length - 1];\n                assets.pop();\n                break;\n            }\n        }\n\n        delete _poolMarkets[index];\n\n        emit PoolMarketRemoved(poolId, vToken);\n    }\n\n    /**\n     * @notice Get the core pool collateral factor for a vToken\n     * @param vToken The address of the vToken to get the collateral factor for\n     * @return The collateral factor for the vToken, scaled by 1e18\n     */\n    function getCollateralFactor(address vToken) external view returns (uint256) {\n        (uint256 cf, , ) = getLiquidationParams(corePoolId, vToken);\n        return cf;\n    }\n\n    /**\n     * @notice Get the core pool liquidation threshold for a vToken\n     * @param vToken The address of the vToken to get the liquidation threshold for\n     * @return The liquidation threshold for the vToken, scaled by 1e18\n     */\n    function getLiquidationThreshold(address vToken) external view returns (uint256) {\n        (, uint256 lt, ) = getLiquidationParams(corePoolId, vToken);\n        return lt;\n    }\n\n    /**\n     * @notice Get the liquidation Incentive for a vToken\n     * @param vToken The address of the vToken whose liquidation Incentive is being queried.\n     * @return The liquidation Incentive for the vToken, scaled by 1e18\n     */\n    function getLiquidationIncentive(address vToken) external view returns (uint256) {\n        (, , uint256 li) = getLiquidationParams(corePoolId, vToken);\n        return li;\n    }\n\n    /**\n     * @notice Returns the effective loan-to-value factor (collateral factor or liquidation threshold) for a given account and market.\n     * @dev This value should be used when calculating account liquidity and during liquidation checks.\n     * @param account The account whose pool is used to determine the market's risk parameters.\n     * @param vToken The address of the vToken market.\n     * @param weightingStrategy The weighting strategy to use:\n     *                          - `WeightFunction.USE_COLLATERAL_FACTOR` to use collateral factor\n     *                          - `WeightFunction.USE_LIQUIDATION_THRESHOLD` to use liquidation threshold\n     * @return factor The effective loan-to-value factor, scaled by 1e18.\n     */\n    function getEffectiveLtvFactor(\n        address account,\n        address vToken,\n        WeightFunction weightingStrategy\n    ) external view returns (uint256) {\n        (uint256 cf, uint256 lt, ) = getLiquidationParams(userPoolId[account], vToken);\n        if (weightingStrategy == WeightFunction.USE_COLLATERAL_FACTOR) return cf;\n        else if (weightingStrategy == WeightFunction.USE_LIQUIDATION_THRESHOLD) return lt;\n        else revert InvalidWeightingStrategy(weightingStrategy);\n    }\n\n    /**\n     * @notice Get the Effective liquidation Incentive for a vToken\n     * @dev This value should be used when calculating account liquidity and during liquidation checks.\n     * @param account The address of the account for which to fetch the liquidation Incentive.\n     * @param vToken The address of the vToken whose liquidation Incentive is being queried.\n     * @return The liquidation Incentive for the vToken, scaled by 1e18\n     */\n    function getEffectiveLiquidationIncentive(address account, address vToken) external view returns (uint256) {\n        (, , uint256 li) = getLiquidationParams(userPoolId[account], vToken);\n        return li;\n    }\n\n    /**\n     * @notice Returns the full list of vTokens for a given pool ID.\n     * @param poolId The ID of the pool whose vTokens are being queried.\n     * @return An array of vToken addresses associated with the pool.\n     * @custom:error PoolDoesNotExist Reverts if the given pool ID do not exist.\n     */\n    function getPoolVTokens(uint96 poolId) external view returns (address[] memory) {\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n        return pools[poolId].vTokens;\n    }\n\n    /**\n     * @notice Returns the market configuration for a vToken in the core pool (poolId = 0).\n     * @dev Fetches the Market struct associated with the core pool and returns all relevant parameters.\n     * @param vToken The address of the vToken whose market configuration is to be fetched.\n     * @return isListed Whether the market is listed and enabled.\n     * @return collateralFactorMantissa The maximum borrowable percentage of collateral, in mantissa.\n     * @return isVenus Whether this market is eligible for VENUS rewards.\n     * @return liquidationThresholdMantissa The threshold at which liquidation is triggered, in mantissa.\n     * @return liquidationIncentiveMantissa The max liquidation incentive allowed for this market, in mantissa.\n     * @return marketPoolId The pool ID this market belongs to.\n     * @return isBorrowAllowed Whether borrowing is allowed in this market.\n     */\n    function markets(\n        address vToken\n    )\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 liquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        )\n    {\n        return poolMarkets(corePoolId, vToken);\n    }\n\n    /**\n     * @notice Returns the market configuration for a vToken from _poolMarkets.\n     * @dev Fetches the Market struct associated with the poolId and returns all relevant parameters.\n     * @param poolId The ID of the pool whose market configuration is being queried.\n     * @param vToken The address of the vToken whose market configuration is to be fetched.\n     * @return isListed Whether the market is listed and enabled.\n     * @return collateralFactorMantissa The maximum borrowable percentage of collateral, in mantissa.\n     * @return isVenus Whether this market is eligible for XVS rewards.\n     * @return liquidationThresholdMantissa The threshold at which liquidation is triggered, in mantissa.\n     * @return maxLiquidationIncentiveMantissa The max liquidation incentive allowed for this market, in mantissa.\n     * @return marketPoolId The pool ID this market belongs to.\n     * @return isBorrowAllowed Whether borrowing is allowed in this market.\n     */\n    function poolMarkets(\n        uint96 poolId,\n        address vToken\n    )\n        public\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 maxLiquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        )\n    {\n        PoolMarketId key = getPoolMarketIndex(poolId, vToken);\n        Market storage m = _poolMarkets[key];\n\n        return (\n            m.isListed,\n            m.collateralFactorMantissa,\n            m.isVenus,\n            m.liquidationThresholdMantissa,\n            m.liquidationIncentiveMantissa,\n            m.poolId,\n            m.isBorrowAllowed\n        );\n    }\n\n    /**\n     * @notice Returns true if the user can switch to the given target pool, i.e.,\n     * all markets they have borrowed from are also borrowable in the target pool.\n     * @param account The address of the user attempting to switch pools.\n     * @param targetPoolId The pool ID the user wants to switch into.\n     * @return bool True if the switch is allowed, otherwise False.\n     */\n    function hasValidPoolBorrows(address account, uint96 targetPoolId) public view returns (bool) {\n        VToken[] memory assets = accountAssets[account];\n        if (targetPoolId != corePoolId && mintedVAIs[account] > 0) {\n            return false;\n        }\n\n        for (uint256 i; i < assets.length; i++) {\n            VToken vToken = assets[i];\n            PoolMarketId index = getPoolMarketIndex(targetPoolId, address(vToken));\n\n            if (!_poolMarkets[index].isBorrowAllowed) {\n                if (vToken.borrowBalanceStored(account) > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    function _updateDelegate(address approver, address delegate, bool approved) internal {\n        approvedDelegates[approver][delegate] = approved;\n        emit DelegateUpdated(approver, delegate, approved);\n    }\n\n    function _addMarketInternal(VToken vToken) internal {\n        uint256 allMarketsLength = allMarkets.length;\n        for (uint256 i; i < allMarketsLength; ++i) {\n            require(allMarkets[i] != vToken, \"already added\");\n        }\n        allMarkets.push(vToken);\n    }\n\n    function _initializeMarket(address vToken) internal {\n        uint32 blockNumber = getBlockNumberAsUint32();\n\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n\n        /*\n         * Update market state indices\n         */\n        if (supplyState.index == 0) {\n            // Initialize supply state index with default value\n            supplyState.index = venusInitialIndex;\n        }\n\n        if (borrowState.index == 0) {\n            // Initialize borrow state index with default value\n            borrowState.index = venusInitialIndex;\n        }\n\n        /*\n         * Update market state block numbers\n         */\n        supplyState.block = borrowState.block = blockNumber;\n    }\n\n    function __supportMarket(VToken vToken) internal returns (uint256) {\n        ensureAllowed(\"_supportMarket(address)\");\n\n        if (getCorePoolMarket(address(vToken)).isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n        // Note that isVenus is not in active use anymore\n        Market storage newMarket = _poolMarkets[getCorePoolMarketIndex(address(vToken))];\n        newMarket.isListed = true;\n        newMarket.isVenus = false;\n        newMarket.collateralFactorMantissa = 0;\n\n        _addMarketInternal(vToken);\n        _initializeMarket(address(vToken));\n\n        emit MarketListed(vToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _addPoolMarket(uint96 poolId, address vToken) internal {\n        ensureAllowed(\"addPoolMarket(uint96,address)\");\n\n        if (poolId == corePoolId) revert CorePoolModificationNotAllowed();\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        // Core Pool Index\n        PoolMarketId index = getPoolMarketIndex(corePoolId, vToken);\n        if (!_poolMarkets[index].isListed) revert MarketNotListedInCorePool();\n\n        // Pool Index\n        index = getPoolMarketIndex(poolId, vToken);\n        if (_poolMarkets[index].isListed) revert MarketAlreadyListed(poolId, vToken);\n\n        Market storage m = _poolMarkets[index];\n        m.poolId = poolId;\n        m.isListed = true;\n\n        pools[poolId].vTokens.push(vToken);\n\n        emit PoolMarketInitialized(poolId, vToken);\n    }\n\n    /**\n     * @notice Returns only the core risk parameters (CF, LI, LT) for a vToken in a specific pool.\n     * @dev If not configured in the given pool, falls back to core pool (poolId = 0).\n     * @return collateralFactorMantissa The max borrowable percentage of collateral, in mantissa.\n     * @return liquidationThresholdMantissa The threshold at which liquidation is triggered, in mantissa.\n     * @return maxLiquidationIncentiveMantissa The max liquidation incentive allowed for this market, in mantissa.\n     */\n    function getLiquidationParams(\n        uint96 poolId,\n        address vToken\n    )\n        internal\n        view\n        returns (\n            uint256 collateralFactorMantissa,\n            uint256 liquidationThresholdMantissa,\n            uint256 maxLiquidationIncentiveMantissa\n        )\n    {\n        PoolMarketId coreKey = getPoolMarketIndex(corePoolId, vToken);\n        PoolMarketId poolKey = getPoolMarketIndex(poolId, vToken);\n\n        Market storage market;\n\n        if (poolId == corePoolId) {\n            market = _poolMarkets[coreKey];\n        } else {\n            Market storage poolMarket = _poolMarkets[poolKey];\n\n            if (poolMarket.isListed) {\n                market = poolMarket;\n            } else {\n                market = _poolMarkets[coreKey];\n            }\n        }\n\n        return (\n            market.collateralFactorMantissa,\n            market.liquidationThresholdMantissa,\n            market.liquidationIncentiveMantissa\n        );\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/PolicyFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IPolicyFacet } from \"../interfaces/IPolicyFacet.sol\";\n\nimport { XVSRewardsHelper } from \"./XVSRewardsHelper.sol\";\nimport { IFlashLoanReceiver } from \"../../../FlashLoan/interfaces/IFlashLoanReceiver.sol\";\nimport { VBep20Interface } from \"../../../Tokens/VTokens/VTokenInterfaces.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\nimport { WeightFunction } from \"../interfaces/IFacetBase.sol\";\n\nimport { IProtocolShareReserve } from \"../../../external/IProtocolShareReserve.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n/**\n * @title PolicyFacet\n * @author Venus\n * @dev This facet contains all the hooks used while transferring the assets\n * @notice This facet contract contains all the external pre-hook functions related to vToken\n */\ncontract PolicyFacet is IPolicyFacet, XVSRewardsHelper {\n    /// @notice Emitted when a new borrow-side XVS speed is calculated for a market\n    event VenusBorrowSpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /// @notice Emitted when a new supply-side XVS speed is calculated for a market\n    event VenusSupplySpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    // @notice Emitted When the flash loan is successfully executed\n    event FlashLoanExecuted(address receiver, VToken[] assets, uint256[] amounts);\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param vToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.MINT);\n        ensureListed(getCorePoolMarket(vToken));\n\n        uint256 supplyCap = supplyCaps[vToken];\n        require(supplyCap != 0, \"market supply cap is 0\");\n\n        uint256 vTokenSupply = VToken(vToken).totalSupply();\n        Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\n        uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\n\n        require(nextTotalSupply <= supplyCap, \"market supply cap reached\");\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, minter);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    // solhint-disable-next-line no-unused-vars\n    function mintVerify(address vToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(minter, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param vToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address vToken, address redeemer, uint256 redeemTokens) external returns (uint256) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REDEEM);\n\n        uint256 allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, redeemer);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address vToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external {\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(redeemer, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param vToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address vToken, address borrower, uint256 borrowAmount) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.BORROW);\n        ensureListed(getCorePoolMarket(vToken));\n        poolBorrowAllowed(borrower, vToken);\n\n        uint256 borrowCap = borrowCaps[vToken];\n        require(borrowCap != 0, \"market borrow cap is 0\");\n\n        if (!getCorePoolMarket(vToken).accountMembership[borrower]) {\n            // only vTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == vToken, \"sender must be vToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(VToken(vToken), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n        }\n\n        if (oracle.getUnderlyingPrice(vToken) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        uint256 nextTotalBorrows = add_(VToken(vToken).totalBorrows(), borrowAmount);\n        require(nextTotalBorrows <= borrowCap, \"market borrow cap reached\");\n\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            VToken(vToken),\n            0,\n            borrowAmount,\n            WeightFunction.USE_COLLATERAL_FACTOR\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n\n        if (shortfall != 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    // solhint-disable-next-line no-unused-vars\n    function borrowVerify(address vToken, address borrower, uint256 borrowAmount) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param vToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address vToken,\n        address payer, // solhint-disable-line no-unused-vars\n        address borrower,\n        uint256 repayAmount // solhint-disable-line no-unused-vars\n    ) external returns (uint256) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REPAY);\n        ensureListed(getCorePoolMarket(vToken));\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address vToken,\n        address payer, // solhint-disable-line no-unused-vars\n        address borrower,\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\n        uint256 borrowerIndex // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vToken);\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external view returns (uint256) {\n        checkProtocolPauseState();\n\n        // if we want to pause liquidating to vTokenCollateral, we should pause seizing\n        checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\n\n        if (liquidatorContract != address(0) && liquidator != liquidatorContract) {\n            return uint256(Error.UNAUTHORIZED);\n        }\n\n        ensureListed(getCorePoolMarket(vTokenCollateral));\n        uint256 borrowBalance;\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(getCorePoolMarket(vTokenBorrowed));\n            borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\n        } else {\n            borrowBalance = vaiController.getVAIRepayAmount(borrower);\n        }\n\n        if (isForcedLiquidationEnabled[vTokenBorrowed] || isForcedLiquidationEnabledForUser[borrower][vTokenBorrowed]) {\n            if (repayAmount > borrowBalance) {\n                return uint(Error.TOO_MUCH_REPAY);\n            }\n            return uint(Error.NO_ERROR);\n        }\n\n        /* The borrower must have shortfall in order to be liquidatable */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            VToken(address(0)),\n            0,\n            0,\n            WeightFunction.USE_LIQUIDATION_THRESHOLD\n        );\n\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall == 0) {\n            return uint256(Error.INSUFFICIENT_SHORTFALL);\n        }\n\n        // The liquidator may not repay more than what is allowed by the closeFactor\n        //-- maxClose = multipy of closeFactorMantissa and borrowBalance\n        if (repayAmount > mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance)) {\n            return uint256(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     * @param seizeTokens The amount of collateral token that will be seized\n     */\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral, // solhint-disable-line no-unused-vars\n        address liquidator,\n        address borrower,\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vTokenBorrowed);\n            prime.accrueInterestAndUpdateScore(liquidator, vTokenBorrowed);\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vTokenCollateral, Action.SEIZE);\n\n        Market storage market = _poolMarkets[getCorePoolMarketIndex(vTokenCollateral)];\n\n        // We've added VAIController as a borrowed token list check for seize\n        ensureListed(market);\n\n        if (!market.accountMembership[borrower]) {\n            return uint256(Error.MARKET_NOT_COLLATERAL);\n        }\n\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(getCorePoolMarket(vTokenBorrowed));\n        }\n\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vTokenCollateral);\n        distributeSupplierVenus(vTokenCollateral, borrower);\n        distributeSupplierVenus(vTokenCollateral, liquidator);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed, // solhint-disable-line no-unused-vars\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\n    ) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(borrower, vTokenCollateral);\n            prime.accrueInterestAndUpdateScore(liquidator, vTokenCollateral);\n        }\n    }\n\n    /**\n     * @notice Executes a flashLoan operation with the specified assets, amounts, and modes.\n     * @dev Transfer the specified assets to the receiver contract and handles repayment based on modes.\n     *      Mode 0: Classic flash loan - must repay everything or revert\n     *      Mode 1: Can create debt position for unpaid amounts\n     * @param initiator The address initiating the flash loan\n     * @param receiver The address of the contract that will receive the flashLoan and execute the operation\n     * @param vTokens The addresses of the vToken assets to be loaned\n     * @param underlyingAmounts The amounts of each underlying asset to be loaned\n     * @param modes How each borrowed asset is handled if not repaid immediately (0: flash loan, 1: debt position)\n     * @param onBehalfOf The address for whom debt positions will be opened (if mode = 1)\n     * @param param The bytes passed in the executeOperation call\n     */\n    function executeFlashLoan(\n        address payable initiator,\n        address payable receiver,\n        VToken[] calldata vTokens,\n        uint256[] calldata underlyingAmounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata param\n    ) external {\n        for (uint256 i = 0; i < vTokens.length; i++) {\n            if (!(vTokens[i]).isFlashLoanEnabled()) revert(\"FlashLoan not enabled\");\n        }\n\n        ensureNonzeroAddress(receiver);\n        ensureNonzeroAddress(onBehalfOf);\n        // All arrays must have the same length and not be zero\n        if (vTokens.length != underlyingAmounts.length || vTokens.length != modes.length || vTokens.length == 0) {\n            revert(\"Invalid flashLoan params\");\n        }\n        // Validate parameters and delegation\n        _validateFlashLoanParams(initiator, vTokens, modes, onBehalfOf);\n\n        if (!authorizedFlashLoan[initiator]) {\n            revert(\"Flash loan not authorized for this account\");\n        }\n        // Execute flash loan phases\n        _executeFlashLoanPhases(receiver, vTokens, underlyingAmounts, modes, onBehalfOf, param);\n\n        emit FlashLoanExecuted(receiver, vTokens, underlyingAmounts);\n    }\n\n    /**\n     * @notice Validates flash loan parameters and delegation\n     */\n    function _validateFlashLoanParams(\n        address payable initiator,\n        VToken[] memory vTokens,\n        uint256[] memory modes,\n        address onBehalfOf\n    ) internal view {\n        // Check delegation if borrowing on behalf of someone else\n        if (onBehalfOf != initiator) {\n            for (uint256 i = 0; i < vTokens.length; i++) {\n                if (modes[i] == 1) {\n                    // Only check delegation for debt-creating modes\n                    require(\n                        delegateAuthorizationFlashloan[onBehalfOf][address(vTokens[i])][initiator],\n                        \"Sender not authorized to use flashloan on behalf\"\n                    );\n                }\n            }\n        }\n\n        // Validate modes\n        for (uint256 i = 0; i < modes.length; i++) {\n            require(modes[i] <= 1, \"Invalid mode\");\n        }\n    }\n\n    /**\n     * @notice Executes all flash loan phases\n     */\n    function _executeFlashLoanPhases(\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        uint256[] memory modes,\n        address onBehalfOf,\n        bytes memory param\n    ) internal returns (FlashLoanData memory flashLoanData) {\n        // Initialize arrays\n        flashLoanData.protocolFees = new uint256[](vTokens.length);\n        flashLoanData.supplierFees = new uint256[](vTokens.length);\n        flashLoanData.totalFees = new uint256[](vTokens.length);\n        flashLoanData.balanceAfterTransfer = new uint256[](vTokens.length);\n        flashLoanData.actualRepayments = new uint256[](vTokens.length);\n        flashLoanData.remainingDebts = new uint256[](vTokens.length);\n\n        // Phase 1: Calculate fees and transfer assets\n        _executePhase1(receiver, vTokens, underlyingAmounts, flashLoanData);\n        // Phase 2: Execute operation on receiver contract\n        _executePhase2(receiver, vTokens, underlyingAmounts, flashLoanData.totalFees, param);\n        // Phase 3: Handle repayment based on modes\n        _executePhase3(receiver, vTokens, underlyingAmounts, modes, onBehalfOf, flashLoanData);\n\n        return flashLoanData;\n    }\n\n    /**\n     * @notice Phase 1: Calculate fees and transfer assets to receiver\n     */\n    function _executePhase1(\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        FlashLoanData memory flashLoanData\n    ) internal {\n        for (uint256 j = 0; j < vTokens.length; j++) {\n            (flashLoanData.protocolFees[j], flashLoanData.supplierFees[j]) = vTokens[j].calculateFlashLoanFee(\n                underlyingAmounts[j]\n            );\n            flashLoanData.totalFees[j] = flashLoanData.protocolFees[j] + flashLoanData.supplierFees[j];\n\n            // Transfer the asset to receiver\n            flashLoanData.balanceAfterTransfer[j] = vTokens[j].transferOutUnderlying(receiver, underlyingAmounts[j]);\n        }\n    }\n\n    /**\n     * @notice Phase 2: Execute operation on receiver contract\n     */\n    function _executePhase2(\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        uint256[] memory totalFees,\n        bytes memory param\n    ) internal {\n        if (!IFlashLoanReceiver(receiver).executeOperation(vTokens, underlyingAmounts, totalFees, msg.sender, param)) {\n            revert(\"Execute flashLoan failed\");\n        }\n    }\n\n    /**\n     * @notice Phase 3: Handle repayment based on modes\n     */\n    function _executePhase3(\n        address payable receiver,\n        VToken[] memory vTokens,\n        uint256[] memory underlyingAmounts,\n        uint256[] memory modes,\n        address onBehalfOf,\n        FlashLoanData memory flashLoanData\n    ) internal {\n        for (uint256 k = 0; k < vTokens.length; k++) {\n            if (modes[k] == 0) {\n                // Mode 0: Classic flash loan - must repay everything\n                _handleFlashLoanMode0(\n                    vTokens[k],\n                    receiver,\n                    underlyingAmounts[k],\n                    flashLoanData.totalFees[k],\n                    flashLoanData.protocolFees[k],\n                    flashLoanData.balanceAfterTransfer[k]\n                );\n                flashLoanData.actualRepayments[k] = underlyingAmounts[k] + flashLoanData.totalFees[k];\n                flashLoanData.remainingDebts[k] = 0;\n            } else if (modes[k] == 1) {\n                // Mode 1: Can create debt position\n                (flashLoanData.actualRepayments[k], flashLoanData.remainingDebts[k]) = _handleFlashLoanMode1(\n                    address(vTokens[k]),\n                    onBehalfOf,\n                    underlyingAmounts[k],\n                    flashLoanData.totalFees[k],\n                    flashLoanData.protocolFees[k],\n                    flashLoanData.balanceAfterTransfer[k]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Handles classic flash loan mode (mode 0) - must repay within transaction\n     */\n    function _handleFlashLoanMode0(\n        VToken vToken,\n        address payable receiver,\n        uint256 amount,\n        uint256 totalFee,\n        uint256 protocolFee,\n        uint256 balanceAfterTransfer\n    ) internal {\n        // Must repay full amount + fee\n        vToken.transferInUnderlyingAndVerify(receiver, amount, totalFee, balanceAfterTransfer);\n\n        // Transfer protocol fee to protocol share reserve\n        vToken.transferOutUnderlying(vToken.protocolShareReserve(), protocolFee);\n\n        // Update protocol share reserve state\n        IProtocolShareReserve(vToken.protocolShareReserve()).updateAssetsState(\n            address(vToken.comptroller()),\n            address(vToken.underlying()),\n            IProtocolShareReserve.IncomeType.FLASHLOAN\n        );\n    }\n\n    /**\n     * @notice Handles debt position mode (mode 1) - can create ongoing debt\n     * @return actualRepayment The amount actually repaid\n     * @return remainingDebt The amount that became ongoing debt\n     */\n    function _handleFlashLoanMode1(\n        address vTokenAddress,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 totalFee,\n        uint256 protocolFee,\n        uint256 balanceAfterTransfer\n    ) internal returns (uint256 actualRepayment, uint256 remainingDebt) {\n        VToken vToken = VToken(vTokenAddress);\n        uint256 requiredRepayment = amount + totalFee;\n        uint256 currentBalance = IERC20(vToken.underlying()).balanceOf(onBehalfOf);\n\n        // Calculate actual repayment received\n        if (currentBalance > balanceAfterTransfer) {\n            actualRepayment = currentBalance - balanceAfterTransfer;\n        } else {\n            actualRepayment = 0;\n        }\n\n        // Create debt position by calling VBep20's borrow function\n        // This will handle all the proper borrow logic including state updates\n        uint256 accrueResult = vToken.accrueInterest();\n        require(accrueResult == 0, \"Failed to accrue interest\");\n\n        // If actual repayment is less than required, we create a debt position\n        uint256 debtError = vToken.borrowDebtPosition(onBehalfOf, requiredRepayment);\n        require(debtError == 0, \"Failed to create debt position\");\n\n        // Handle fees from actual repayment proportionally\n        if (actualRepayment > 0) {\n            uint256 feeFromRepayment = (actualRepayment * protocolFee) / requiredRepayment;\n            if (feeFromRepayment > 0) {\n                vToken.transferOutUnderlying(vToken.protocolShareReserve(), feeFromRepayment);\n                IProtocolShareReserve(vToken.protocolShareReserve()).updateAssetsState(\n                    address(vToken.comptroller()),\n                    address(vToken.underlying()),\n                    IProtocolShareReserve.IncomeType.FLASHLOAN\n                );\n            }\n        }\n\n        return (actualRepayment, requiredRepayment);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param vToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.TRANSFER);\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(vToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, src);\n        distributeSupplierVenus(vToken, dst);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\n     * @param vToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     */\n    // solhint-disable-next-line no-unused-vars\n    function transferVerify(address vToken, address src, address dst, uint256 transferTokens) external {\n        if (address(prime) != address(0)) {\n            prime.accrueInterestAndUpdateScore(src, vToken);\n            prime.accrueInterestAndUpdateScore(dst, vToken);\n        }\n    }\n\n    /**\n     * @notice Alias to getAccountLiquidity to support the Isolated Lending Comptroller Interface\n     * @param account The account get liquidity for\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getBorrowingPower(address account) external view returns (uint256, uint256, uint256) {\n        return _getAccountLiquidity(account, WeightFunction.USE_COLLATERAL_FACTOR);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @param account The account get liquidity for\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256) {\n        return _getAccountLiquidity(account, WeightFunction.USE_COLLATERAL_FACTOR);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external view returns (uint256, uint256, uint256) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(vTokenModify),\n            redeemTokens,\n            borrowAmount,\n            WeightFunction.USE_COLLATERAL_FACTOR\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    // setter functionality\n    /**\n     * @notice Set XVS speed for a single market\n     * @dev Allows the contract admin to set XVS speed for a market\n     * @param vTokens The market whose XVS speed to update\n     * @param supplySpeeds New XVS speed for supply\n     * @param borrowSpeeds New XVS speed for borrow\n     */\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint256[] calldata supplySpeeds,\n        uint256[] calldata borrowSpeeds\n    ) external {\n        ensureAdmin();\n\n        uint256 numTokens = vTokens.length;\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"invalid input\");\n\n        for (uint256 i; i < numTokens; ++i) {\n            ensureNonzeroAddress(address(vTokens[i]));\n            setVenusSpeedInternal(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n        }\n    }\n\n    function setVenusSpeedInternal(VToken vToken, uint256 supplySpeed, uint256 borrowSpeed) internal {\n        ensureListed(getCorePoolMarket(address(vToken)));\n\n        if (venusSupplySpeeds[address(vToken)] != supplySpeed) {\n            // Supply speed updated so let's update supply state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n\n            updateVenusSupplyIndex(address(vToken));\n            // Update speed and emit event\n            venusSupplySpeeds[address(vToken)] = supplySpeed;\n            emit VenusSupplySpeedUpdated(vToken, supplySpeed);\n        }\n\n        if (venusBorrowSpeeds[address(vToken)] != borrowSpeed) {\n            // Borrow speed updated so let's update borrow state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n            // Update speed and emit event\n            venusBorrowSpeeds[address(vToken)] = borrowSpeed;\n            emit VenusBorrowSpeedUpdated(vToken, borrowSpeed);\n        }\n    }\n\n    function poolBorrowAllowed(address account, address vToken) internal view {\n        PoolMarketId index = getPoolMarketIndex(userPoolId[account], vToken);\n        if (!_poolMarkets[index].isBorrowAllowed) {\n            revert BorrowNotAllowedInPool();\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/RewardFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { IRewardFacet } from \"../interfaces/IRewardFacet.sol\";\nimport { XVSRewardsHelper } from \"./XVSRewardsHelper.sol\";\nimport { VBep20Interface } from \"../../../Tokens/VTokens/VTokenInterfaces.sol\";\nimport { WeightFunction } from \"../interfaces/IFacetBase.sol\";\n\n/**\n * @title RewardFacet\n * @author Venus\n * @dev This facet contains all the methods related to the reward functionality\n * @notice This facet contract provides the external functions related to all claims and rewards of the protocol\n */\ncontract RewardFacet is IRewardFacet, XVSRewardsHelper {\n    /// @notice Emitted when Venus is granted by admin\n    event VenusGranted(address indexed recipient, uint256 amount);\n\n    /// @notice Emitted when XVS are seized for the holder\n    event VenusSeized(address indexed holder, uint256 amount);\n\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\n     * @param holder The address to claim XVS for\n     */\n    function claimVenus(address holder) public {\n        return claimVenus(holder, allMarkets);\n    }\n\n    /**\n     * @notice Claim all the xvs accrued by holder in the specified markets\n     * @param holder The address to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     */\n    function claimVenus(address holder, VToken[] memory vTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimVenus(holders, vTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all xvs accrued by the holders\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     */\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\n        claimVenus(holders, vTokens, borrowers, suppliers, false);\n    }\n\n    /**\n     * @notice Claim all the xvs accrued by holder in all markets, a shorthand for `claimVenus` with collateral set to `true`\n     * @param holder The address to claim XVS for\n     */\n    function claimVenusAsCollateral(address holder) external {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimVenus(holders, allMarkets, true, true, true);\n    }\n\n    /**\n     * @notice Transfer XVS to the user with user's shortfall considered\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all\n     * @param user The address of the user to transfer XVS to\n     * @param amount The amount of XVS to (possibly) transfer\n     * @param shortfall The shortfall of the user\n     * @param collateral Whether or not we will use user's venus reward as collateral to pay off the debt\n     * @return The amount of XVS which was NOT transferred to the user\n     */\n    function grantXVSInternal(\n        address user,\n        uint256 amount,\n        uint256 shortfall,\n        bool collateral\n    ) internal returns (uint256) {\n        // If the user is blacklisted, they can't get XVS rewards\n        require(\n            user != 0xEF044206Db68E40520BfA82D45419d498b4bc7Bf &&\n                user != 0x7589dD3355DAE848FDbF75044A3495351655cB1A &&\n                user != 0x33df7a7F6D44307E1e5F3B15975b47515e5524c0 &&\n                user != 0x24e77E5b74B30b026E9996e4bc3329c881e24968,\n            \"Blacklisted\"\n        );\n\n        IERC20 xvs_ = IERC20(xvs);\n\n        if (amount == 0 || amount > xvs_.balanceOf(address(this))) {\n            return amount;\n        }\n\n        if (shortfall == 0) {\n            xvs_.safeTransfer(user, amount);\n            return 0;\n        }\n        // If user's bankrupt and doesn't use pending xvs as collateral, don't grant\n        // anything, otherwise, we will transfer the pending xvs as collateral to\n        // vXVS token and mint vXVS for the user\n        //\n        // If mintBehalf failed, don't grant any xvs\n        require(collateral, \"bankrupt\");\n\n        address xvsVToken_ = xvsVToken;\n\n        xvs_.safeApprove(xvsVToken_, 0);\n        xvs_.safeApprove(xvsVToken_, amount);\n        require(VBep20Interface(xvsVToken_).mintBehalf(user, amount) == uint256(Error.NO_ERROR), \"mint behalf error\");\n\n        // set venusAccrued[user] to 0\n        return 0;\n    }\n\n    /*** Venus Distribution Admin ***/\n\n    /**\n     * @notice Transfer XVS to the recipient\n     * @dev Allows the contract admin to transfer XVS to any recipient based on the recipient's shortfall\n     *      Note: If there is not enough XVS, we do not perform the transfer all\n     * @param recipient The address of the recipient to transfer XVS to\n     * @param amount The amount of XVS to (possibly) transfer\n     */\n    function _grantXVS(address recipient, uint256 amount) external {\n        ensureAdmin();\n        uint256 amountLeft = grantXVSInternal(recipient, amount, 0, false);\n        require(amountLeft == 0, \"no xvs\");\n        emit VenusGranted(recipient, amount);\n    }\n\n    /**\n     * @dev Seize XVS tokens from the specified holders and transfer to recipient\n     * @notice Seize XVS rewards allocated to holders\n     * @param holders Addresses of the XVS holders\n     * @param recipient Address of the XVS token recipient\n     * @return The total amount of XVS tokens seized and transferred to recipient\n     */\n    function seizeVenus(address[] calldata holders, address recipient) external returns (uint256) {\n        ensureAllowed(\"seizeVenus(address[],address)\");\n\n        uint256 holdersLength = holders.length;\n        uint256 totalHoldings;\n\n        updateAndDistributeRewardsInternal(holders, allMarkets, true, true);\n        for (uint256 j; j < holdersLength; ++j) {\n            address holder = holders[j];\n            uint256 userHolding = venusAccrued[holder];\n\n            if (userHolding != 0) {\n                totalHoldings += userHolding;\n                delete venusAccrued[holder];\n            }\n\n            emit VenusSeized(holder, userHolding);\n        }\n\n        if (totalHoldings != 0) {\n            IERC20(xvs).safeTransfer(recipient, totalHoldings);\n            emit VenusGranted(recipient, totalHoldings);\n        }\n\n        return totalHoldings;\n    }\n\n    /**\n     * @notice Claim all xvs accrued by the holders\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     * @param collateral Whether or not to use XVS earned as collateral, only takes effect when the holder has a shortfall\n     */\n    function claimVenus(\n        address[] memory holders,\n        VToken[] memory vTokens,\n        bool borrowers,\n        bool suppliers,\n        bool collateral\n    ) public {\n        uint256 holdersLength = holders.length;\n\n        updateAndDistributeRewardsInternal(holders, vTokens, borrowers, suppliers);\n        for (uint256 j; j < holdersLength; ++j) {\n            address holder = holders[j];\n\n            // If there is a positive shortfall, the XVS reward is accrued,\n            // but won't be granted to this holder\n            (, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n                holder,\n                VToken(address(0)),\n                0,\n                0,\n                WeightFunction.USE_COLLATERAL_FACTOR\n            );\n\n            uint256 value = venusAccrued[holder];\n            delete venusAccrued[holder];\n\n            uint256 returnAmount = grantXVSInternal(holder, value, shortfall, collateral);\n\n            // returnAmount can only be positive if balance of xvsAddress is less than grant amount(venusAccrued[holder])\n            if (returnAmount != 0) {\n                venusAccrued[holder] = returnAmount;\n            }\n        }\n    }\n\n    /**\n     * @notice Update and distribute tokens\n     * @param holders The addresses to claim XVS for\n     * @param vTokens The list of markets to claim XVS in\n     * @param borrowers Whether or not to claim XVS earned by borrowing\n     * @param suppliers Whether or not to claim XVS earned by supplying\n     */\n    function updateAndDistributeRewardsInternal(\n        address[] memory holders,\n        VToken[] memory vTokens,\n        bool borrowers,\n        bool suppliers\n    ) internal {\n        uint256 j;\n        uint256 holdersLength = holders.length;\n        uint256 vTokensLength = vTokens.length;\n\n        for (uint256 i; i < vTokensLength; ++i) {\n            VToken vToken = vTokens[i];\n            ensureListed(getCorePoolMarket(address(vToken)));\n            if (borrowers) {\n                Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\n                for (j = 0; j < holdersLength; ++j) {\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\n                }\n            }\n\n            if (suppliers) {\n                updateVenusSupplyIndex(address(vToken));\n                for (j = 0; j < holdersLength; ++j) {\n                    distributeSupplierVenus(address(vToken), holders[j]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the XVS vToken address\n     * @return The address of XVS vToken\n     */\n    function getXVSVTokenAddress() external view returns (address) {\n        return xvsVToken;\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/SetterFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { ComptrollerLensInterface } from \"../../ComptrollerLensInterface.sol\";\nimport { VAIControllerInterface } from \"../../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { IPrime } from \"../../../Tokens/Prime/IPrime.sol\";\nimport { ISetterFacet } from \"../interfaces/ISetterFacet.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\n\n/**\n * @title SetterFacet\n * @author Venus\n * @dev This facet contains all the setters for the states\n * @notice This facet contract contains all the configurational setter functions\n */\ncontract SetterFacet is ISetterFacet, FacetBase {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(\n        uint96 indexed poolId,\n        VToken indexed vToken,\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(\n        uint96 indexed poolId,\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(ResilientOracleInterface oldPriceOracle, ResilientOracleInterface newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint256 oldVAIMintRate, uint256 newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint256 oldTreasuryPercent, uint256 newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address indexed vault_, uint256 releaseStartBlock_, uint256 releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint256 oldVenusVAIVaultRate, uint256 newVenusVAIVaultRate);\n\n    /// @notice Emitted when prime token contract address is changed\n    event NewPrimeToken(IPrime oldPrimeToken, IPrime newPrimeToken);\n\n    /// @notice Emitted when forced liquidation is enabled or disabled for all users in a market\n    event IsForcedLiquidationEnabledUpdated(address indexed vToken, bool enable);\n\n    /// @notice Emitted when forced liquidation is enabled or disabled for a user borrowing in a market\n    event IsForcedLiquidationEnabledForUserUpdated(address indexed borrower, address indexed vToken, bool enable);\n\n    /// @notice Emitted when XVS token address is changed\n    event NewXVSToken(address indexed oldXVS, address indexed newXVS);\n\n    /// @notice Emitted when XVS vToken address is changed\n    event NewXVSVToken(address indexed oldXVSVToken, address indexed newXVSVToken);\n\n    /// @notice Emitted when an account's flash loan whitelist status is updated\n    event IsAccountFlashLoanWhitelisted(address indexed account, bool indexed isWhitelisted);\n    /// @notice Emitted when delegate authorization for flash loans is changed\n    event DelegateAuthorizationFlashloanChanged(\n        address indexed user,\n        address indexed market,\n        address indexed delegate,\n        bool approved\n    );\n\n    /// @notice Emitted when liquidation threshold is changed by admin\n    event NewLiquidationThreshold(\n        uint96 indexed poolId,\n        VToken indexed vToken,\n        uint256 oldLiquidationThresholdMantissa,\n        uint256 newLiquidationThresholdMantissa\n    );\n\n    /// @notice Emitted when the borrowAllowed flag is updated for a market\n    event BorrowAllowedUpdated(uint96 indexed poolId, address indexed market, bool isAllowed);\n\n    /**\n     * @notice Compare two addresses to ensure they are different\n     * @param oldAddress The original address to compare\n     * @param newAddress The new address to compare\n     */\n    modifier compareAddress(address oldAddress, address newAddress) {\n        require(oldAddress != newAddress, \"old address is same as new address\");\n        _;\n    }\n\n    /**\n     * @notice Compare two values to ensure they are different\n     * @param oldValue The original value to compare\n     * @param newValue The new value to compare\n     */\n    modifier compareValue(uint256 oldValue, uint256 newValue) {\n        require(oldValue != newValue, \"old value is same as new value\");\n        _;\n    }\n\n    /**\n     * @notice Alias to _setPriceOracle to support the Isolated Lending Comptroller Interface\n     * @param newOracle The new price oracle to set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256) {\n        return __setPriceOracle(newOracle);\n    }\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Allows the contract admin to set a new price oracle used by the Comptroller\n     * @param newOracle The new price oracle to set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256) {\n        return __setPriceOracle(newOracle);\n    }\n\n    /**\n     * @notice Alias to _setCloseFactor to support the Isolated Lending Comptroller Interface\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint256 0=success, otherwise will revert\n     */\n    function setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        return __setCloseFactor(newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Allows the contract admin to set the closeFactor used to liquidate borrows\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint256 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        return __setCloseFactor(newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Allows the contract admin to set the address of access control of this contract\n     * @param newAccessControlAddress New address for the access control\n     * @return uint256 0=success, otherwise will revert\n     */\n    function _setAccessControl(\n        address newAccessControlAddress\n    ) external compareAddress(accessControl, newAccessControlAddress) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateral factor and liquidation threshold for a market in the Core Pool only.\n     * @dev Alias to _setCollateralFactor to support the Isolated Lending Comptroller Interface\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256) {\n        ensureAllowed(\"setCollateralFactor(address,uint256,uint256)\");\n        return __setCollateralFactor(corePoolId, vToken, newCollateralFactorMantissa, newLiquidationThresholdMantissa);\n    }\n\n    /**\n     * @notice Sets the liquidation incentive for a market in the Core Pool only.\n     * @dev Alias to _setLiquidationIncentive to support the Isolated Lending Comptroller Interface\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setLiquidationIncentive(\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    ) external returns (uint256) {\n        ensureAllowed(\"setLiquidationIncentive(address,uint256)\");\n        return __setLiquidationIncentive(corePoolId, vToken, newLiquidationIncentiveMantissa);\n    }\n\n    /**\n     * @notice Sets the collateral factor and liquidation threshold for a market in the specified pool.\n     * @param poolId The ID of the pool.\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setCollateralFactor(\n        uint96 poolId,\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256) {\n        ensureAllowed(\"setCollateralFactor(uint96,address,uint256,uint256)\");\n        return __setCollateralFactor(poolId, vToken, newCollateralFactorMantissa, newLiquidationThresholdMantissa);\n    }\n\n    /**\n     * @notice Sets the liquidation incentive for a market in the specified pool.\n     * @param poolId The ID of the pool.\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint256 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function setLiquidationIncentive(\n        uint96 poolId,\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    ) external returns (uint256) {\n        ensureAllowed(\"setLiquidationIncentive(uint96,address,uint256)\");\n        return __setLiquidationIncentive(poolId, vToken, newLiquidationIncentiveMantissa);\n    }\n\n    /**\n     * @notice Update the address of the liquidator contract\n     * @dev Allows the contract admin to update the address of liquidator contract\n     * @param newLiquidatorContract_ The new address of the liquidator contract\n     */\n    function _setLiquidatorContract(\n        address newLiquidatorContract_\n    ) external compareAddress(liquidatorContract, newLiquidatorContract_) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newLiquidatorContract_);\n        address oldLiquidatorContract = liquidatorContract;\n        liquidatorContract = newLiquidatorContract_;\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @dev Allows the contract admin to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint256 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(\n        address newPauseGuardian\n    ) external compareAddress(pauseGuardian, newPauseGuardian) returns (uint256) {\n        ensureAdmin();\n        ensureNonzeroAddress(newPauseGuardian);\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Alias to _setMarketBorrowCaps to support the Isolated Lending Comptroller Interface\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to Borrow not allowed\n     */\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\n        __setMarketBorrowCaps(vTokens, newBorrowCaps);\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given vToken market Borrowing that brings total borrows to or above borrow cap will revert\n     * @dev Allows a privileged role to set the borrowing cap for a vToken market. A borrow cap of 0 corresponds to Borrow not allowed\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to Borrow not allowed\n     */\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\n        __setMarketBorrowCaps(vTokens, newBorrowCaps);\n    }\n\n    /**\n     * @notice Alias to _setMarketSupplyCaps to support the Isolated Lending Comptroller Interface\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed\n     */\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        __setMarketSupplyCaps(vTokens, newSupplyCaps);\n    }\n\n    /**\n     * @notice Set the given supply caps for the given vToken market Supply that brings total Supply to or above supply cap will revert\n     * @dev Allows a privileged role to set the supply cap for a vToken. A supply cap of 0 corresponds to Minting NotAllowed\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed\n     */\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        __setMarketSupplyCaps(vTokens, newSupplyCaps);\n    }\n\n    /**\n     * @notice Set whole protocol pause/unpause state\n     * @dev Allows a privileged role to pause/unpause protocol\n     * @param state The new state (true=paused, false=unpaused)\n     * @return bool The updated state of the protocol\n     */\n    function _setProtocolPaused(bool state) external returns (bool) {\n        ensureAllowed(\"_setProtocolPaused(bool)\");\n\n        protocolPaused = state;\n        emit ActionProtocolPaused(state);\n        return state;\n    }\n\n    /**\n     * @notice Alias to _setActionsPaused to support the Isolated Lending Comptroller Interface\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        __setActionsPaused(markets_, actions_, paused_);\n    }\n\n    /**\n     * @notice Pause/unpause certain actions\n     * @dev Allows a privileged role to pause/unpause the protocol action state\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        __setActionsPaused(markets_, actions_, paused_);\n    }\n\n    /**\n     * @dev Pause/unpause an action on a market\n     * @param market Market to pause/unpause the action on\n     * @param action Action id to pause/unpause\n     * @param paused The new paused state (true=paused, false=unpaused)\n     */\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\n        ensureListed(getCorePoolMarket(market));\n        _actionPaused[market][uint256(action)] = paused;\n        emit ActionPausedMarket(VToken(market), action, paused);\n    }\n\n    /**\n     * @notice Sets a new VAI controller\n     * @dev Admin function to set a new VAI controller\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIController(\n        VAIControllerInterface vaiController_\n    ) external compareAddress(address(vaiController), address(vaiController_)) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(vaiController_));\n\n        VAIControllerInterface oldVaiController = vaiController;\n        vaiController = vaiController_;\n        emit NewVAIController(oldVaiController, vaiController_);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the VAI mint rate\n     * @param newVAIMintRate The new VAI mint rate to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIMintRate(\n        uint256 newVAIMintRate\n    ) external compareValue(vaiMintRate, newVAIMintRate) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        uint256 oldVAIMintRate = vaiMintRate;\n        vaiMintRate = newVAIMintRate;\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the minted VAI amount of the `owner`\n     * @param owner The address of the account to set\n     * @param amount The amount of VAI to set to the account\n     * @return The number of minted VAI by `owner`\n     */\n    function setMintedVAIOf(address owner, uint256 amount) external returns (uint256) {\n        checkProtocolPauseState();\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n        // Check caller is vaiController\n        if (msg.sender != address(vaiController)) {\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\n        }\n        mintedVAIs[owner] = amount;\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the treasury data.\n     * @param newTreasuryGuardian The new address of the treasury guardian to be set\n     * @param newTreasuryAddress The new address of the treasury to be set\n     * @param newTreasuryPercent The new treasury percent to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256) {\n        // Check caller is admin\n        ensureAdminOr(treasuryGuardian);\n\n        require(newTreasuryPercent < 1e18, \"percent >= 100%\");\n        ensureNonzeroAddress(newTreasuryGuardian);\n        ensureNonzeroAddress(newTreasuryAddress);\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint256 oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Venus Distribution ***/\n\n    /**\n     * @dev Set ComptrollerLens contract address\n     * @param comptrollerLens_ The new ComptrollerLens contract address to be set\n     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptrollerLens(\n        ComptrollerLensInterface comptrollerLens_\n    ) external virtual compareAddress(address(comptrollerLens), address(comptrollerLens_)) returns (uint256) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block to VAI Vault\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\n     */\n    function _setVenusVAIVaultRate(\n        uint256 venusVAIVaultRate_\n    ) external compareValue(venusVAIVaultRate, venusVAIVaultRate_) {\n        ensureAdmin();\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n        uint256 oldVenusVAIVaultRate = venusVAIVaultRate;\n        venusVAIVaultRate = venusVAIVaultRate_;\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n    }\n\n    /**\n     * @notice Set the VAI Vault infos\n     * @param vault_ The address of the VAI Vault\n     * @param releaseStartBlock_ The start block of release to VAI Vault\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\n     */\n    function _setVAIVaultInfo(\n        address vault_,\n        uint256 releaseStartBlock_,\n        uint256 minReleaseAmount_\n    ) external compareAddress(vaiVaultAddress, vault_) {\n        ensureAdmin();\n        ensureNonzeroAddress(vault_);\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n\n        vaiVaultAddress = vault_;\n        releaseStartBlock = releaseStartBlock_;\n        minReleaseAmount = minReleaseAmount_;\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n    }\n\n    /**\n     * @notice Alias to _setPrimeToken to support the Isolated Lending Comptroller Interface\n     * @param _prime The new prime token contract to be set\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function setPrimeToken(IPrime _prime) external returns (uint256) {\n        return __setPrimeToken(_prime);\n    }\n\n    /**\n     * @notice Sets the prime token contract for the comptroller\n     * @param _prime The new prime token contract to be set\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPrimeToken(IPrime _prime) external returns (uint256) {\n        return __setPrimeToken(_prime);\n    }\n\n    /**\n     * @notice Alias to _setForcedLiquidation to support the Isolated Lending Comptroller Interface\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external {\n        __setForcedLiquidation(vTokenBorrowed, enable);\n    }\n\n    /** @notice Enables forced liquidations for a market. If forced liquidation is enabled,\n     * borrows in the market may be liquidated regardless of the account liquidity\n     * @dev Allows a privileged role to set enable/disable forced liquidations\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function _setForcedLiquidation(address vTokenBorrowed, bool enable) external {\n        __setForcedLiquidation(vTokenBorrowed, enable);\n    }\n\n    /**\n     * @notice Enables forced liquidations for user's borrows in a certain market. If forced\n     * liquidation is enabled, user's borrows in the market may be liquidated regardless of\n     * the account liquidity. Forced liquidation may be enabled for a user even if it is not\n     * enabled for the entire market.\n     * @param borrower The address of the borrower\n     * @param vTokenBorrowed Borrowed vToken\n     * @param enable Whether to enable forced liquidations\n     */\n    function _setForcedLiquidationForUser(address borrower, address vTokenBorrowed, bool enable) external {\n        ensureAllowed(\"_setForcedLiquidationForUser(address,address,bool)\");\n        if (vTokenBorrowed != address(vaiController)) {\n            ensureListed(getCorePoolMarket(vTokenBorrowed));\n        }\n        isForcedLiquidationEnabledForUser[borrower][vTokenBorrowed] = enable;\n        emit IsForcedLiquidationEnabledForUserUpdated(borrower, vTokenBorrowed, enable);\n    }\n\n    /**\n     * @notice Set the address of the XVS token\n     * @param xvs_ The address of the XVS token\n     */\n    function _setXVSToken(address xvs_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(xvs_);\n\n        emit NewXVSToken(xvs, xvs_);\n        xvs = xvs_;\n    }\n\n    /**\n     * @notice Set the address of the XVS vToken\n     * @param xvsVToken_ The address of the XVS vToken\n     */\n    function _setXVSVToken(address xvsVToken_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(xvsVToken_);\n\n        address underlying = VToken(xvsVToken_).underlying();\n        require(underlying == xvs, \"invalid xvs vtoken address\");\n\n        emit NewXVSVToken(xvsVToken, xvsVToken_);\n        xvsVToken = xvsVToken_;\n    }\n\n    /**\n     * @notice Adds/Removes an account to the flash loan whitelist\n     * @param account The account to authorize for flash loans\n     * @param _isWhiteListed True to whitelist the account for flash loans, false to remove from whitelist\n     */\n    function setWhiteListFlashLoanAccount(address account, bool _isWhiteListed) external {\n        ensureAllowed(\"setWhiteListFlashLoanAccount(address,bool)\");\n        ensureNonzeroAddress(account);\n\n        authorizedFlashLoan[account] = _isWhiteListed;\n        emit IsAccountFlashLoanWhitelisted(account, _isWhiteListed);\n    }\n\n    /**\n     * @notice Set or revoke delegate authorization for flash loans\n     * @dev Allows users to authorize delegates to execute flash loans on their behalf\n     * @param delegate The address to authorize or revoke as delegate\n     * @param approved True to authorize, false to revoke\n     */\n    function setDelegateAuthorizationFlashloan(address market, address delegate, bool approved) external {\n        ensureNonzeroAddress(delegate);\n\n        // Only allow users to set authorization for themselves\n        delegateAuthorizationFlashloan[msg.sender][market][delegate] = approved;\n\n        emit DelegateAuthorizationFlashloanChanged(msg.sender, market, delegate, approved);\n    }\n\n    /**\n     * @notice Updates the `isBorrowAllowed` flag for a market in a pool.\n     * @param poolId The ID of the pool.\n     * @param vToken The address of the market (vToken).\n     * @param borrowAllowed The new borrow allowed status.\n     * @custom:error PoolDoesNotExist Reverts if the pool ID is invalid.\n     * @custom:error MarketConfigNotFound Reverts if the market is not listed in the pool.\n     * @custom:event BorrowAllowedUpdated Emitted after the borrow permission for a market is updated.\n     */\n    function setIsBorrowAllowed(uint96 poolId, address vToken, bool borrowAllowed) external {\n        ensureAllowed(\"setIsBorrowAllowed(uint96,address,bool)\");\n\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        PoolMarketId index = getPoolMarketIndex(poolId, vToken);\n        Market storage m = _poolMarkets[index];\n\n        if (!m.isListed) {\n            revert MarketConfigNotFound();\n        }\n\n        if (m.isBorrowAllowed == borrowAllowed) {\n            return;\n        }\n\n        m.isBorrowAllowed = borrowAllowed;\n\n        emit BorrowAllowedUpdated(poolId, vToken, borrowAllowed);\n    }\n\n    /**\n     * @dev Updates the valid price oracle. Used by _setPriceOracle and setPriceOracle\n     * @param newOracle The new price oracle to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setPriceOracle(\n        ResilientOracleInterface newOracle\n    ) internal compareAddress(address(oracle), address(newOracle)) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        ResilientOracleInterface oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the close factor. Used by _setCloseFactor and setCloseFactor\n     * @param newCloseFactorMantissa The new close factor to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setCloseFactor(\n        uint256 newCloseFactorMantissa\n    ) internal compareValue(closeFactorMantissa, newCloseFactorMantissa) returns (uint256) {\n        // Check caller is admin\n        ensureAdmin();\n\n        Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n\n        //-- Check close factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n        //-- Check close factor >= 0.05\n        Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n\n        if (lessThanExp(highLimit, newCloseFactorExp) || greaterThanExp(lowLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the collateral factor. Used by _setCollateralFactor and setCollateralFactor\n     * @param poolId The ID of the pool.\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setCollateralFactor(\n        uint96 poolId,\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) internal returns (uint256) {\n        ensureNonzeroAddress(address(vToken));\n\n        // Check if pool exists\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        // Verify market is listed in the pool\n        Market storage market = _poolMarkets[getPoolMarketIndex(poolId, address(vToken))];\n        ensureListed(market);\n\n        //-- Check collateral factor <= 1\n        if (newCollateralFactorMantissa > mantissaOne) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(vToken)) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Ensure that liquidation threshold <= 1\n        if (newLiquidationThresholdMantissa > mantissaOne) {\n            return fail(Error.INVALID_LIQUIDATION_THRESHOLD, FailureInfo.SET_LIQUIDATION_THRESHOLD_VALIDATION);\n        }\n\n        // Ensure that liquidation threshold >= CF\n        if (newLiquidationThresholdMantissa < newCollateralFactorMantissa) {\n            return\n                fail(\n                    Error.INVALID_LIQUIDATION_THRESHOLD,\n                    FailureInfo.COLLATERAL_FACTOR_GREATER_THAN_LIQUIDATION_THRESHOLD\n                );\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        if (newCollateralFactorMantissa != oldCollateralFactorMantissa) {\n            market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n            // Emit event with poolId, asset, old collateral factor, and new collateral factor\n            emit NewCollateralFactor(poolId, vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n        }\n\n        uint256 oldLiquidationThresholdMantissa = market.liquidationThresholdMantissa;\n        if (newLiquidationThresholdMantissa != oldLiquidationThresholdMantissa) {\n            market.liquidationThresholdMantissa = newLiquidationThresholdMantissa;\n\n            emit NewLiquidationThreshold(\n                poolId,\n                vToken,\n                oldLiquidationThresholdMantissa,\n                newLiquidationThresholdMantissa\n            );\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the liquidation incentive. Used by setLiquidationIncentive\n     * @param poolId The ID of the pool.\n     * @param vToken The market to set the Incentive for\n     * @param newLiquidationIncentiveMantissa The new liquidation incentive to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setLiquidationIncentive(\n        uint96 poolId,\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    )\n        internal\n        compareValue(\n            _poolMarkets[getPoolMarketIndex(poolId, vToken)].liquidationIncentiveMantissa,\n            newLiquidationIncentiveMantissa\n        )\n        returns (uint256)\n    {\n        // Check if pool exists\n        if (poolId > lastPoolId) revert PoolDoesNotExist(poolId);\n\n        // Verify market is listed in the pool\n        Market storage market = _poolMarkets[getPoolMarketIndex(poolId, vToken)];\n        ensureListed(market);\n\n        require(newLiquidationIncentiveMantissa >= mantissaOne, \"incentive < 1e18\");\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(poolId, market.liquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        // Set liquidation incentive to new incentive\n        market.liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the borrow caps. Used by _setMarketBorrowCaps and setMarketBorrowCaps\n     * @param vTokens The markets to set the borrow caps on\n     * @param newBorrowCaps The new borrow caps to be set\n     */\n    function __setMarketBorrowCaps(VToken[] memory vTokens, uint256[] memory newBorrowCaps) internal {\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\n\n        uint256 numMarkets = vTokens.length;\n        uint256 numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint256 i; i < numMarkets; ++i) {\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Updates the supply caps. Used by _setMarketSupplyCaps and setMarketSupplyCaps\n     * @param vTokens The markets to set the supply caps on\n     * @param newSupplyCaps The new supply caps to be set\n     */\n    function __setMarketSupplyCaps(VToken[] memory vTokens, uint256[] memory newSupplyCaps) internal {\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\n\n        uint256 numMarkets = vTokens.length;\n        uint256 numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint256 i; i < numMarkets; ++i) {\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Updates the prime token. Used by _setPrimeToken and setPrimeToken\n     * @param _prime The new prime token to be set\n     * @return uint256 0=success, otherwise reverted\n     */\n    function __setPrimeToken(IPrime _prime) internal returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(_prime));\n\n        IPrime oldPrime = prime;\n        prime = _prime;\n        emit NewPrimeToken(oldPrime, _prime);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Updates the forced liquidation. Used by _setForcedLiquidation and setForcedLiquidation\n     * @param vTokenBorrowed The market to set the forced liquidation on\n     * @param enable Whether to enable forced liquidations\n     */\n    function __setForcedLiquidation(address vTokenBorrowed, bool enable) internal {\n        ensureAllowed(\"_setForcedLiquidation(address,bool)\");\n        if (vTokenBorrowed != address(vaiController)) {\n            ensureListed(getCorePoolMarket(vTokenBorrowed));\n        }\n        isForcedLiquidationEnabled[vTokenBorrowed] = enable;\n        emit IsForcedLiquidationEnabledUpdated(vTokenBorrowed, enable);\n    }\n\n    /**\n     * @dev Updates the actions paused. Used by _setActionsPaused and setActionsPaused\n     * @param markets_ The markets to set the actions paused on\n     * @param actions_ The actions to set the paused state on\n     * @param paused_ The new paused state to be set\n     */\n    function __setActionsPaused(address[] memory markets_, Action[] memory actions_, bool paused_) internal {\n        ensureAllowed(\"_setActionsPaused(address[],uint8[],bool)\");\n\n        uint256 numMarkets = markets_.length;\n        uint256 numActions = actions_.length;\n        for (uint256 marketIdx; marketIdx < numMarkets; ++marketIdx) {\n            for (uint256 actionIdx; actionIdx < numActions; ++actionIdx) {\n                setActionPausedInternal(markets_[marketIdx], actions_[actionIdx], paused_);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/facets/XVSRewardsHelper.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { FacetBase } from \"./FacetBase.sol\";\n\n/**\n * @title XVSRewardsHelper\n * @author Venus\n * @dev This contract contains internal functions used in RewardFacet and PolicyFacet\n * @notice This facet contract contains the shared functions used by the RewardFacet and PolicyFacet\n */\ncontract XVSRewardsHelper is FacetBase {\n    /// @notice Emitted when XVS is distributed to a borrower\n    event DistributedBorrowerVenus(\n        VToken indexed vToken,\n        address indexed borrower,\n        uint256 venusDelta,\n        uint256 venusBorrowIndex\n    );\n\n    /// @notice Emitted when XVS is distributed to a supplier\n    event DistributedSupplierVenus(\n        VToken indexed vToken,\n        address indexed supplier,\n        uint256 venusDelta,\n        uint256 venusSupplyIndex\n    );\n\n    /**\n     * @notice Accrue XVS to the market by updating the borrow index\n     * @param vToken The market whose borrow index to update\n     */\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n        uint256 borrowSpeed = venusBorrowSpeeds[vToken];\n        uint32 blockNumber = getBlockNumberAsUint32();\n        uint256 deltaBlocks = sub_(blockNumber, borrowState.block);\n        if (deltaBlocks != 0 && borrowSpeed != 0) {\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n            uint256 accruedVenus = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount != 0 ? fraction(accruedVenus, borrowAmount) : Double({ mantissa: 0 });\n            borrowState.index = safe224(add_(Double({ mantissa: borrowState.index }), ratio).mantissa, \"224\");\n            borrowState.block = blockNumber;\n        } else if (deltaBlocks != 0) {\n            borrowState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Accrue XVS to the market by updating the supply index\n     * @param vToken The market whose supply index to update\n     */\n    function updateVenusSupplyIndex(address vToken) internal {\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        uint256 supplySpeed = venusSupplySpeeds[vToken];\n        uint32 blockNumber = getBlockNumberAsUint32();\n\n        uint256 deltaBlocks = sub_(blockNumber, supplyState.block);\n        if (deltaBlocks != 0 && supplySpeed != 0) {\n            uint256 supplyTokens = VToken(vToken).totalSupply();\n            uint256 accruedVenus = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens != 0 ? fraction(accruedVenus, supplyTokens) : Double({ mantissa: 0 });\n            supplyState.index = safe224(add_(Double({ mantissa: supplyState.index }), ratio).mantissa, \"224\");\n            supplyState.block = blockNumber;\n        } else if (deltaBlocks != 0) {\n            supplyState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\n     * @param vToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute XVS to\n     */\n    function distributeSupplierVenus(address vToken, address supplier) internal {\n        if (address(vaiVaultAddress) != address(0)) {\n            releaseToVault();\n        }\n        uint256 supplyIndex = venusSupplyState[vToken].index;\n        uint256 supplierIndex = venusSupplierIndex[vToken][supplier];\n        // Update supplier's index to the current index since we are distributing accrued XVS\n        venusSupplierIndex[vToken][supplier] = supplyIndex;\n        if (supplierIndex == 0 && supplyIndex >= venusInitialIndex) {\n            // Covers the case where users supplied tokens before the market's supply state index was set.\n            // Rewards the user with XVS accrued from the start of when supplier rewards were first\n            // set for the market.\n            supplierIndex = venusInitialIndex;\n        }\n        // Calculate change in the cumulative sum of the XVS per vToken accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\n        // Multiply of supplierTokens and supplierDelta\n        uint256 supplierDelta = mul_(VToken(vToken).balanceOf(supplier), deltaIndex);\n        // Addition of supplierAccrued and supplierDelta\n        venusAccrued[supplier] = add_(venusAccrued[supplier], supplierDelta);\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex);\n    }\n\n    /**\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol\n     * @param vToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute XVS to\n     */\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\n        if (address(vaiVaultAddress) != address(0)) {\n            releaseToVault();\n        }\n        uint256 borrowIndex = venusBorrowState[vToken].index;\n        uint256 borrowerIndex = venusBorrowerIndex[vToken][borrower];\n        // Update borrowers's index to the current index since we are distributing accrued XVS\n        venusBorrowerIndex[vToken][borrower] = borrowIndex;\n        if (borrowerIndex == 0 && borrowIndex >= venusInitialIndex) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\n            // Rewards the user with XVS accrued from the start of when borrower rewards were first\n            // set for the market.\n            borrowerIndex = venusInitialIndex;\n        }\n        // Calculate change in the cumulative sum of the XVS per borrowed unit accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\n        uint256 borrowerDelta = mul_(div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex), deltaIndex);\n        venusAccrued[borrower] = add_(venusAccrued[borrower], borrowerDelta);\n        emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex);\n    }\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    function diamondCut(FacetCut[] calldata _diamondCut) external;\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IFacetBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { Action } from \"../../../Comptroller/ComptrollerInterface.sol\";\nimport { PoolMarketId } from \"../../../Comptroller/Types/PoolMarketId.sol\";\n\nenum WeightFunction {\n    /// @notice Use the collateral factor of the asset for weighting\n    USE_COLLATERAL_FACTOR,\n    /// @notice Use the liquidation threshold of the asset for weighting\n    USE_LIQUIDATION_THRESHOLD\n}\n\ninterface IFacetBase {\n    /**\n     * @notice The initial XVS rewards index for a market\n     */\n    function venusInitialIndex() external pure returns (uint224);\n\n    /**\n     * @notice Checks if a certain action is paused on a market\n     * @param action Action id\n     * @param market vToken address\n     */\n    function actionPaused(address market, Action action) external view returns (bool);\n\n    /**\n     * @notice Returns the XVS address\n     * @return The address of XVS token\n     */\n    function getXVSAddress() external view returns (address);\n\n    function getPoolMarketIndex(uint96 poolId, address vToken) external pure returns (PoolMarketId);\n\n    function corePoolId() external pure returns (uint96);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IMarketFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { WeightFunction } from \"./IFacetBase.sol\";\n\ninterface IMarketFacet {\n    function isComptroller() external pure returns (bool);\n\n    function liquidateCalculateSeizeTokens(\n        address borrower,\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256);\n\n    function checkMembership(address account, VToken vToken) external view returns (bool);\n\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory);\n\n    function exitMarket(address vToken) external returns (uint256);\n\n    function _supportMarket(VToken vToken) external returns (uint256);\n\n    function supportMarket(VToken vToken) external returns (uint256);\n\n    function isMarketListed(VToken vToken) external view returns (bool);\n\n    function getAssetsIn(address account) external view returns (VToken[] memory);\n\n    function getAllMarkets() external view returns (VToken[] memory);\n\n    function updateDelegate(address delegate, bool allowBorrows) external;\n\n    function unlistMarket(address market) external returns (uint256);\n\n    function createPool(string memory label) external returns (uint96);\n\n    function enterPool(uint96 poolId) external;\n\n    function addPoolMarkets(uint96[] calldata poolIds, address[] calldata vTokens) external;\n\n    function removePoolMarket(uint96 poolId, address vToken) external;\n\n    function markets(\n        address vToken\n    )\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 liquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        );\n\n    function poolMarkets(\n        uint96 poolId,\n        address vToken\n    )\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isVenus,\n            uint256 liquidationThresholdMantissa,\n            uint256 maxLiquidationIncentiveMantissa,\n            uint96 marketPoolId,\n            bool isBorrowAllowed\n        );\n\n    function hasValidPoolBorrows(address user, uint96 targetPoolId) external view returns (bool);\n\n    function getCollateralFactor(address vToken) external view returns (uint256);\n\n    function getLiquidationThreshold(address vToken) external view returns (uint256);\n\n    function getLiquidationIncentive(address vToken) external view returns (uint256);\n\n    function getEffectiveLtvFactor(\n        address account,\n        address vToken,\n        WeightFunction weightingStrategy\n    ) external view returns (uint256);\n\n    function getEffectiveLiquidationIncentive(address account, address vToken) external view returns (uint256);\n\n    function getPoolVTokens(uint96 poolId) external view returns (address[] memory);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IPolicyFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\n\ninterface IPolicyFacet {\n    function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256);\n\n    function mintVerify(address vToken, address minter, uint256 mintAmount, uint256 mintTokens) external;\n\n    function redeemAllowed(address vToken, address redeemer, uint256 redeemTokens) external returns (uint256);\n\n    function redeemVerify(address vToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\n\n    function borrowAllowed(address vToken, address borrower, uint256 borrowAmount) external returns (uint256);\n\n    function borrowVerify(address vToken, address borrower, uint256 borrowAmount) external;\n\n    function repayBorrowAllowed(\n        address vToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external view returns (uint256);\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(address vToken, address src, address dst, uint256 transferTokens) external;\n\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256);\n\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external view returns (uint256, uint256, uint256);\n\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint256[] calldata supplySpeeds,\n        uint256[] calldata borrowSpeeds\n    ) external;\n\n    function executeFlashLoan(\n        address payable initiator,\n        address payable receiver,\n        VToken[] calldata assets,\n        uint256[] calldata underlyingAmounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata param\n    ) external;\n    function getBorrowingPower(\n        address account\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/IRewardFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { IFacetBase } from \"./IFacetBase.sol\";\n\ninterface IRewardFacet is IFacetBase {\n    function claimVenus(address holder) external;\n\n    function claimVenus(address holder, VToken[] calldata vTokens) external;\n\n    function claimVenus(address[] calldata holders, VToken[] calldata vTokens, bool borrowers, bool suppliers) external;\n\n    function claimVenusAsCollateral(address holder) external;\n\n    function _grantXVS(address recipient, uint256 amount) external;\n\n    function getXVSVTokenAddress() external view returns (address);\n\n    function claimVenus(\n        address[] calldata holders,\n        VToken[] calldata vTokens,\n        bool borrowers,\n        bool suppliers,\n        bool collateral\n    ) external;\n    function seizeVenus(address[] calldata holders, address recipient) external returns (uint256);\n}\n"
    },
    "contracts/Comptroller/Diamond/interfaces/ISetterFacet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { VToken } from \"../../../Tokens/VTokens/VToken.sol\";\nimport { Action } from \"../../ComptrollerInterface.sol\";\nimport { VAIControllerInterface } from \"../../../Tokens/VAI/VAIControllerInterface.sol\";\nimport { ComptrollerLensInterface } from \"../../../Comptroller/ComptrollerLensInterface.sol\";\nimport { IPrime } from \"../../../Tokens/Prime/IPrime.sol\";\n\ninterface ISetterFacet {\n    function setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256);\n\n    function _setPriceOracle(ResilientOracleInterface newOracle) external returns (uint256);\n\n    function setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n    function _setAccessControl(address newAccessControlAddress) external returns (uint256);\n\n    function setCollateralFactor(\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256);\n\n    function setCollateralFactor(\n        uint96 poolId,\n        VToken vToken,\n        uint256 newCollateralFactorMantissa,\n        uint256 newLiquidationThresholdMantissa\n    ) external returns (uint256);\n\n    function setLiquidationIncentive(\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    ) external returns (uint256);\n\n    function setLiquidationIncentive(\n        uint96 poolId,\n        address vToken,\n        uint256 newLiquidationIncentiveMantissa\n    ) external returns (uint256);\n\n    function _setLiquidatorContract(address newLiquidatorContract_) external;\n\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint256);\n\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external;\n\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external;\n\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external;\n\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external;\n\n    function _setProtocolPaused(bool state) external returns (bool);\n\n    function setActionsPaused(address[] calldata markets, Action[] calldata actions, bool paused) external;\n\n    function _setActionsPaused(address[] calldata markets, Action[] calldata actions, bool paused) external;\n\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint256);\n\n    function _setVAIMintRate(uint256 newVAIMintRate) external returns (uint256);\n\n    function setMintedVAIOf(address owner, uint256 amount) external returns (uint256);\n\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint256 newTreasuryPercent\n    ) external returns (uint256);\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external returns (uint256);\n\n    function _setVenusVAIVaultRate(uint256 venusVAIVaultRate_) external;\n\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) external;\n\n    function _setForcedLiquidation(address vToken, bool enable) external;\n\n    function setPrimeToken(IPrime _prime) external returns (uint256);\n\n    function _setPrimeToken(IPrime _prime) external returns (uint);\n\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external;\n\n    function _setForcedLiquidationForUser(address borrower, address vTokenBorrowed, bool enable) external;\n\n    function _setXVSToken(address xvs_) external;\n\n    function _setXVSVToken(address xvsVToken_) external;\n\n    function setWhiteListFlashLoanAccount(address account, bool _isWhiteListed) external;\n    function setDelegateAuthorizationFlashloan(address market, address delegate, bool approved) external;\n    function setIsBorrowAllowed(uint96 poolId, address vToken, bool borrowAllowed) external;\n}\n"
    },
    "contracts/Comptroller/Types/PoolMarketId.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\n/// @notice Strongly-typed identifier for pool markets mapping keys\n/// @dev Underlying storage is bytes32: first 12 bytes (96 bits) = poolId, last 20 bytes = vToken address\ntype PoolMarketId is bytes32;\n\n "
    },
    "contracts/Comptroller/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { UnitrollerAdminStorage } from \"./ComptrollerStorage.sol\";\nimport { ComptrollerErrorReporter } from \"../Utils/ErrorReporter.sol\";\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * VTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n    /**\n     * @notice Emitted when pendingComptrollerImplementation is changed\n     */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n     * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n        }\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptImplementation() public returns (uint) {\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = comptrollerImplementation;\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller is pendingAdmin\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/external/IProtocolShareReserve.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\ninterface IProtocolShareReserve {\n    enum IncomeType {\n        SPREAD,\n        LIQUIDATION,\n        FLASHLOAN\n    }\n\n    function updateAssetsState(address comptroller, address asset, IncomeType incomeType) external;\n}\n"
    },
    "contracts/FlashLoan/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { VToken } from \"../../Tokens/VTokens/VToken.sol\";\n\n/// @title IFlashLoanReceiver\n/// @notice Interface for flashLoan receiver contract, which execute custom logic with flash-borrowed assets.\n/// @dev This interface defines the method that must be implemented by any contract wishing to interact with the flashLoan system.\n///      Contracts must ensure they have the means to repay both the flashLoan amount and the associated premium (fee).\ninterface IFlashLoanReceiver {\n    /**\n     * @notice Executes an operation after receiving the flash-borrowed assets.\n     * @dev Implementation of this function must ensure the borrowed amount plus the premium (fee) is repaid within the same transaction.\n     * @param assets The assets that were flash-borrowed.\n     * @param amounts The amounts of each of the flash-borrowed assets.\n     * @param premiums The premiums (fees) associated with each flash-borrowed asset.\n     * @param initiator The address that initiated the flashLoan operation.\n     * @param param Additional parameters encoded as bytes. These can be used to pass custom data to the receiver contract.\n     * @return True if the operation succeeds and the borrowed amount plus the premium is repaid, false otherwise.\n     */\n    function executeOperation(\n        VToken[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata param\n    ) external returns (bool);\n}\n"
    },
    "contracts/FlashLoan/interfaces/IFlashLoanSimpleReceiver.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/// @title IFlashLoanSimpleReceiver\n/// @notice Interface for flashLoan receiver contract, which execute custom logic with flash-borrowed asset.\n/// @dev This interface defines the method that must be implemented by any contract wishing to interact with the flashLoan system.\n///      Contracts must ensure they have the means to repay both the flashLoan amount and the associated premium (fee).\ninterface IFlashLoanSimpleReceiver {\n    /**\n     * @notice Executes an operation after receiving the flash-borrowed asset\n     * @dev Ensure that the contract can return the debt + premium, e.g., has\n     *      enough funds to repay and has to transfer the debt + premium to the VToken\n     * @param asset The address of the flash-borrowed asset\n     * @param amount The amount of the flash-borrowed asset\n     * @param premium The premium (fee) associated with flash-borrowed asset.\n     * @param initiator The address that initiated the flashLoan operation\n     * @param param The byte-encoded param passed when initiating the flashLoan\n     * @return True if the execution of the operation succeeds, false otherwise\n     */\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address initiator,\n        bytes calldata param\n    ) external returns (bool);\n}\n"
    },
    "contracts/InterestRateModels/InterestRateModelV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Venus's InterestRateModelV8 Interface\n * @author Venus\n */\nabstract contract InterestRateModelV8 {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view virtual returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view virtual returns (uint256);\n}\n"
    },
    "contracts/test/ComptrollerHarness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"./ComptrollerMock.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\ncontract ComptrollerHarness is ComptrollerMock {\n    address internal xvsAddress;\n    address internal vXVSAddress;\n    uint public blockNumber;\n\n    constructor() ComptrollerMock() {}\n\n    function setVenusSupplyState(address vToken, uint224 index, uint32 blockNumber_) public {\n        venusSupplyState[vToken].index = index;\n        venusSupplyState[vToken].block = blockNumber_;\n    }\n\n    function setVenusBorrowState(address vToken, uint224 index, uint32 blockNumber_) public {\n        venusBorrowState[vToken].index = index;\n        venusBorrowState[vToken].block = blockNumber_;\n    }\n\n    function setVenusAccrued(address user, uint userAccrued) public {\n        venusAccrued[user] = userAccrued;\n    }\n\n    function setXVSAddress(address xvsAddress_) public {\n        xvsAddress = xvsAddress_;\n    }\n\n    function setXVSVTokenAddress(address vXVSAddress_) public {\n        vXVSAddress = vXVSAddress_;\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block\n     * @param venusRate_ The amount of XVS wei per block to distribute\n     */\n    function harnessSetVenusRate(uint venusRate_) public {\n        venusRate = venusRate_;\n    }\n\n    /**\n     * @notice Recalculate and update XVS speeds for all XVS markets\n     */\n    function harnessRefreshVenusSpeeds() public {\n        VToken[] memory allMarkets_ = allMarkets;\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusSupplyIndex(address(vToken));\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n        }\n\n        Exp memory totalUtility = Exp({ mantissa: 0 });\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            if (venusSpeeds[address(vToken)] > 0) {\n                Exp memory assetPrice = Exp({ mantissa: oracle.getUnderlyingPrice(address(vToken)) });\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\n                utilities[i] = utility;\n                totalUtility = add_(totalUtility, utility);\n            }\n        }\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets[i];\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\n            setVenusSpeedInternal(vToken, newSpeed, newSpeed);\n        }\n    }\n\n    function setVenusBorrowerIndex(address vToken, address borrower, uint index) public {\n        venusBorrowerIndex[vToken][borrower] = index;\n    }\n\n    function setVenusSupplierIndex(address vToken, address supplier, uint index) public {\n        venusSupplierIndex[vToken][supplier] = index;\n    }\n\n    function harnessDistributeAllBorrowerVenus(\n        address vToken,\n        address borrower,\n        uint marketBorrowIndexMantissa\n    ) public {\n        distributeBorrowerVenus(vToken, borrower, Exp({ mantissa: marketBorrowIndexMantissa }));\n        venusAccrued[borrower] = grantXVSInternal(borrower, venusAccrued[borrower], 0, false);\n    }\n\n    function harnessDistributeAllSupplierVenus(address vToken, address supplier) public {\n        distributeSupplierVenus(vToken, supplier);\n        venusAccrued[supplier] = grantXVSInternal(supplier, venusAccrued[supplier], 0, false);\n    }\n\n    function harnessUpdateVenusBorrowIndex(address vToken, uint marketBorrowIndexMantissa) public {\n        updateVenusBorrowIndex(vToken, Exp({ mantissa: marketBorrowIndexMantissa }));\n    }\n\n    function harnessUpdateVenusSupplyIndex(address vToken) public {\n        updateVenusSupplyIndex(vToken);\n    }\n\n    function harnessDistributeBorrowerVenus(address vToken, address borrower, uint marketBorrowIndexMantissa) public {\n        distributeBorrowerVenus(vToken, borrower, Exp({ mantissa: marketBorrowIndexMantissa }));\n    }\n\n    function harnessDistributeSupplierVenus(address vToken, address supplier) public {\n        distributeSupplierVenus(vToken, supplier);\n    }\n\n    function harnessTransferVenus(address user, uint userAccrued, uint threshold) public returns (uint) {\n        if (userAccrued > 0 && userAccrued >= threshold) {\n            return grantXVSInternal(user, userAccrued, 0, false);\n        }\n        return userAccrued;\n    }\n\n    function harnessAddVenusMarkets(address[] memory vTokens) public {\n        for (uint i = 0; i < vTokens.length; i++) {\n            // temporarily set venusSpeed to 1 (will be fixed by `harnessRefreshVenusSpeeds`)\n            setVenusSpeedInternal(VToken(vTokens[i]), 1, 1);\n        }\n    }\n\n    function harnessSetMintedVAIs(address user, uint amount) public {\n        mintedVAIs[user] = amount;\n    }\n\n    function harnessFastForward(uint blocks) public returns (uint) {\n        blockNumber += blocks;\n        return blockNumber;\n    }\n\n    function setBlockNumber(uint number) public {\n        blockNumber = number;\n    }\n\n    function getBlockNumber() internal view override returns (uint) {\n        return blockNumber;\n    }\n\n    function getVenusMarkets() public view returns (address[] memory) {\n        uint m = allMarkets.length;\n        uint n = 0;\n        for (uint i = 0; i < m; i++) {\n            if (venusSpeeds[address(allMarkets[i])] > 0) {\n                n++;\n            }\n        }\n\n        address[] memory venusMarkets = new address[](n);\n        uint k = 0;\n        for (uint i = 0; i < m; i++) {\n            if (venusSpeeds[address(allMarkets[i])] > 0) {\n                venusMarkets[k++] = address(allMarkets[i]);\n            }\n        }\n        return venusMarkets;\n    }\n\n    function harnessSetReleaseStartBlock(uint startBlock) external {\n        releaseStartBlock = startBlock;\n    }\n\n    function harnessAddVtoken(address vToken) external {\n        _poolMarkets[getCorePoolMarketIndex(vToken)].isListed = true;\n    }\n}\n\ncontract EchoTypesComptroller is UnitrollerAdminStorage {\n    function stringy(string memory s) public pure returns (string memory) {\n        return s;\n    }\n\n    function addresses(address a) public pure returns (address) {\n        return a;\n    }\n\n    function booly(bool b) public pure returns (bool) {\n        return b;\n    }\n\n    function listOInts(uint[] memory u) public pure returns (uint[] memory) {\n        return u;\n    }\n\n    function reverty() public pure {\n        require(false, \"gotcha sucka\");\n    }\n\n    function becomeBrains(address payable unitroller) public {\n        Unitroller(unitroller)._acceptImplementation();\n    }\n}\n"
    },
    "contracts/test/ComptrollerMock.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/facets/MarketFacet.sol\";\nimport \"../Comptroller/Diamond/facets/PolicyFacet.sol\";\nimport \"../Comptroller/Diamond/facets/RewardFacet.sol\";\nimport \"../Comptroller/Diamond/facets/SetterFacet.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\n// This contract contains all methods of Comptroller implementation in different facets at one place for testing purpose\n// This contract does not have diamond functionality(i.e delegate call to facets methods)\ncontract ComptrollerMock is MarketFacet, PolicyFacet, RewardFacet, SetterFacet {\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external override returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/test/ComptrollerMockR1.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/facets/MarketFacet.sol\";\nimport \"../Comptroller/Diamond/facets/PolicyFacet.sol\";\nimport \"../Comptroller/Diamond/facets/RewardFacet.sol\";\nimport \"../Comptroller/Diamond/facets/SetterFacet.sol\";\nimport \"../Comptroller/Unitroller.sol\";\n\n// This contract contains all methods of Comptroller implementation in different facets at one place for testing purpose\n// This contract does not have diamond functionality(i.e delegate call to facets methods)\ncontract ComptrollerMockR1 is MarketFacet, PolicyFacet, RewardFacet, SetterFacet {\n    event MarketListed(address vToken);\n    event NewCollateralFactor(address vToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n    event MarketEntered(address vToken, address account);\n    event MarketExited(address vToken, address account);\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external override returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n}\n"
    },
    "contracts/test/ComptrollerScenario.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"./ComptrollerMock.sol\";\n\ncontract ComptrollerScenario is ComptrollerMock {\n    uint public blockNumber;\n    address public xvsAddress;\n    address public vaiAddress;\n\n    constructor() ComptrollerMock() {}\n\n    function setXVSAddress(address xvsAddress_) public {\n        xvsAddress = xvsAddress_;\n    }\n\n    // function getXVSAddress() public view returns (address) {\n    //     return xvsAddress;\n    // }\n\n    function setVAIAddress(address vaiAddress_) public {\n        vaiAddress = vaiAddress_;\n    }\n\n    function getVAIAddress() public view returns (address) {\n        return vaiAddress;\n    }\n\n    function membershipLength(VToken vToken) public view returns (uint) {\n        return accountAssets[address(vToken)].length;\n    }\n\n    function fastForward(uint blocks) public returns (uint) {\n        blockNumber += blocks;\n\n        return blockNumber;\n    }\n\n    function setBlockNumber(uint number) public {\n        blockNumber = number;\n    }\n\n    function getBlockNumber() internal view override returns (uint) {\n        return blockNumber;\n    }\n\n    function getVenusMarkets() public view returns (address[] memory) {\n        uint m = allMarkets.length;\n        uint n = 0;\n        for (uint i = 0; i < m; i++) {\n            if (getCorePoolMarket(address(allMarkets[i])).isVenus) {\n                n++;\n            }\n        }\n\n        address[] memory venusMarkets = new address[](n);\n        uint k = 0;\n        for (uint i = 0; i < m; i++) {\n            if (getCorePoolMarket(address(allMarkets[i])).isVenus) {\n                venusMarkets[k++] = address(allMarkets[i]);\n            }\n        }\n        return venusMarkets;\n    }\n\n    function unlist(VToken vToken) public {\n        _poolMarkets[getCorePoolMarketIndex(address(vToken))].isListed = false;\n    }\n\n    /**\n     * @notice Recalculate and update XVS speeds for all XVS markets\n     */\n    function refreshVenusSpeeds() public {\n        VToken[] memory allMarkets_ = allMarkets;\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusSupplyIndex(address(vToken));\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n        }\n\n        Exp memory totalUtility = Exp({ mantissa: 0 });\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets_[i];\n            if (venusSpeeds[address(vToken)] > 0) {\n                Exp memory assetPrice = Exp({ mantissa: oracle.getUnderlyingPrice(address(vToken)) });\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\n                utilities[i] = utility;\n                totalUtility = add_(totalUtility, utility);\n            }\n        }\n\n        for (uint i = 0; i < allMarkets_.length; i++) {\n            VToken vToken = allMarkets[i];\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\n            setVenusSpeedInternal(vToken, newSpeed, newSpeed);\n        }\n    }\n}\n"
    },
    "contracts/test/DiamondHarness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Comptroller/Diamond/Diamond.sol\";\n\ncontract DiamondHarness is Diamond {\n    function getFacetAddress(bytes4 sig) public view returns (address) {\n        address facet = _selectorToFacetAndPosition[sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        return facet;\n    }\n}\n"
    },
    "contracts/test/EvilXToken.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VTokens/VBep20Immutable.sol\";\nimport \"../Tokens/VTokens/VBep20Delegator.sol\";\nimport \"../Tokens/VTokens/VBep20Delegate.sol\";\nimport \"./ComptrollerScenario.sol\";\nimport \"../Comptroller/ComptrollerInterface.sol\";\n\ncontract VBep20Scenario is VBep20Immutable {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\n// doTransferOut method of this token supposed to be compromised and contians malicious code which\n// can be used by attacker to compromise the protocol working.\ncontract EvilXToken is VBep20Delegate {\n    event Log(string x, address y);\n    event Log(string x, uint y);\n    event LogLiquidity(uint liquidity);\n\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    address public comptrollerAddress;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    function setComptrollerAddress(address _comptrollerAddress) external {\n        comptrollerAddress = _comptrollerAddress;\n    }\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        super.doTransferOut(to, amount);\n\n        // Checking the Liquidity of the user after the tranfer.\n        // solhint-disable-next-line no-unused-vars\n        (uint errorCode, uint liquidity, uint shortfall) = ComptrollerInterface(comptrollerAddress).getAccountLiquidity(\n            msg.sender\n        );\n        emit LogLiquidity(liquidity);\n        return;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\n        totalBorrows = totalBorrows + addtlBorrow_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n    }\n}\n"
    },
    "contracts/test/VBep20Harness.sol": {
      "content": "pragma solidity 0.8.25;\n\nimport \"../Tokens/VTokens/VBep20Immutable.sol\";\nimport \"../Tokens/VTokens/VBep20Delegator.sol\";\nimport \"../Tokens/VTokens/VBep20Delegate.sol\";\nimport \"./ComptrollerScenario.sol\";\n\ncontract VBep20Harness is VBep20Immutable {\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        return super.doTransferOut(to, amount);\n    }\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n    }\n}\n\ncontract VBep20Scenario is VBep20Immutable {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Immutable(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\ncontract VEvil is VBep20Scenario {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    )\n        VBep20Scenario(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_\n        )\n    {}\n\n    function evilSeize(VToken treasure, address liquidator, address borrower, uint seizeTokens) public returns (uint) {\n        return treasure.seize(liquidator, borrower, seizeTokens);\n    }\n}\n\nabstract contract VBep20DelegatorScenario is VBep20Delegator {\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address implementation_,\n        bytes memory becomeImplementationData,\n        bool flashLoanEnabled_,\n        uint256 flashLoanProtocolFeeMantissa_,\n        uint256 flashLoanSupplierFeeMantissa_\n    )\n        VBep20Delegator(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_,\n            implementation_,\n            becomeImplementationData,\n            flashLoanEnabled_,\n            flashLoanProtocolFeeMantissa_,\n            flashLoanSupplierFeeMantissa_\n        )\n    {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n}\n\ncontract VBep20DelegateHarness is VBep20Delegate {\n    event Log(string x, address y);\n    event Log(string x, uint y);\n\n    uint internal blockNumber = 100000;\n    uint internal harnessExchangeRate;\n    bool internal harnessExchangeRateStored;\n\n    mapping(address => bool) public failTransferToAddresses;\n\n    function exchangeRateStoredInternal() internal view override returns (MathError, uint) {\n        if (harnessExchangeRateStored) {\n            return (MathError.NO_ERROR, harnessExchangeRate);\n        }\n        return super.exchangeRateStoredInternal();\n    }\n\n    function doTransferOut(address payable to, uint amount) internal override {\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\n        return super.doTransferOut(to, amount);\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        return blockNumber;\n    }\n\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\n        return borrowRateMaxMantissa;\n    }\n\n    function harnessSetBlockNumber(uint newBlockNumber) public {\n        blockNumber = newBlockNumber;\n    }\n\n    function harnessFastForward(uint blocks) public {\n        blockNumber += blocks;\n    }\n\n    function harnessSetBalance(address account, uint amount) external {\n        accountTokens[account] = amount;\n    }\n\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\n        accrualBlockNumber = _accrualblockNumber;\n    }\n\n    function harnessSetTotalSupply(uint totalSupply_) public {\n        totalSupply = totalSupply_;\n    }\n\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\n        totalBorrows = totalBorrows + addtlBorrow_;\n    }\n\n    function harnessSetTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\n        totalSupply = totalSupply_;\n        totalBorrows = totalBorrows_;\n        totalReserves = totalReserves_;\n    }\n\n    function harnessSetExchangeRate(uint exchangeRate) public {\n        harnessExchangeRate = exchangeRate;\n        harnessExchangeRateStored = true;\n    }\n\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\n        failTransferToAddresses[_to] = _fail;\n    }\n\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintFresh(account, mintAmount);\n        return err;\n    }\n\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\n        (uint err, ) = super.mintBehalfFresh(payer, receiver, mintAmount);\n        return err;\n    }\n\n    function harnessRedeemFresh(\n        address payable account,\n        uint vTokenAmount,\n        uint underlyingAmount\n    ) public returns (uint) {\n        return super.redeemFresh(account, account, vTokenAmount, underlyingAmount);\n    }\n\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\n        BorrowSnapshot memory snapshot = accountBorrows[account];\n        return (snapshot.principal, snapshot.interestIndex);\n    }\n\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\n        accountBorrows[account] = BorrowSnapshot({ principal: principal, interestIndex: interestIndex });\n    }\n\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\n        borrowIndex = borrowIndex_;\n    }\n\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\n        return borrowFresh(account, account, borrowAmount);\n    }\n\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\n        (uint err, ) = repayBorrowFresh(payer, account, repayAmount);\n        return err;\n    }\n\n    function harnessLiquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VToken vTokenCollateral\n    ) public returns (uint) {\n        (uint err, ) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\n        return _reduceReservesFresh(amount);\n    }\n\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    function harnessSetInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) public returns (uint) {\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\n        interestRateModel = InterestRateModelV8(newInterestRateModelAddress);\n    }\n\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\n    }\n}\n\ncontract VBep20DelegateScenario is VBep20Delegate {\n    constructor() {}\n\n    function setTotalBorrows(uint totalBorrows_) public {\n        totalBorrows = totalBorrows_;\n    }\n\n    function setTotalReserves(uint totalReserves_) public {\n        totalReserves = totalReserves_;\n    }\n\n    function getBlockNumber() internal view returns (uint) {\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\n        return comptrollerScenario.blockNumber();\n    }\n}\n\ncontract VBep20DelegateScenarioExtra is VBep20DelegateScenario {\n    function iHaveSpoken() public pure returns (string memory) {\n        return \"i have spoken\";\n    }\n\n    function itIsTheWay() public {\n        admin = payable(address(1)); // make a change to test effect\n    }\n\n    function babyYoda() public pure {\n        revert(\"protect the baby\");\n    }\n}\n"
    },
    "contracts/Tokens/Prime/IPrime.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title IPrime\n * @author Venus\n * @notice Interface for Prime Token\n */\ninterface IPrime {\n    /**\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\n     * @param user the account address whose balance was updated\n     */\n    function xvsUpdated(address user) external;\n\n    /**\n     * @notice accrues interest and updates score for an user for a specific market\n     * @param user the account address for which to accrue interest and update score\n     * @param market the market for which to accrue interest and update score\n     */\n    function accrueInterestAndUpdateScore(address user, address market) external;\n\n    /**\n     * @notice Distributes income from market since last distribution\n     * @param vToken the market for which to distribute the income\n     */\n    function accrueInterest(address vToken) external;\n\n    /**\n     * @notice Returns if user is a prime holder\n     * @param isPrimeHolder returns if the user is a prime holder\n     */\n    function isUserPrimeHolder(address user) external view returns (bool isPrimeHolder);\n}\n"
    },
    "contracts/Tokens/VAI/VAIControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VTokenInterface } from \"../VTokens/VTokenInterfaces.sol\";\n\ninterface VAIControllerInterface {\n    function mintVAI(uint256 mintVAIAmount) external returns (uint256);\n\n    function repayVAI(uint256 amount) external returns (uint256, uint256);\n\n    function repayVAIBehalf(address borrower, uint256 amount) external returns (uint256, uint256);\n\n    function liquidateVAI(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint256, uint256);\n\n    function getMintableVAI(address minter) external view returns (uint256, uint256);\n\n    function getVAIAddress() external view returns (address);\n\n    function getVAIRepayAmount(address account) external view returns (uint256);\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VBep20Interface, VTokenInterface } from \"./VTokenInterfaces.sol\";\nimport { VToken } from \"./VToken.sol\";\n\n/**\n * @title Venus's VBep20 Contract\n * @notice vTokens which wrap an ERC-20 underlying\n * @author Venus\n */\ncontract VBep20 is VToken, VBep20Interface {\n    using SafeERC20 for IERC20;\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits Mint event\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err, ) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param receiver The account which is receiving the vTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    // @custom:event Emits MintBehalf event\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\n        (uint err, ) = mintBehalfInternal(receiver, mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(msg.sender, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The user on behalf of whom to redeem\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemBehalf(address redeemer, uint redeemTokens) external returns (uint) {\n        require(comptroller.approvedDelegates(redeemer, msg.sender), \"not an approved delegate\");\n\n        return redeemInternal(redeemer, payable(msg.sender), redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(msg.sender, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender redeems underlying assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer, on behalf of whom to redeem\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Redeem event on success\n    // @custom:event Emits Transfer event on success\n    // @custom:event Emits RedeemFee when fee is charged by the treasury\n    function redeemUnderlyingBehalf(address redeemer, uint redeemAmount) external returns (uint) {\n        require(comptroller.approvedDelegates(redeemer, msg.sender), \"not an approved delegate\");\n\n        return redeemUnderlyingInternal(redeemer, payable(msg.sender), redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(msg.sender, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the borrower using `comptroller.updateDelegate`\n     * @param borrower The borrower, on behalf of whom to borrow.\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Borrow event on success\n    function borrowBehalf(address borrower, uint borrowAmount) external returns (uint) {\n        require(comptroller.approvedDelegates(borrower, msg.sender), \"not an approved delegate\");\n        return borrowInternal(borrower, payable(msg.sender), borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrowing account\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits RepayBorrow event on success\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emit LiquidateBorrow event on success\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint) {\n        (uint err, ) = liquidateBorrowInternal(borrower, repayAmount, vTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount of underlying tokens to add as reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits ReservesAdded event\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        // VToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @dev Similar to ERC-20 transfer, but handles tokens that have transfer fees.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     * @param from Sender of the underlying tokens\n     * @param amount Amount of underlying to transfer\n     * @return Actual amount received\n     */\n    function doTransferIn(address from, uint256 amount) internal virtual override returns (uint256) {\n        IERC20 token = IERC20(underlying);\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        uint256 balanceAfter = token.balanceOf(address(this));\n        // Return the amount that was *actually* transferred\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Just a regular ERC-20 transfer, reverts on failure\n     * @param to Receiver of the underlying tokens\n     * @param amount Amount of underlying to transfer\n     */\n    function doTransferOut(address payable to, uint256 amount) internal virtual override {\n        IERC20 token = IERC20(underlying);\n        token.safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Delegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { VBep20 } from \"./VBep20.sol\";\nimport { VDelegateInterface } from \"./VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20Delegate Contract\n * @notice VTokens which wrap an EIP-20 underlying and are delegated to\n * @author Venus\n */\ncontract VBep20Delegate is VBep20, VDelegateInterface {\n    /**\n     * @notice Construct an empty delegate\n     */\n    constructor() {}\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) public {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() public {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Delegator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VTokenInterface, VBep20Interface, VDelegatorInterface } from \"./VTokenInterfaces.sol\";\n\n/**\n * @title Venus's VBep20Delegator Contract\n * @notice vTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Venus\n */\nabstract contract VBep20Delegator is VTokenInterface, VBep20Interface, VDelegatorInterface {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     * @param flashLoanEnabled_ Enable flashLoan or not for this market\n     * @param flashLoanProtocolFeeMantissa_ FlashLoan protocol fee mantissa, transferred to protocol share reserve\n     * @param flashLoanSupplierFeeMantissa_ FlashLoan supplier fee mantissa, transferred to the supplier of the asset\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_,\n        address implementation_,\n        bytes memory becomeImplementationData,\n        bool flashLoanEnabled_,\n        uint256 flashLoanProtocolFeeMantissa_,\n        uint256 flashLoanSupplierFeeMantissa_\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"initialize(address,address,address,uint256,string,string,uint8,bool,uint256,uint256)\",\n                underlying_,\n                comptroller_,\n                interestRateModel_,\n                initialExchangeRateMantissa_,\n                name_,\n                symbol_,\n                decimals_,\n                flashLoanEnabled_,\n                flashLoanProtocolFeeMantissa_,\n                flashLoanSupplierFeeMantissa_\n            )\n        );\n\n        // New implementations always get set via the settor (post-initialize)\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mint(uint256)\", mintAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"mintBehalf(address,uint256)\", receiver, mintAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying asset\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function borrow(uint borrowAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrower\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"liquidateBorrow(address,uint256,address)\", borrower, repayAmount, vTokenCollateral)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount));\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", src, dst, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (type(uint256).max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount)\n        );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  It's absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function seize(address liquidator, address borrower, uint seizeTokens) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"seize(address,address,uint256)\", liquidator, borrower, seizeTokens)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setReserveFactor(uint newReserveFactorMantissa) external override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. `msg.sender` must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _acceptAdmin() external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and adds reserves by transferring from admin\n     * @param addAmount Amount of reserves to add\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _reduceReserves(uint reduceAmount) external override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getCash()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (type(uint256).max means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"allowance(address,address)\", owner, spender)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"balanceOf(address)\", owner));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint, uint, uint, uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"getAccountSnapshot(address)\", account)\n        );\n        return abi.decode(data, (uint, uint, uint, uint));\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this vToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    // @custom:access Only callable by admin\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) public {\n        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\n\n        if (allowResign) {\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n        }\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves.\n     * @dev This calculates interest accrued from the last checkpointed block\n     *      up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override returns (uint) {\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Admin function to set a new comptroller\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Accrues interest and updates the interest rate model using `_setInterestRateModelFresh`\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel The new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel) public override returns (uint) {\n        bytes memory data = delegateToImplementation(\n            abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n        return delegateTo(implementation, data);\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(\n            abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data)\n        );\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(\n            abi.encodeWithSignature(\"borrowBalanceStored(address)\", account)\n        );\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint) {\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\n        return abi.decode(data, (uint));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VBep20Immutable.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VBep20 } from \"./VBep20.sol\";\n\n/**\n * @title Venus's VBep20Immutable Contract\n * @notice VTokens which wrap an EIP-20 underlying and are immutable\n * @author Venus\n */\ncontract VBep20Immutable is VBep20 {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ BEP-20 name of this token\n     * @param symbol_ BEP-20 symbol of this token\n     * @param decimals_ BEP-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address payable admin_\n    ) {\n        // Creator of the contract is admin during initialization\n        admin = payable(msg.sender);\n\n        // Initialize the market\n        initialize(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_\n        );\n\n        // Set the proper admin now that initialization is done\n        admin = admin_;\n    }\n}\n"
    },
    "contracts/Tokens/VTokens/VToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport { IProtocolShareReserve } from \"../../external/IProtocolShareReserve.sol\";\nimport { ComptrollerInterface, IComptroller } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { TokenErrorReporter } from \"../../Utils/ErrorReporter.sol\";\nimport { Exponential } from \"../../Utils/Exponential.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\nimport { VTokenInterface } from \"./VTokenInterfaces.sol\";\nimport { IFlashLoanSimpleReceiver } from \"../../FlashLoan/interfaces/IFlashLoanSimpleReceiver.sol\";\n\n/**\n * @title Venus's vToken Contract\n * @notice Abstract base for vTokens\n * @author Venus\n */\nabstract contract VToken is VTokenInterface, Exponential, TokenErrorReporter {\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    // @custom:event Emits Transfer event\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    // @custom:event Emits Transfer event\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (type(uint256).max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    // @custom:event Emits Approval event on successful approve\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        transferAllowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        ensureNoMathError(mErr);\n        return balance;\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits Transfer event\n    function seize(\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external override nonReentrant returns (uint) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewPendingAdmin event with old and new admin addresses\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        // Check caller = admin\n        ensureAdmin(msg.sender);\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewAdmin event on successful acceptance\n    // @custom:event Emits NewPendingAdmin event with null new pending admin\n    function _acceptAdmin() external override returns (uint) {\n        // Check caller is pendingAdmin\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = payable(address(0));\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using `_setReserveFactorFresh`\n     * @dev Governor function to accrue interest and set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewReserveFactor event\n    function _setReserveFactor(uint newReserveFactorMantissa_) external override nonReentrant returns (uint) {\n        ensureAllowed(\"_setReserveFactor(uint256)\");\n        checkAccrueInterest(FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa_);\n    }\n\n    /**\n     * @notice Sets the address of the access control manager of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlManagerAddress New address for the access control\n     * @return uint 0=success, otherwise will revert\n     */\n    function setAccessControlManager(address newAccessControlManagerAddress) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n\n        ensureNonZeroAddress(newAccessControlManagerAddress);\n\n        emit NewAccessControlManager(accessControlManager, newAccessControlManagerAddress);\n        accessControlManager = newAccessControlManagerAddress;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to protocol share reserve\n     * @param reduceAmount_ Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits ReservesReduced event\n    function _reduceReserves(uint reduceAmount_) external virtual override nonReentrant returns (uint) {\n        ensureAllowed(\"_reduceReserves(uint256)\");\n        checkAccrueInterest(FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        // If reserves were reduced in accrueInterest\n        if (reduceReservesBlockNumber == block.number) return (uint(Error.NO_ERROR));\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount_);\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (type(uint256).max means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint, uint, uint, uint) {\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), accountTokens[account], borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this vToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Governance function to set new threshold of block difference after which funds will be sent to the protocol share reserve\n     * @param newReduceReservesBlockDelta_ block difference value\n     */\n    function setReduceReservesBlockDelta(uint256 newReduceReservesBlockDelta_) external {\n        require(newReduceReservesBlockDelta_ > 0, \"Invalid Input\");\n        ensureAllowed(\"setReduceReservesBlockDelta(uint256)\");\n        emit NewReduceReservesBlockDelta(reduceReservesBlockDelta, newReduceReservesBlockDelta_);\n        reduceReservesBlockDelta = newReduceReservesBlockDelta_;\n    }\n\n    /**\n     * @notice Sets protocol share reserve contract address\n     * @param protcolShareReserve_ The address of protocol share reserve contract\n     */\n    function setProtocolShareReserve(address payable protcolShareReserve_) external {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n        ensureNonZeroAddress(protcolShareReserve_);\n        emit NewProtocolShareReserve(protocolShareReserve, protcolShareReserve_);\n        protocolShareReserve = protcolShareReserve_;\n    }\n\n    /**\n     * @notice Transfers the underlying asset to the specified address.\n     * @dev Can only be called by the Comptroller contract. This function performs the actual transfer of the underlying\n     *      asset by calling the `doTransferOut` internal function.\n     * @param to The address to which the underlying asset is to be transferred.\n     * @param amount The amount of the underlying asset to transfer.\n     * requirements\n     *      - The caller must be the Comptroller contract.\n     * custom:reverts\n     *      - Reverts with \"Invalid Comptroller\" if the caller is not the Comptroller.\n     * custom:event Emits TransferOutUnderlying event on successful transfer of amount to receiver\n     */\n    function transferOutUnderlying(\n        address payable to,\n        uint256 amount\n    ) external nonReentrant returns (uint256 balanceBefore) {\n        if (msg.sender != address(comptroller)) {\n            revert(\"Invalid comptroller\");\n        }\n\n        flashLoanAmount += amount;\n        doTransferOut(to, amount);\n\n        balanceBefore = getCashPrior();\n        emit TransferOutUnderlying(underlying, to, amount);\n    }\n\n    /**\n     * @notice Transfers the underlying asset from the specified address.\n     * @dev Can only be called by the Comptroller contract. This function performs the actual transfer of the underlying\n     *      asset by calling the `doTransferIn` internal function.\n     * @param from The address from which the underlying asset is to be transferred.\n     * @param amount The amount of the underlying asset to transfer.\n     * @param fee The accrued fee\n     * @param balanceBefore Cash before transfer in\n     * requirements\n     *      - The caller must be the Comptroller contract.\n     * custom:reverts\n     *      - Reverts with \"Invalid Comptroller\" if the caller is not the Comptroller.\n     * custom:event Emits TransferOutUnderlying event on successful transfer of amount to receiver\n     */\n    function transferInUnderlyingAndVerify(\n        address payable from,\n        uint256 amount,\n        uint256 fee,\n        uint256 balanceBefore\n    ) external nonReentrant {\n        if (msg.sender != address(comptroller)) {\n            revert(\"Invalid comptroller\");\n        }\n\n        uint256 repayment = amount + fee;\n        doTransferIn(from, repayment);\n        flashLoanAmount -= amount;\n\n        if ((getCashPrior() - balanceBefore) < repayment) revert InsufficientRepaymentBalance();\n\n        emit TransferInUnderlyingAndVerify(underlying, from, repayment);\n    }\n\n    /**\n     * @notice Executes a flashLoan operation.\n     * @dev Transfers the amount to the receiver contract and ensures that the total repayment (amount + fee)\n     *      is returned by the receiver contract after the operation. The function performs checks to ensure the validity\n     *      of parameters, that flashLoan is enabled for the given asset, and that the total repayment is sufficient.\n     *      Reverts on invalid parameters, disabled flashLoans, or insufficient repayment.\n     * @param initiator The address that initiated the flash loan.\n     * @param receiver The address of the contract that will receive the flashLoan and execute the operation.\n     * @param amount The amount of asset to be loaned.\n     * @param param Additional encoded parameters passed with the flash loan.\n     * custom:requirements\n     *      - The `receiver` address must not be the zero address.\n     *      - FlashLoans must be enabled for the asset.\n     *      - The `receiver` contract must repay the loan with the appropriate fee.\n     * custom:reverts\n     *      - Reverts with `Flash loan not authorized for this account` if the initiator is not authorized for flash loans.\n     *      - Reverts with `FlashLoan not enabled` if flashLoans are disabled for any of the requested assets.\n     *      - Reverts with `Execute flashLoan failed` if the receiver contract fails to execute the operation.\n     *      - Reverts with `Insufficient repayment balance` if the repayment (amount + fee) is insufficient after the operation.\n     * custom:event Emits FlashLoanExecuted event on success\n     */\n    function executeFlashLoan(\n        address initiator,\n        address payable receiver,\n        uint256 amount,\n        bytes calldata param\n    ) external nonReentrant returns (uint256) {\n        if (!isFlashLoanEnabled) revert FlashLoanNotEnabled();\n        ensureNonZeroAddress(receiver);\n\n        // Check if the caller is authorized to execute flash loans\n        if (!comptroller.authorizedFlashLoan(initiator)) revert FlashLoanNotAuthorized();\n\n        // Tracks the flashLoan amount before transferring amount to the receiver\n        flashLoanAmount += amount;\n\n        // Transfer the underlying asset to the receiver\n        doTransferOut(receiver, amount);\n\n        uint256 balanceBefore = getCashPrior();\n        (uint256 protocolFee, uint256 supplierFee) = calculateFlashLoanFee(amount);\n        uint256 fee = protocolFee + supplierFee;\n        uint256 repayAmount = amount + fee;\n\n        // Call the execute operation on receiver contract\n        if (!IFlashLoanSimpleReceiver(receiver).executeOperation(underlying, amount, fee, msg.sender, param)) revert ExecuteFlashLoanFailed();\n\n        doTransferIn(receiver, repayAmount);\n        flashLoanAmount -= amount;\n\n        if ((getCashPrior() - balanceBefore) < repayAmount) revert InsufficientRepaymentBalance();\n        \n        // Transfer protocol fee to protocol share reserve\n        doTransferOut(protocolShareReserve, protocolFee);\n\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\n            address(comptroller),\n            underlying,\n            IProtocolShareReserve.IncomeType.FLASHLOAN\n        );\n\n        emit FlashLoanExecuted(receiver, underlying, amount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Enable or disable flash loan for the market\n     * custom:access Only Governance\n     * custom:event Emits ToggleFlashLoanEnabled event on success\n     */\n    function _toggleFlashLoan() external returns (uint256) {\n        ensureAllowed(\"_toggleFlashLoan()\");\n        isFlashLoanEnabled = !isFlashLoanEnabled;\n\n        emit ToggleFlashLoanEnabled(!isFlashLoanEnabled, isFlashLoanEnabled);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Update flashLoan fee mantissa\n     * @param protocolFeeMantissa_ FlashLoan protocol fee mantissa, transferred to protocol share reserve\n     * @param supplierFeeMantissa_ FlashLoan supplier fee mantissa, transferred to the supplier of the asset\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     * custom:access Only Governance\n     * custom:event Emits FlashLoanFeeUpdated event on success\n     */\n    function _setFlashLoanFeeMantissa(\n        uint256 protocolFeeMantissa_,\n        uint256 supplierFeeMantissa_\n    ) external returns (uint256) {\n        // update the signature\n        ensureAllowed(\"_setFlashLoanFeeMantissa(uint256,uint256)\");\n\n        emit FlashLoanFeeUpdated(\n            flashLoanProtocolFeeMantissa,\n            protocolFeeMantissa_,\n            flashLoanSupplierFeeMantissa,\n            supplierFeeMantissa_\n        );\n        flashLoanProtocolFeeMantissa = protocolFeeMantissa_;\n        flashLoanSupplierFeeMantissa = supplierFeeMantissa_;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModelV8 interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public {\n        ensureAdmin(msg.sender);\n        require(\n            accrualBlockNumber == 0 && borrowIndex == 0 && (initialExchangeRateMantissa_ > 0),\n            \"market may only be initialized once\"\n        );\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        // Set the comptroller\n        uint ComptrollerErr = _setComptroller(comptroller_);\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = block.number;\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        uint InterestModelErr = _setInterestRateModelFresh(interestRateModel_);\n        require(\n            (ComptrollerErr == uint(Error.NO_ERROR)) && (InterestModelErr == uint(Error.NO_ERROR)),\n            \"comptroller or interest model initialization failed\"\n        );\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     * up to the current block and writes new checkpoint to storage and\n     * reduce spread reserves to protocol share reserve\n     * if currentBlock - reduceReservesBlockNumber >= blockDelta\n     */\n    // @custom:event Emits AccrueInterest event\n    function accrueInterest() public virtual override returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = block.number;\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        ensureNoMathError(mathErr);\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            reservesPrior\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n                    uint(mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        (mathErr, blockDelta) = subUInt(currentBlockNumber, reduceReservesBlockNumber);\n        ensureNoMathError(mathErr);\n        if (blockDelta >= reduceReservesBlockDelta) {\n            reduceReservesBlockNumber = currentBlockNumber;\n            if (cashPrior < totalReservesNew) {\n                _reduceReservesFresh(cashPrior);\n            } else {\n                _reduceReservesFresh(totalReservesNew);\n            }\n        }\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Admin function to set a new comptroller\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // @custom:event Emits NewComptroller event\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint) {\n        // Check caller is admin\n        ensureAdmin(msg.sender);\n\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(comptroller, newComptroller);\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Governance function to accrue interest and update the interest rate model\n     * @param newInterestRateModel_ The new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel_) public override returns (uint) {\n        ensureAllowed(\"_setInterestRateModel(address)\");\n        checkAccrueInterest(FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel_);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        ensureNoMathError(err);\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        ensureNoMathError(err);\n        return result;\n    }\n\n    /**\n     * @notice open a debt position for the borrower\n     * @param borrower The address of the borrower\n     * @param borrowAmount The amount of underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     * @dev This function checks if the borrow is allowed, accrues interest, and updates the borrower's balance.\n     *      It also emits a Borrow event and calls the comptroller's borrowVerify function.\n     *      It reverts if the borrow is not allowed, if the market's block number is not current, or if the protocol has insufficient cash.\n     */\n    function borrowDebtPosition(address borrower, uint borrowAmount) external override returns (uint256) {\n        /* Revert if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        /* Revert if protocol has insufficient underlying cash */\n        if (getCashPrior() < borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        ensureNoMathError(vars.mathErr);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Calculates the protocol fee and supplier fee for a flash loan.\n     * @param amount The amount of the flash loan.\n     * @return protocolFee The portion of the fee allocated to the protocol.\n     * @return supplierFee The portion of the fee allocated to the supplier.\n     * @dev This function reverts if flash loans are not enabled.\n     */\n    function calculateFlashLoanFee(uint256 amount) public view returns (uint256, uint256) {\n        MathError mErr;\n        uint256 protocolFee;\n        uint256 supplierFee;\n\n        (mErr, protocolFee) = mulScalarTruncate(Exp({ mantissa: amount }), flashLoanProtocolFeeMantissa);\n        ensureNoMathError(mErr);\n\n        (mErr, supplierFee) = mulScalarTruncate(Exp({ mantissa: amount }), flashLoanSupplierFeeMantissa);\n        ensureNoMathError(mErr);\n\n        return (protocolFee, supplierFee);\n    }\n\n    /**\n     * @notice Transfers `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srvTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srvTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srvTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint256).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n        checkAccrueInterest(FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives vTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        ensureNoMathError(vars.mathErr);\n\n        /*\n         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens, vars.accountTokensNew);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param receiver The address of the account which is receiving the vTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfInternal(address receiver, uint mintAmount) internal nonReentrant returns (uint, uint) {\n        checkAccrueInterest(FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n\n        // mintBelahfFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintBehalfFresh(msg.sender, receiver, mintAmount);\n    }\n\n    /**\n     * @notice Payer supplies assets into the market and receiver receives vTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param payer The address of the account which is paying the underlying token\n     * @param receiver The address of the account which is receiving vToken\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfFresh(address payer, address receiver, uint mintAmount) internal returns (uint, uint) {\n        ensureNonZeroAddress(receiver);\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), receiver, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the payer and the mintAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(payer, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        ensureNoMathError(vars.mathErr);\n\n        /*\n         * We calculate the new total supply of vTokens and receiver token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[receiver] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[receiver], vars.mintTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[receiver] = vars.accountTokensNew;\n\n        /* We emit a MintBehalf event, and a Transfer event */\n        emit MintBehalf(payer, receiver, vars.actualMintAmount, vars.mintTokens, vars.accountTokensNew);\n        emit Transfer(address(this), receiver, vars.mintTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.mintVerify(address(this), receiver, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Redeemer redeems vTokens in exchange for the underlying assets, transferred to the receiver. Redeemer and receiver can be the same\n     *   address, or different addresses if the receiver was previously approved by the redeemer as a valid delegate (see MarketFacet.updateDelegate)\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemInternal(\n        address redeemer,\n        address payable receiver,\n        uint redeemTokens\n    ) internal nonReentrant returns (uint) {\n        checkAccrueInterest(FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(redeemer, receiver, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems underlying assets on behalf of some other address. This function is only available\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens, if called by a delegate\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function redeemUnderlyingInternal(\n        address redeemer,\n        address payable receiver,\n        uint redeemAmount\n    ) internal nonReentrant returns (uint) {\n        checkAccrueInterest(FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(redeemer, receiver, 0, redeemAmount);\n    }\n\n    /**\n     * @notice Redeemer redeems vTokens in exchange for the underlying assets, transferred to the receiver. Redeemer and receiver can be the same\n     *   address, or different addresses if the receiver was previously approved by the redeemer as a valid delegate (see MarketFacet.updateDelegate)\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param receiver The receiver of the tokens\n     * @param redeemTokensIn The number of vTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming vTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    // solhint-disable-next-line code-complexity\n    function redeemFresh(\n        address redeemer,\n        address payable receiver,\n        uint redeemTokensIn,\n        uint redeemAmountIn\n    ) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        ensureNoMathError(vars.mathErr);\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n                Exp({ mantissa: vars.exchangeRateMantissa }),\n                redeemTokensIn\n            );\n            ensureNoMathError(vars.mathErr);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n                redeemAmountIn,\n                Exp({ mantissa: vars.exchangeRateMantissa })\n            );\n            ensureNoMathError(vars.mathErr);\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        ensureNoMathError(vars.mathErr);\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_CASH_NOT_AVAILABLE);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /*\n         * We invoke doTransferOut for the receiver and the redeemAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n\n        uint feeAmount;\n        uint remainedAmount;\n        if (IComptroller(address(comptroller)).treasuryPercent() != 0) {\n            (vars.mathErr, feeAmount) = mulUInt(\n                vars.redeemAmount,\n                IComptroller(address(comptroller)).treasuryPercent()\n            );\n            ensureNoMathError(vars.mathErr);\n\n            (vars.mathErr, feeAmount) = divUInt(feeAmount, 1e18);\n            ensureNoMathError(vars.mathErr);\n\n            (vars.mathErr, remainedAmount) = subUInt(vars.redeemAmount, feeAmount);\n            ensureNoMathError(vars.mathErr);\n\n            address payable treasuryAddress = payable(IComptroller(address(comptroller)).treasuryAddress());\n            doTransferOut(treasuryAddress, feeAmount);\n\n            emit RedeemFee(redeemer, feeAmount, vars.redeemTokens);\n        } else {\n            remainedAmount = vars.redeemAmount;\n        }\n\n        doTransferOut(receiver, remainedAmount);\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, remainedAmount, vars.redeemTokens, vars.accountTokensNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Receiver gets the borrow on behalf of the borrower address\n     * @param borrower The borrower, on behalf of whom to borrow\n     * @param receiver The account that would receive the funds (can be the same as the borrower)\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function borrowInternal(\n        address borrower,\n        address payable receiver,\n        uint borrowAmount\n    ) internal nonReentrant returns (uint) {\n        checkAccrueInterest(FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(borrower, receiver, borrowAmount);\n    }\n\n    /**\n     * @notice Receiver gets the borrow on behalf of the borrower address\n     * @dev Before calling this function, ensure that the interest has been accrued\n     * @param borrower The borrower, on behalf of whom to borrow\n     * @param receiver The account that would receive the funds (can be the same as the borrower)\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint Returns 0 on success, otherwise revert (see ErrorReporter.sol for details).\n     */\n    function borrowFresh(address borrower, address payable receiver, uint borrowAmount) internal returns (uint) {\n        /* Revert if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        /* Revert if protocol has insufficient underlying cash */\n        if (getCashPrior() < borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        ensureNoMathError(vars.mathErr);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /*\n         * We invoke doTransferOut for the receiver and the borrowAmount.\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(receiver, borrowAmount);\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n        checkAccrueInterest(FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to another borrowing account\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n        checkAccrueInterest(FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer The account paying off the borrow\n     * @param borrower The account with the debt being payed off\n     * @param repayAmount The amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return (\n                failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        ensureNoMathError(vars.mathErr);\n\n        /* If repayAmount == type(uint256).max, repayAmount = accountBorrows */\n        if (repayAmount == type(uint256).max) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n        ensureNoMathError(vars.mathErr);\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n        ensureNoMathError(vars.mathErr);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) internal nonReentrant returns (uint, uint) {\n        checkAccrueInterest(FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        uint error = vTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, vTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    // solhint-disable-next-line code-complexity\n    function liquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) internal returns (uint, uint) {\n        /* Fail if liquidate not allowed */\n        uint allowed = comptroller.liquidateBorrowAllowed(\n            address(this),\n            address(vTokenCollateral),\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n\n        /* Verify vTokenCollateral market's block number equals current block number */\n        if (vTokenCollateral.accrualBlockNumber() != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n\n        /* Fail if repayAmount = type(uint256).max */\n        if (repayAmount == type(uint256).max) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n\n        /* Fail if repayBorrow fails */\n        uint err;\n        uint actualRepayAmount;\n        (err, actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (err != uint(Error.NO_ERROR)) {\n            return (fail(Error(err), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n            borrower,\n            address(this),\n            address(vTokenCollateral),\n            actualRepayAmount\n        );\n\n        require(\n            (err == uint(Error.NO_ERROR)) && (vTokenCollateral.balanceOf(borrower) >= seizeTokens),\n            \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED or LIQUIDATE_SEIZE_TOO_MUCH\"\n        );\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        if (address(vTokenCollateral) == address(this)) {\n            err = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            err = vTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(err == uint(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.liquidateBorrowVerify(\n            address(this),\n            address(vTokenCollateral),\n            liquidator,\n            borrower,\n            actualRepayAmount,\n            seizeTokens\n        );\n\n        return (uint(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another vToken.\n     *  Its absolutely critical to use msg.sender as the seizer vToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed vToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function seizeInternal(\n        address seizerToken,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) internal returns (uint) {\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        /* We call the defense and prime accrue interest hook */\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n     * @dev Governance function to set a new reserve factor\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and adds reserves by transferring from `msg.sender`\n     * @param addAmount Amount of addition to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n        checkAccrueInterest(FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n        uint error;\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n        (error, ) = _addReservesFresh(addAmount);\n        return error;\n    }\n\n    /**\n     * @notice Add reserves by transferring from caller\n     * @dev Requires fresh interest accrual\n     * @param addAmount Amount of addition to reserves\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n     */\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n        // totalReserves + actualAddAmount\n        uint totalReservesNew;\n        uint actualAddAmount;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\n         *  On success, the vToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n        /* Return (NO_ERROR, actualAddAmount) */\n        return (uint(Error.NO_ERROR), actualAddAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to protocol share reserve contract\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _reduceReservesFresh(uint reduceAmount) internal virtual returns (uint) {\n        if (reduceAmount == 0) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReserves - reduceAmount;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(protocolShareReserve, reduceAmount);\n\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\n            address(comptroller),\n            underlying,\n            IProtocolShareReserve.IncomeType.SPREAD\n        );\n\n        emit ReservesReduced(protocolShareReserve, reduceAmount, totalReserves);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Governance function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).\n     */\n    function _setInterestRateModelFresh(InterestRateModelV8 newInterestRateModel) internal returns (uint) {\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != block.number) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(interestRateModel, newInterestRateModel);\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint amount) internal virtual returns (uint);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint amount) internal virtual;\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return Tuple of error code and the calculated balance or 0 if error code is non-zero\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the vToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Tuple of error code and calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStoredInternal() internal view virtual returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows + flashLoanAmount - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n                totalCash + flashLoanAmount,\n                totalBorrows,\n                totalReserves\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    function ensureAllowed(string memory functionSig) private view {\n        require(\n            IAccessControlManagerV8(accessControlManager).isAllowedToCall(msg.sender, functionSig),\n            \"access denied\"\n        );\n    }\n\n    function ensureAdmin(address caller_) private view {\n        require(caller_ == admin, \"Unauthorized\");\n    }\n\n    function ensureNoMathError(MathError mErr) private pure {\n        require(mErr == MathError.NO_ERROR, \"math error\");\n    }\n\n    function ensureNonZeroAddress(address address_) private pure {\n        require(address_ != address(0), \"zero address\");\n    }\n\n    function ensureAccrueInterest() private {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n    }\n\n    function checkAccrueInterest(FailureInfo info) private returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), info);\n        }\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal view virtual returns (uint);\n}\n"
    },
    "contracts/Tokens/VTokens/VTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { ComptrollerInterface } from \"../../Comptroller/ComptrollerInterface.sol\";\nimport { InterestRateModelV8 } from \"../../InterestRateModels/InterestRateModelV8.sol\";\n\ncontract VTokenStorageBase {\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    bool internal _notEntered;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public decimals;\n\n    /**\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     */\n\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n    /**\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     */\n    uint internal constant reserveFactorMaxMantissa = 1e18;\n\n    /**\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address payable public pendingAdmin;\n\n    /**\n     * @notice Contract which oversees inter-vToken operations\n     */\n    ComptrollerInterface public comptroller;\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModelV8 public interestRateModel;\n\n    /**\n     * @notice Initial exchange rate used when minting the first VTokens (used when totalSupply = 0)\n     */\n    uint internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint public reserveFactorMantissa;\n\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint public borrowIndex;\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint public totalBorrows;\n\n    /**\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint public totalSupply;\n\n    /**\n     * @notice Official record of token balances for each account\n     */\n    mapping(address => uint) internal accountTokens;\n\n    /**\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping(address => mapping(address => uint)) internal transferAllowances;\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     * @notice Underlying asset for this VToken\n     */\n    address public underlying;\n\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n\n    /**\n     * @notice delta block after which reserves will be reduced\n     */\n    uint public reduceReservesBlockDelta;\n\n    /**\n     * @notice last block number at which reserves were reduced\n     */\n    uint public reduceReservesBlockNumber;\n\n    /**\n     * @notice address of protocol share reserve contract\n     */\n    address payable public protocolShareReserve;\n\n    /**\n     * @notice address of accessControlManager\n     */\n\n    address public accessControlManager;\n}\n\ncontract VTokenStorage is VTokenStorageBase {\n    /**\n     * @notice flashLoan is enabled for this market or not\n     */\n    bool public isFlashLoanEnabled;\n\n    /**\n     * @notice fee percentage collected by protocol on flashLoan\n     */\n    uint256 public flashLoanProtocolFeeMantissa;\n\n    /**\n     * @notice fee percentage collected by supplier on flashLoan\n     */\n    uint256 public flashLoanSupplierFeeMantissa;\n\n    /**\n     * @notice Amount of flashLoan taken by the receiver\n     * @dev This is used to track the amount of flashLoan taken in the current transaction\n     */\n    uint256 public flashLoanAmount;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n\nabstract contract VTokenInterface is VTokenStorage {\n    /**\n     * @notice Indicator that this is a vToken contract (for inspection)\n     */\n    bool public constant isVToken = true;\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint mintAmount, uint mintTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are minted behalf by payer to receiver\n     */\n    event MintBehalf(address payer, address receiver, uint mintAmount, uint mintTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens, uint256 totalSupply);\n\n    /**\n     * @notice Event emitted when tokens are redeemed and fee is transferred\n     */\n    event RedeemFee(address redeemer, uint feeAmount, uint redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        address vTokenCollateral,\n        uint seizeTokens\n    );\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Event emitted when pendingAdmin is accepted, which means admin has been updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(\n        InterestRateModelV8 oldInterestRateModel,\n        InterestRateModelV8 newInterestRateModel\n    );\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address protocolShareReserve, uint reduceAmount, uint newTotalReserves);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    /**\n     * @notice Event emitted when block delta for reduce reserves get updated\n     */\n    event NewReduceReservesBlockDelta(uint256 oldReduceReservesBlockDelta, uint256 newReduceReservesBlockDelta);\n\n    /**\n     * @notice Event emitted when address of ProtocolShareReserve contract get updated\n     */\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserve);\n\n    /**\n     * @notice Emitted when access control address is changed by admin\n     */\n    event NewAccessControlManager(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /**\n     * @notice Event emitted when flashLoanEnabled status is changed\n     */\n    event ToggleFlashLoanEnabled(bool previousStatus, bool newStatus);\n\n    /**\n     * @notice Event emitted when flashLoan is executed\n     */\n    event FlashLoanExecuted(address receiver, address underlying, uint256 amount);\n\n    /**\n     * @notice Event emitted when asset is transferred to receiver\n     */\n    event TransferOutUnderlying(address asset, address receiver, uint256 amount);\n\n    /**\n     * @notice Event emitted when asset is transferred from sender and verified\n     */\n    event TransferInUnderlyingAndVerify(address asset, address sender, uint256 amount);\n\n    /**\n     * @notice Event emitted when flashLoan fee mantissa is updated\n     */\n    event FlashLoanFeeUpdated(\n        uint256 oldFlashLoanProtocolFeeMantissa,\n        uint256 newFlashLoanProtocolFeeMantissa,\n        uint256 oldFlashLoanSupplierFeeMantissa,\n        uint256 newFlashLoanSupplierFeeMantissa\n    );\n\n    /*** Flash Loan Error***/\n    \n     error FlashLoanNotAuthorized();\n\n     error FlashLoanNotEnabled();\n\n     error ExecuteFlashLoanFailed();\n\n     error InsufficientRepaymentBalance();\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint amount) external virtual returns (bool);\n\n    function transferFrom(address src, address dst, uint amount) external virtual returns (bool);\n\n    function approve(address spender, uint amount) external virtual returns (bool);\n\n    function balanceOfUnderlying(address owner) external virtual returns (uint);\n\n    function totalBorrowsCurrent() external virtual returns (uint);\n\n    function borrowBalanceCurrent(address account) external virtual returns (uint);\n\n    function seize(address liquidator, address borrower, uint seizeTokens) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _acceptAdmin() external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setReserveFactor(uint newReserveFactorMantissa) external virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _reduceReserves(uint reduceAmount) external virtual returns (uint);\n\n    function borrowDebtPosition(address borrower, uint borrowAmount) external virtual returns (uint);\n\n    function balanceOf(address owner) external view virtual returns (uint);\n\n    function allowance(address owner, address spender) external view virtual returns (uint);\n\n    function getAccountSnapshot(address account) external view virtual returns (uint, uint, uint, uint);\n\n    function borrowRatePerBlock() external view virtual returns (uint);\n\n    function supplyRatePerBlock() external view virtual returns (uint);\n\n    function getCash() external view virtual returns (uint);\n\n    function exchangeRateCurrent() public virtual returns (uint);\n\n    function accrueInterest() public virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setComptroller(ComptrollerInterface newComptroller) public virtual returns (uint);\n\n    /*** Admin Function ***/\n    function _setInterestRateModel(InterestRateModelV8 newInterestRateModel) public virtual returns (uint);\n\n    function borrowBalanceStored(address account) public view virtual returns (uint);\n\n    function exchangeRateStored() public view virtual returns (uint);\n}\n\ninterface VBep20Interface {\n    /*** User Interface ***/\n\n    function mint(uint mintAmount) external returns (uint);\n\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint);\n\n    function redeem(uint redeemTokens) external returns (uint);\n\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n\n    function borrow(uint borrowAmount) external returns (uint);\n\n    function repayBorrow(uint repayAmount) external returns (uint);\n\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\n\n    function liquidateBorrow(\n        address borrower,\n        uint repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external returns (uint);\n\n    /*** Admin Functions ***/\n\n    function _addReserves(uint addAmount) external returns (uint);\n}\n\ninterface VDelegatorInterface {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) external;\n}\n\ninterface VDelegateInterface {\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) external;\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() external;\n}\n"
    },
    "contracts/Utils/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Careful Math\n * @author Venus\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c;\n        unchecked {\n            c = a * b;\n        }\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            unchecked {\n                return (MathError.NO_ERROR, a - b);\n            }\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c;\n        unchecked {\n            c = a + b;\n        }\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
    },
    "contracts/Utils/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { WeightFunction } from \"../Comptroller/Diamond/interfaces/IFacetBase.sol\";\n\ncontract ComptrollerErrorReporter {\n    /// @notice Thrown when You are already in the selected pool.\n    error AlreadyInSelectedPool();\n\n    /// @notice Thrown when One or more of your assets are not compatible with the selected pool.\n    error IncompatibleBorrowedAssets();\n\n    /// @notice Thrown when Switching to this pool would fail the liquidity check or lead to liquidation.\n    error LiquidityCheckFailed(uint256 errorCode, uint256 shortfall);\n\n    /// @notice Thrown when trying to modify the core pool (poolId == 0)\n    error CorePoolModificationNotAllowed();\n\n    /// @notice Thrown when input array lengths do not match\n    error ArrayLengthMismatch();\n\n    /// @notice Thrown when market trying to add in a pool is not listed in the core pool\n    error MarketNotListedInCorePool();\n\n    /// @notice Thrown when market is not set in the _poolMarkets mapping\n    error MarketConfigNotFound();\n\n    /// @notice Thrown when borrowing is not allowed in the selected pool for a given market.\n    error BorrowNotAllowedInPool();\n\n    /// @notice Thrown when trying to remove a market that is not listed in the given pool.\n    error PoolMarketNotFound(uint96 poolId, address vToken);\n\n    /// @notice Thrown when a given pool ID does not exist\n    error PoolDoesNotExist(uint96 poolId);\n\n    /// @notice Thrown when the pool label is empty\n    error EmptyPoolLabel();\n\n    /// @notice Thrown when a vToken is already listed in the specified pool\n    error MarketAlreadyListed(uint96 poolId, address vToken);\n\n    /// @notice Thrown when an invalid weighting strategy is provided\n    error InvalidWeightingStrategy(WeightFunction strategy);\n\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY,\n        INSUFFICIENT_BALANCE_FOR_VAI,\n        MARKET_NOT_COLLATERAL,\n        INVALID_LIQUIDATION_THRESHOLD\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        SET_VAI_MINT_RATE_CHECK,\n        SET_VAICONTROLLER_OWNER_CHECK,\n        SET_MINTED_VAI_REJECTION,\n        SET_TREASURY_OWNER_CHECK,\n        UNLIST_MARKET_NOT_LISTED,\n        SET_LIQUIDATION_THRESHOLD_VALIDATION,\n        COLLATERAL_FACTOR_GREATER_THAN_LIQUIDATION_THRESHOLD\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        COMPTROLLER_REJECTION,\n        COMPTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED,\n        TOKEN_PRICE_ERROR\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_COMPTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_COMPTROLLER_REJECTION,\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_COMPTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_COMPTROLLER_REJECTION,\n        REDEEM_CASH_NOT_AVAILABLE,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_COMPTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COMPTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_COMPTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n        TOKEN_GET_UNDERLYING_PRICE_ERROR,\n        REPAY_VAI_COMPTROLLER_REJECTION,\n        REPAY_VAI_FRESHNESS_CHECK,\n        VAI_MINT_EXCHANGE_CALCULATION_FAILED,\n        SFT_MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract VAIControllerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED, // The sender is not authorized to perform this action.\n        REJECTION, // The action would violate the comptroller, vaicontroller policy.\n        SNAPSHOT_ERROR, // The comptroller could not get the account borrows and exchange rate from the market.\n        PRICE_ERROR, // The comptroller could not obtain a required price of an asset.\n        MATH_ERROR, // A math calculation error occurred.\n        INSUFFICIENT_BALANCE_FOR_VAI // Caller does not have sufficient balance to mint VAI.\n    }\n\n    enum FailureInfo {\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_COMPTROLLER_OWNER_CHECK,\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        VAI_MINT_REJECTION,\n        VAI_BURN_REJECTION,\n        VAI_LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        VAI_LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        VAI_LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        VAI_LIQUIDATE_COMPTROLLER_REJECTION,\n        VAI_LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        VAI_LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        VAI_LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        VAI_LIQUIDATE_FRESHNESS_CHECK,\n        VAI_LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        VAI_LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        VAI_LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        VAI_LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        VAI_LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        VAI_LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        VAI_LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_FEE_CALCULATION_FAILED,\n        SET_TREASURY_OWNER_CHECK\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n"
    },
    "contracts/Utils/Exponential.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { CarefulMath } from \"./CarefulMath.sol\";\nimport { ExponentialNoError } from \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Venus\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: rational }));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({ mantissa: result }));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({ mantissa: result }));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({ mantissa: 0 }));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({ mantissa: 0 }));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({ mantissa: product }));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n        return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"
    },
    "contracts/Utils/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint internal constant expScale = 1e18;\n    uint internal constant doubleScale = 1e36;\n    uint internal constant halfExpScale = expScale / 2;\n    uint internal constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) internal pure returns (uint224) {\n        require(n < 2 ** 224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\n    }\n\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: add_(a.mantissa, b.mantissa) });\n    }\n\n    function add_(uint a, uint b) internal pure returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\n    }\n\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\n    }\n\n    function sub_(uint a, uint b) internal pure returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\n    }\n\n    function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: mul_(a.mantissa, b) });\n    }\n\n    function mul_(uint a, Exp memory b) internal pure returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\n    }\n\n    function mul_(Double memory a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: mul_(a.mantissa, b) });\n    }\n\n    function mul_(uint a, Double memory b) internal pure returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) internal pure returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\n    }\n\n    function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\n        return Exp({ mantissa: div_(a.mantissa, b) });\n    }\n\n    function div_(uint a, Exp memory b) internal pure returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\n    }\n\n    function div_(Double memory a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(a.mantissa, b) });\n    }\n\n    function div_(uint a, Double memory b) internal pure returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) internal pure returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) internal pure returns (Double memory) {\n        return Double({ mantissa: div_(mul_(a, doubleScale), b) });\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
